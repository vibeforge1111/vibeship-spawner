id: integration-patterns
name: Integration Patterns
category: enterprise
description: Use when designing system integrations, implementing API gateways, event-driven architectures, ESB patterns, or hybrid cloud connectivity

patterns:
  golden_rules:
    - rule: "Prefer async over sync"
      reason: "Reduces coupling, improves resilience"
    - rule: "API-first design"
      reason: "Contract before implementation"
    - rule: "Idempotent operations"
      reason: "Safe retries, exactly-once semantics"
    - rule: "Schema evolution"
      reason: "Backward/forward compatibility"
    - rule: "Circuit breakers everywhere"
      reason: "Prevent cascade failures"

  integration_types:
    synchronous:
      rest: "Request-reply over HTTP, user-facing"
      graphql: "Flexible queries, federated graphs"
      grpc: "High-performance internal, streaming"
    asynchronous:
      events: "Domain events, eventual consistency"
      commands: "Task queues, work distribution"
      cqrs: "Separate read/write models"

  pattern_selection:
    need_immediate_response:
      user_facing: "REST or GraphQL"
      internal: "gRPC"
    eventual_consistency:
      ordering_required: "Kafka with partitions"
      fan_out: "SNS/SQS"
      routing: "EventBridge"

  api_gateway_features:
    - "Rate limiting"
    - "Response caching"
    - "Circuit breaking"
    - "Request transformation"
    - "Authentication"
    - "Authorization"

  event_patterns:
    cloudevents: "Standard event format"
    outbox: "Transactional reliability"
    saga: "Distributed transactions"
    cqrs: "Command query separation"

anti_patterns:
  - pattern: "Point-to-point spaghetti"
    problem: "N systems = N*(N-1)/2 connections"
    solution: "Hub-and-spoke or event mesh"
  - pattern: "Synchronous chains"
    problem: "Cascading failures, high latency"
    solution: "Async events, choreography"
  - pattern: "Shared database integration"
    problem: "Tight coupling, schema changes break all"
    solution: "API contracts"
  - pattern: "No schema evolution"
    problem: "Breaking changes on update"
    solution: "Backward/forward compatible schemas"
  - pattern: "Ignoring idempotency"
    problem: "Duplicate processing on retry"
    solution: "Idempotency keys, deduplication"

implementation_checklist:
  api_gateway:
    - "Rate limiting configured per client/route"
    - "Response caching for GET endpoints"
    - "Circuit breakers for upstream services"
    - "Request/response logging"
    - "Authentication/authorization"
  event_driven:
    - "CloudEvents format adopted"
    - "Transactional outbox for reliability"
    - "Dead letter queues for failures"
    - "Schema registry for evolution"
    - "Idempotent consumers"
  hybrid_cloud:
    - "Service discovery across clouds"
    - "Consistent security policies"
    - "Data replication strategy defined"
    - "Latency-aware routing"
    - "Failover tested"
  legacy_integration:
    - "Canonical data model defined"
    - "Transformers for each format"
    - "Content enrichers configured"
    - "Error handling flows"
    - "Monitoring and alerting"

handoffs:
  - skill: enterprise-architecture
    trigger: "architecture decisions for integration"
  - skill: disaster-recovery
    trigger: "integration failover requirements"

ecosystem:
  api_gateways:
    - "Kong"
    - "Apigee"
    - "AWS API Gateway"
    - "Azure API Management"
  event_streaming:
    - "Apache Kafka"
    - "Apache Pulsar"
    - "AWS Kinesis"
    - "Azure Event Hubs"
  service_mesh:
    - "Istio"
    - "Linkerd"
    - "Consul Connect"
    - "AWS App Mesh"
  esb:
    - "Apache Camel"
    - "MuleSoft"
    - "Boomi"
    - "Workato"

sources:
  books:
    - "Enterprise Integration Patterns - Hohpe & Woolf"
    - "Building Event-Driven Microservices"
    - "Designing Data-Intensive Applications"
  standards:
    - "CloudEvents Specification"
    - "AsyncAPI Specification"
    - "OpenAPI Specification"
