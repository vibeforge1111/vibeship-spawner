id: microservices-patterns-collaboration
skill: microservices-patterns
version: 1.0.0

# ============================================================================
# RECEIVES FROM (Who delegates TO this skill)
# ============================================================================
receives_from:
  - skill: backend
    context: "Backend needs to scale or evolve independently"
    receives:
      - "Current architecture"
      - "Scaling requirements"
      - "Team structure"
    provides: "Service decomposition and communication patterns"

  - skill: api-designer
    context: "Need to design inter-service APIs"
    receives:
      - "Service contracts"
      - "Data requirements"
      - "Communication patterns"
    provides: "API design for service communication"

  - skill: infrastructure-as-code
    context: "Need to deploy microservices"
    receives:
      - "Service topology"
      - "Scaling requirements"
      - "Network policies"
    provides: "Deployment patterns and infrastructure requirements"

  - skill: performance-optimization
    context: "Need to optimize distributed system"
    receives:
      - "Latency requirements"
      - "Current bottlenecks"
      - "Scaling needs"
    provides: "Performance patterns for distributed systems"

# ============================================================================
# DELEGATION TRIGGERS
# ============================================================================
delegation_triggers:
  - trigger: "async|event|message|queue"
    delegate_to: queue-workers
    pattern: parallel
    context: "Need async service communication"
    handoff_data:
      - "Event types"
      - "Message patterns"
      - "Delivery guarantees"
    receive: "Message queue implementation"

  - trigger: "api|contract|version"
    delegate_to: api-designer
    pattern: sequential
    context: "Need to design service APIs"
    handoff_data:
      - "Service boundaries"
      - "Data contracts"
      - "Versioning needs"
    receive: "API design and contracts"

  - trigger: "deploy|kubernetes|docker"
    delegate_to: infrastructure-as-code
    pattern: sequential
    context: "Need to deploy services"
    handoff_data:
      - "Service topology"
      - "Scaling requirements"
      - "Health checks"
    receive: "Deployment configuration"

  - trigger: "trace|monitor|observe"
    delegate_to: observability-sre
    pattern: parallel
    context: "Need distributed tracing"
    handoff_data:
      - "Service map"
      - "Key metrics"
      - "Alert requirements"
    receive: "Observability setup"

  - trigger: "database|data|schema"
    delegate_to: database-schema-design
    pattern: parallel
    context: "Need per-service databases"
    handoff_data:
      - "Service boundaries"
      - "Data ownership"
      - "Sync requirements"
    receive: "Database design per service"

  - trigger: "rate limit|throttle"
    delegate_to: rate-limiting
    pattern: parallel
    context: "Need rate limiting between services"
    handoff_data:
      - "Service limits"
      - "Client quotas"
      - "Backpressure requirements"
    receive: "Rate limiting configuration"

  - trigger: "cache|performance|latency"
    delegate_to: caching-patterns
    pattern: parallel
    context: "Need caching between services"
    handoff_data:
      - "Cache requirements"
      - "Invalidation patterns"
      - "Consistency needs"
    receive: "Caching strategy"

# ============================================================================
# FEEDBACK LOOPS
# ============================================================================
feedback_loops:
  receives_feedback_from:
    - skill: observability-sre
      signal: "High latency between services"
      action: "Review call patterns, add caching, consider async"

    - skill: observability-sre
      signal: "Cascade failures detected"
      action: "Add circuit breakers, improve fallbacks"

    - skill: performance-optimization
      signal: "N+1 service calls"
      action: "Aggregate endpoints, denormalize data"

    - skill: infrastructure-as-code
      signal: "Services not scaling independently"
      action: "Review coupling, separate databases"

    - skill: queue-workers
      signal: "Event processing delays"
      action: "Scale consumers, review event volume"

  sends_feedback_to:
    - skill: backend
      signal: "Service boundaries identified"
      action: "Refactor monolith along bounded contexts"

    - skill: api-designer
      signal: "API versioning needed"
      action: "Design backward-compatible API changes"

    - skill: infrastructure-as-code
      signal: "Service discovery needed"
      action: "Set up Consul, Kubernetes DNS, or similar"

    - skill: observability-sre
      signal: "Distributed tracing required"
      action: "Implement OpenTelemetry across services"

    - skill: database-schema-design
      signal: "Database per service required"
      action: "Design service-specific schemas with event sync"

# ============================================================================
# CROSS-DOMAIN INSIGHTS
# ============================================================================
cross_domain_insights:
  - domain: Distributed Systems
    insight: |
      Distributed systems engineers know the fallacies:
      - The network is reliable (it's not)
      - Latency is zero (it's not)
      - Bandwidth is infinite (it's not)
      - The network is secure (it's not)
      - Topology doesn't change (it does)
      - There is one administrator (there isn't)
      - Transport cost is zero (it's not)
      - The network is homogeneous (it's not)

      Every microservices decision must account for these.
    applies_when: "Designing any distributed system"

  - domain: Site Reliability Engineering
    insight: |
      SREs know microservices multiply operational complexity:
      - N services = N deployment pipelines
      - Debugging spans multiple logs
      - Partial failures are the norm
      - Rollback is service-by-service
      - On-call needs distributed systems knowledge

      Operational readiness scales with service count.
    applies_when: "Operating microservices in production"

  - domain: Domain-Driven Design
    insight: |
      DDD practitioners understand service boundaries:
      - Bounded contexts define natural service edges
      - Aggregates shouldn't span services
      - Context maps show integration patterns
      - Ubiquitous language per service

      Good microservices follow domain boundaries.
    applies_when: "Decomposing into services"

  - domain: Organization Design
    insight: |
      Conway's Law: Systems mirror communication structures.
      - Team boundaries often become service boundaries
      - Ownership is clearer with service-per-team
      - Cross-team coordination = service coupling
      - Small teams (2-pizza) own small services

      Microservices are also an organizational pattern.
    applies_when: "Deciding service boundaries"

# ============================================================================
# COMMON COMBINATIONS
# ============================================================================
common_combinations:
  - name: Service Decomposition
    skills:
      - microservices-patterns
      - backend
      - database-schema-design
    workflow: |
      1. Identify bounded contexts (microservices-patterns)
      2. Define service boundaries (microservices-patterns)
      3. Design per-service databases (database-schema-design)
      4. Implement services (backend)
      5. Add event-driven sync (queue-workers)
      6. Set up observability (observability-sre)

  - name: Service Communication
    skills:
      - microservices-patterns
      - queue-workers
      - api-designer
    workflow: |
      1. Identify sync vs async needs (microservices-patterns)
      2. Design service APIs (api-designer)
      3. Set up message broker (queue-workers)
      4. Implement circuit breakers (microservices-patterns)
      5. Add correlation IDs (microservices-patterns)
      6. Monitor communication (observability-sre)

  - name: Resilient Services
    skills:
      - microservices-patterns
      - rate-limiting
      - caching-patterns
    workflow: |
      1. Add timeouts to all calls (microservices-patterns)
      2. Implement circuit breakers (microservices-patterns)
      3. Add rate limiting (rate-limiting)
      4. Cache service responses (caching-patterns)
      5. Implement bulkheads (microservices-patterns)
      6. Test failure scenarios (microservices-patterns)

  - name: Service Deployment
    skills:
      - microservices-patterns
      - infrastructure-as-code
      - observability-sre
    workflow: |
      1. Containerize services (infrastructure-as-code)
      2. Add health checks (microservices-patterns)
      3. Set up Kubernetes (infrastructure-as-code)
      4. Configure service discovery (infrastructure-as-code)
      5. Add distributed tracing (observability-sre)
      6. Set up alerting (observability-sre)

  - name: Event-Driven Architecture
    skills:
      - microservices-patterns
      - queue-workers
      - database-schema-design
    workflow: |
      1. Identify events (microservices-patterns)
      2. Design event schemas (queue-workers)
      3. Set up event store (database-schema-design)
      4. Implement event sourcing (microservices-patterns)
      5. Add saga orchestration (microservices-patterns)
      6. Handle eventual consistency (microservices-patterns)

# ============================================================================
# ECOSYSTEM
# ============================================================================
ecosystem:
  primary_tools:
    - "Docker - Container runtime"
    - "Kubernetes - Container orchestration"
    - "OpenTelemetry - Distributed tracing"
    - "gRPC - Service communication"
    - "opossum - Circuit breaker"

  service_communication:
    - name: gRPC
      use_when: "Internal service-to-service communication"
      features: "Type-safe, efficient, streaming"

    - name: REST/HTTP
      use_when: "External APIs, simple communication"
      features: "Universal, well-understood"

    - name: GraphQL Federation
      use_when: "Complex data aggregation"
      features: "Single API for clients, distributed resolvers"

  message_brokers:
    - name: RabbitMQ
      use_when: "Complex routing, work queues"
      features: "Exchanges, bindings, dead letter"

    - name: Apache Kafka
      use_when: "Event streaming, high volume"
      features: "Persistent log, replay, streams"

    - name: NATS
      use_when: "Simple, fast messaging"
      features: "Lightweight, pub/sub, request/reply"

  service_mesh:
    - name: Istio
      use_when: "Full-featured service mesh"
      features: "Traffic management, security, observability"

    - name: Linkerd
      use_when: "Lightweight service mesh"
      features: "Simple, Rust-based, low overhead"

    - name: Consul Connect
      use_when: "Service discovery with mesh"
      features: "DNS-based discovery, intentions"

  observability:
    - name: Jaeger
      purpose: "Distributed tracing"

    - name: Prometheus
      purpose: "Metrics collection"

    - name: Grafana
      purpose: "Visualization and dashboards"

    - name: ELK Stack
      purpose: "Log aggregation"


