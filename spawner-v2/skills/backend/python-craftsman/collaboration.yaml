# Python Craftsman Collaboration Model
# How this skill works with other AI memory specialists

prerequisites:
  skills: []
  knowledge:
    - "Python 3.10+ syntax (match, union types)"
    - "Basic async/await understanding"
    - "Package management concepts"
    - "Type hint basics"

complementary_skills:
  - skill: api-designer
    relationship: "API implementation"
    brings: "FastAPI routes, request/response models, validation"

  - skill: test-architect
    relationship: "Python testing"
    brings: "pytest patterns, fixtures, async testing"

  - skill: data-engineer
    relationship: "Data processing"
    brings: "Pandas patterns, ETL code, data validation"

  - skill: sdk-builder
    relationship: "Library design"
    brings: "Public API design, packaging, documentation"

  - skill: performance-hunter
    relationship: "Python performance"
    brings: "Profiling, optimization, memory management"

  - skill: docs-engineer
    relationship: "Documentation"
    brings: "Docstrings, API docs, type documentation"

delegation:
  - trigger: "API endpoint design"
    delegate_to: api-designer
    pattern: parallel
    context: "Endpoint requirements"
    receive: "Route structure and schemas"

  - trigger: "test strategy for Python code"
    delegate_to: test-architect
    pattern: sequential
    context: "Code to be tested"
    receive: "Test plan with fixtures"

  - trigger: "data processing pipeline"
    delegate_to: data-engineer
    pattern: parallel
    context: "Data transformation needs"
    receive: "Pipeline design"

  - trigger: "public library API"
    delegate_to: sdk-builder
    pattern: sequential
    context: "Library purpose and users"
    receive: "API surface design"

  - trigger: "performance bottleneck"
    delegate_to: performance-hunter
    pattern: sequential
    context: "Slow code or memory issues"
    receive: "Profiling results and recommendations"

  - trigger: "documentation needs"
    delegate_to: docs-engineer
    pattern: parallel
    context: "What to document"
    receive: "Documentation structure"

collaboration_patterns:
  sequential:
    - "I design models, then api-designer creates routes"
    - "I write code, then test-architect designs tests"
    - "I optimize, then performance-hunter validates"

  parallel:
    - "I write implementation while docs-engineer writes docs"
    - "I build core while sdk-builder designs public API"

  review:
    - "Review api-designer's FastAPI code for Python patterns"
    - "Review test-architect's fixtures for proper async handling"
    - "Review data-engineer's code for type safety"

cross_domain_insights:
  - domain: rust
    insight: "Result<T, E> pattern makes errors explicit in types"
    applies_when: "Designing error handling without exceptions"

  - domain: functional-programming
    insight: "Immutable by default prevents unexpected state changes"
    applies_when: "Designing data models (frozen dataclasses, Pydantic)"

  - domain: go
    insight: "Explicit is better than implicit (no exceptions, interfaces)"
    applies_when: "Designing clear function contracts"

  - domain: java
    insight: "Interface segregation keeps dependencies minimal"
    applies_when: "Designing class hierarchies and protocols"

  - domain: unix-philosophy
    insight: "Do one thing well, compose larger from smaller"
    applies_when: "Designing modules and functions"

ecosystem:
  primary_tools:
    - "uv - Fast Python package manager"
    - "ruff - Fast linter and formatter"
    - "mypy - Static type checker"
    - "pytest - Testing framework"
    - "pydantic - Data validation"

  alternatives:
    - name: poetry
      use_when: "Need mature dependency resolution"
      avoid_when: "Speed is priority (uv is 10x faster)"

    - name: black
      use_when: "Team already using it"
      avoid_when: "Starting fresh (ruff includes formatter)"

    - name: pyright
      use_when: "Need faster type checking, VS Code integration"
      avoid_when: "Need strictest Python type checking"

    - name: hatch
      use_when: "Need build system with environment management"
      avoid_when: "Simple projects (uv is simpler)"

    - name: attrs
      use_when: "Need more control than dataclasses"
      avoid_when: "Pydantic validation is needed"

  deprecated:
    - "setup.py for modern packages"
    - "requirements.txt without lock files"
    - "Python 3.8 (end of life)"
    - "typing.Optional instead of X | None"
    - "Union[X, Y] instead of X | Y"
    - "Dict, List, Tuple from typing instead of builtins"
