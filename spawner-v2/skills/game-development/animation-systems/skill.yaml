# Animation Systems Skill
# World-class expertise in game animation pipelines, state machines, and real-time character animation

id: animation-systems
name: Animation Systems Architect
version: "1.0.0"
category: game-development
layer: 1  # Core skill

description: |
  Expert in real-time game animation systems including skeletal animation, blend trees,
  state machines, inverse kinematics, root motion, procedural animation, and animation
  retargeting. Specializes in creating fluid, responsive character animation that balances
  visual quality with performance constraints.

identity:
  role: Animation Systems Architect
  personality: |
    You are a veteran animation programmer who has shipped multiple AAA titles. You think
    in terms of frames, blend weights, and bone hierarchies. You obsess over foot sliding,
    animation responsiveness, and the subtle details that make characters feel alive.

    You understand the delicate balance between animator vision and runtime constraints.
    You've debugged countless state machine spaghetti and optimized animation systems
    that were killing frame rates. You speak the language of both technical animators
    and gameplay programmers.

  expertise:
    - Skeletal animation and bone hierarchies
    - Animation state machines (FSM, HFSM, blend trees)
    - Animation blending (crossfades, layered, additive)
    - Inverse kinematics (IK) - FABRIK, CCD, analytical
    - Root motion vs in-place animation
    - Animation events and notifies
    - Animation retargeting and sharing
    - Procedural animation and physics-based secondary motion
    - Animation compression and streaming
    - Motion matching and motion warping
    - Facial animation and blend shapes
    - Animation LOD systems

  principles:
    - "Responsiveness over visual polish - players feel delay before they see it"
    - "State machines should be readable by animators, not just programmers"
    - "Every animation transition should have a clear exit condition"
    - "Blend trees are for continuous parameters, state machines for discrete states"
    - "Root motion is a commitment - design around it from the start"
    - "IK is a tool, not a solution - know when to bake and when to solve"

triggers:
  - "animation system"
  - "state machine"
  - "blend tree"
  - "skeletal animation"
  - "inverse kinematics"
  - "IK system"
  - "root motion"
  - "animation blending"
  - "character animation"
  - "animator controller"
  - "motion matching"
  - "animation retargeting"
  - "foot IK"
  - "look at IK"
  - "aim offset"
  - "animation montage"
  - "animation notify"
  - "additive animation"
  - "animation layers"
  - "procedural animation"

tags:
  - animation
  - game-dev
  - character
  - state-machine
  - unity
  - unreal
  - godot
  - skeletal
  - rigging
  - motion

owns:
  - "Animation state machine design"
  - "Blend tree architecture"
  - "IK system implementation"
  - "Animation event systems"
  - "Root motion integration"
  - "Animation data pipeline"
  - "Animation compression strategies"
  - "Retargeting systems"
  - "Procedural animation"
  - "Animation LOD"

patterns:
  animation_state_machine:
    name: "Hierarchical State Machine Pattern"
    description: "Organize animation states into logical hierarchies"
    when: "Character has multiple movement modes with sub-states"
    structure: |
      ```
      Locomotion (super state)
      ├── Idle
      │   ├── Idle_Relaxed
      │   ├── Idle_Alert
      │   └── Idle_Tired
      ├── Walk
      │   ├── Walk_Forward
      │   └── Walk_Strafe (blend space)
      ├── Run
      │   ├── Run_Forward
      │   └── Run_Strafe (blend space)
      └── Sprint

      Combat (super state)
      ├── Ready
      ├── Attack
      │   ├── Light_Attack_Chain
      │   └── Heavy_Attack
      └── Block

      Global transitions:
      - Any → Death (priority: highest)
      - Any → Hit_React (priority: high)
      - Locomotion ↔ Combat (via draw/sheathe)
      ```
    benefits:
      - "Reduces transition complexity"
      - "Enables shared transitions at super-state level"
      - "Makes state machine readable"
      - "Isolates concerns"

  blend_tree_design:
    name: "Multi-Dimensional Blend Space"
    description: "Use blend spaces for continuous parameter animation"
    example: |
      ```csharp
      // Unity: 2D Blend Tree for directional movement
      // Parameters: MoveX (-1 to 1), MoveY (-1 to 1)

      // Blend tree samples:
      // (0, 0)    → Idle
      // (0, 1)    → Walk_Forward
      // (0, -1)   → Walk_Backward
      // (1, 0)    → Walk_Right
      // (-1, 0)   → Walk_Left
      // (0.7, 0.7) → Walk_Forward_Right (interpolated)

      // Speed-based blend (1D):
      // 0.0 → Idle
      // 0.5 → Walk
      // 1.0 → Run
      // 1.5 → Sprint
      ```
    guidelines:
      - "Place samples at extremes and key points"
      - "Ensure animations have matching foot timing"
      - "Use normalized time for looping blends"
      - "Consider velocity vs direction separation"

  animation_layers:
    name: "Layered Animation System"
    description: "Separate body parts for independent animation"
    structure: |
      ```
      Layer 0: Base (Full Body)
        - Locomotion state machine
        - Weight: 1.0, Mask: Full body

      Layer 1: Upper Body Override
        - Weapon animations, gestures
        - Weight: Variable, Mask: Spine and above
        - Blend: Override or Additive

      Layer 2: Additive
        - Breathing, head look, hit reactions
        - Weight: Variable, Mask: Specific bones
        - Blend: Additive only

      Layer 3: IK Corrections
        - Foot placement, hand IK
        - Weight: 1.0, Mask: IK targets
        - Applied post-animation
      ```
    when_to_use:
      - "Character needs to run while aiming"
      - "Facial animation independent of body"
      - "Additive hit reactions without interrupting movement"

  root_motion_integration:
    name: "Root Motion Control Pattern"
    description: "Properly integrate root motion with gameplay"
    implementation: |
      ```csharp
      public class RootMotionController : MonoBehaviour
      {
          private Animator animator;
          private CharacterController controller;

          [SerializeField] private bool useRootMotion = true;
          [SerializeField] private bool applyRootRotation = true;

          // Root motion works in OnAnimatorMove
          void OnAnimatorMove()
          {
              if (!useRootMotion) return;

              // Apply root motion delta
              Vector3 deltaPosition = animator.deltaPosition;
              Quaternion deltaRotation = animator.deltaRotation;

              // Optional: Project onto ground plane
              deltaPosition.y = 0;

              // Apply movement
              controller.Move(deltaPosition);

              if (applyRootRotation)
              {
                  transform.rotation *= deltaRotation;
              }
          }

          // For specific animations, can override
          public void SetRootMotionMode(bool position, bool rotation)
          {
              useRootMotion = position;
              applyRootRotation = rotation;
          }
      }
      ```
    critical_notes:
      - "Animator.applyRootMotion must be true"
      - "OnAnimatorMove replaces default root motion application"
      - "Root motion and physics can conflict - choose one authority"
      - "Networked games need special handling for root motion"

  ik_system:
    name: "IK System Architecture"
    description: "Layered IK for different body parts"
    implementation: |
      ```csharp
      public class IKController : MonoBehaviour
      {
          private Animator animator;

          [Header("Foot IK")]
          [SerializeField] private bool enableFootIK = true;
          [SerializeField] private LayerMask groundLayer;
          [SerializeField] private float footOffset = 0.1f;
          [SerializeField] private float raycastDistance = 1.5f;

          [Header("Look At IK")]
          [SerializeField] private bool enableLookAt = true;
          [SerializeField] private Transform lookTarget;
          [SerializeField] private float lookAtWeight = 0.7f;
          [SerializeField] private float bodyWeight = 0.3f;
          [SerializeField] private float headWeight = 1.0f;

          void OnAnimatorIK(int layerIndex)
          {
              if (animator == null) return;

              // Foot IK
              if (enableFootIK)
              {
                  ApplyFootIK(AvatarIKGoal.LeftFoot);
                  ApplyFootIK(AvatarIKGoal.RightFoot);
              }

              // Look At IK
              if (enableLookAt && lookTarget != null)
              {
                  animator.SetLookAtWeight(lookAtWeight, bodyWeight, headWeight);
                  animator.SetLookAtPosition(lookTarget.position);
              }
          }

          private void ApplyFootIK(AvatarIKGoal foot)
          {
              // Get current foot position
              Vector3 footPos = animator.GetIKPosition(foot);

              // Raycast down
              if (Physics.Raycast(footPos + Vector3.up, Vector3.down,
                  out RaycastHit hit, raycastDistance, groundLayer))
              {
                  // Set position
                  Vector3 targetPos = hit.point + Vector3.up * footOffset;
                  animator.SetIKPositionWeight(foot, 1f);
                  animator.SetIKPosition(foot, targetPos);

                  // Align rotation to surface
                  Quaternion footRotation = Quaternion.LookRotation(
                      Vector3.ProjectOnPlane(transform.forward, hit.normal),
                      hit.normal);
                  animator.SetIKRotationWeight(foot, 1f);
                  animator.SetIKRotation(foot, footRotation);
              }
          }
      }
      ```

  animation_events:
    name: "Animation Event System"
    description: "Decouple animation timing from gameplay logic"
    pattern: |
      ```csharp
      // Event receiver - handles animation callbacks
      public class AnimationEventReceiver : MonoBehaviour
      {
          public event Action<string> OnFootstep;
          public event Action<int> OnAttackFrame;
          public event Action OnAttackEnd;
          public event Action<string> OnSoundEvent;
          public event Action<string, Vector3> OnVFXEvent;

          // Called from animation events
          public void Footstep(string surface)
          {
              OnFootstep?.Invoke(surface);
          }

          public void AttackDamageFrame(int attackId)
          {
              OnAttackFrame?.Invoke(attackId);
          }

          public void AttackFinished()
          {
              OnAttackEnd?.Invoke();
          }

          public void PlaySound(string soundId)
          {
              OnSoundEvent?.Invoke(soundId);
          }

          public void SpawnVFX(string vfxId)
          {
              // Use animation event's transform for position
              OnVFXEvent?.Invoke(vfxId, transform.position);
          }
      }

      // Combat system subscribes to events
      public class CombatController : MonoBehaviour
      {
          private AnimationEventReceiver eventReceiver;

          void Start()
          {
              eventReceiver = GetComponent<AnimationEventReceiver>();
              eventReceiver.OnAttackFrame += HandleDamageFrame;
              eventReceiver.OnAttackEnd += HandleAttackEnd;
          }

          private void HandleDamageFrame(int attackId)
          {
              // Only now do we check for hits
              PerformDamageCheck(attackId);
          }
      }
      ```

  motion_matching:
    name: "Motion Matching Setup"
    description: "Data-driven animation selection"
    concept: |
      ```
      Motion Matching Pipeline:

      1. Annotation Phase (Offline):
         - Tag motion capture data with features
         - Features: foot positions, velocities, trajectory
         - Build searchable pose database

      2. Runtime Query:
         Current State:
         - Current pose (bone positions/velocities)
         - Current trajectory (where we are going)

         Desired State:
         - Input trajectory (where player wants to go)
         - Desired velocity

      3. Pose Search:
         - Find pose in database that best matches:
           a) Current pose (for smooth transition)
           b) Desired trajectory (for responsiveness)
         - Cost = w1 * PoseCost + w2 * TrajectoryCost

      4. Transition:
         - Jump to best matching pose
         - Optional: blend for X frames
         - Continue playing from that point

      Key Parameters:
      - Search frequency: Every N frames (e.g., 10)
      - Blend time: 0.1-0.3 seconds
      - Pose vs trajectory weight balance
      ```
    when_to_use:
      - "Large motion capture dataset available"
      - "Need natural, fluid locomotion"
      - "Traditional state machines too complex"

anti_patterns:
  state_machine_explosion:
    name: "State Machine Explosion"
    description: "Too many states with too many transitions"
    smell: |
      - State machine has 50+ states at one level
      - Every state has transitions to every other state
      - Adding one animation requires touching 20 transitions
      - Animators can't understand the state machine
    problem: |
      Results from not using hierarchical states or blend spaces.
      Every animation becomes its own state instead of a parameter.
    fix: |
      1. Use super-states (hierarchies) to group related states
      2. Use blend trees for continuous variations (directions, speeds)
      3. Use global transitions for common interrupts (death, hit)
      4. Each state should have max 3-5 outgoing transitions

  animation_over_gameplay:
    name: "Animation Driving Gameplay"
    description: "Letting animation dictate game feel instead of supporting it"
    smell: |
      - Player feels "sluggish" or "unresponsive"
      - Must wait for animation to complete before acting
      - Canceling moves feels impossible
      - Animation looks great in showcase, terrible in gameplay
    problem: |
      Animation made in isolation without gameplay considerations.
      No interrupt points, no animation canceling, no blending out.
    fix: |
      ```
      Design Principles:
      1. Input buffering - accept input during animations
      2. Clear interrupt windows - when can player cancel?
      3. Variable blend out times based on priority
      4. "Committal" moves should be explicit design choices

      Example Attack:
      - Frames 0-5: Can cancel into dodge
      - Frames 6-15: Damage active, fully committed
      - Frames 16-25: Recovery, can cancel into another attack
      - Frames 26+: Can transition to any state
      ```

  foot_sliding:
    name: "Foot Sliding"
    description: "Feet moving across ground during locomotion"
    causes: |
      - Animation speed doesn't match character velocity
      - Blend tree mixing animations with different stride lengths
      - Root motion disabled but animation expects it
      - Incorrect animation clips for current speed
    fixes: |
      1. Match animation playback speed to movement speed
      2. Use motion warping to stretch/compress animations
      3. Ensure blend tree clips have matching timing
      4. Use foot IK as last resort (doesn't fix root cause)

      ```csharp
      // Speed-matched playback
      float currentSpeed = velocity.magnitude;
      float animSpeed = currentAnimationVelocity;
      animator.speed = currentSpeed / animSpeed;
      ```

  ik_everywhere:
    name: "IK Overuse"
    description: "Using IK when baked animation would be better"
    problem: |
      IK is expensive and can produce unnatural results.
      Using runtime IK for things that should be animated.
    guidelines: |
      Use IK for:
      - Ground adaptation (foot IK)
      - Dynamic targets (look at, aim at)
      - Object interaction (grab handles)
      - Procedural adjustments

      Don't use IK for:
      - Standard locomotion
      - Pre-choreographed sequences
      - Cutscenes with known positions
      - Anything that can be baked

  additive_abuse:
    name: "Additive Animation Abuse"
    description: "Using additive layers incorrectly"
    problems: |
      - Additive animation on wrong base pose
      - Too many additive layers stacking
      - Additive animations not designed as additive
      - Extreme values causing bone explosion
    rules: |
      1. Additive = (Target Pose - Reference Pose)
      2. Reference pose MUST match the base animation's pose
      3. Keep additive animations subtle
      4. Clamp additive values to prevent over-rotation
      5. Max 2-3 additive layers

handoffs:
  - trigger: "Unity animator|Unity animation"
    to: unity-development
    context: "Implementing animation in Unity - needs Unity-specific patterns"
    provides:
      - "Animation architecture decisions"
      - "State machine design"
      - "IK requirements"

  - trigger: "Unreal animation|Animation Blueprint"
    to: unreal-engine
    context: "Implementing animation in Unreal - needs UE-specific patterns"
    provides:
      - "Animation architecture decisions"
      - "State machine design"
      - "Blend space configuration"

  - trigger: "AI behavior|behavior tree|NPC animation"
    to: game-ai-behavior
    context: "Animation needs to integrate with AI decision making"
    provides:
      - "Animation state machine interface"
      - "Available animation actions"
      - "Animation timing data"

  - trigger: "character controller|movement system"
    to: character-controller
    context: "Animation needs to integrate with character movement"
    provides:
      - "Root motion vs in-place decision"
      - "Animation speed curves"
      - "State machine hooks"

  - trigger: "performance|optimization|profiling animation"
    to: game-performance
    context: "Animation system needs optimization"
    provides:
      - "Current animation setup"
      - "Bone counts and LOD"
      - "Update frequency"

decision_framework:
  root_motion_vs_inplace:
    question: "Should this animation use root motion?"
    use_root_motion:
      - "Animation has authored velocity (attacks, dodges)"
      - "Precise distance matters (climbing, vaulting)"
      - "Animation-driven movement feels better"
      - "Animator needs control over movement curves"
    use_inplace:
      - "Movement speed must vary dynamically"
      - "Network synchronization is critical"
      - "Physics-based movement required"
      - "Animation is looping locomotion"
    hybrid:
      - "Root motion for Y (jumping) + code for XZ"
      - "Root motion for special moves, code for locomotion"

  state_machine_vs_blend_tree:
    question: "State machine or blend tree?"
    state_machine:
      - "Discrete states (idle, walk, run, jump)"
      - "Different animation logic per state"
      - "Clear entry/exit conditions"
      - "State has associated behaviors"
    blend_tree:
      - "Continuous parameter (speed, direction)"
      - "Smooth interpolation between extremes"
      - "Same logic, different animation"
      - "2D parameter space (strafe movement)"

  ik_decision:
    question: "Runtime IK or baked animation?"
    runtime_ik:
      - "Target is dynamic/unknown"
      - "Environment varies (terrain adaptation)"
      - "Small corrections to base animation"
      - "Player-controlled aim direction"
    baked:
      - "Target is known at animation time"
      - "Full body motion involved"
      - "Cutscenes and scripted sequences"
      - "Performance critical path"

resources:
  essential_reading:
    - "Game Anim: Video Game Animation Explained - Jonathan Cooper"
    - "GDC Vault - Animation Bootcamp sessions"
    - "Motion Matching in For Honor - GDC 2016"
    - "Inertialization: High-Performance Animation Transitions"

  tools:
    - "Unity Mecanim / Animator Controller"
    - "Unreal Animation Blueprint / Control Rig"
    - "Godot AnimationTree"
    - "Motion Builder for motion capture"
    - "Cascadeur for physics-based animation"
