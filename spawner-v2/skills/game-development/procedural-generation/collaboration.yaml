id: procedural-generation
skill: Procedural Generation
version: "1.0"

receives_context_from:
  - skill: game-design
    receives:
      - Gameplay requirements
      - Level pacing constraints
      - Difficulty curves
    provides:
      - Generated level layouts
      - Procedural content parameters
      - Seed management

  - skill: worldbuilding
    receives:
      - World lore and rules
      - Geographic constraints
      - Named location requirements
    provides:
      - Terrain generation
      - Biome distribution
      - Procedural place names

  - skill: threejs-3d-graphics
    receives:
      - Rendering requirements
      - LOD specifications
      - Performance constraints
    provides:
      - Heightmap data
      - Mesh generation algorithms
      - Chunk streaming logic

  - skill: generative-art
    receives:
      - Aesthetic requirements
      - Color palette rules
      - Style constraints
    provides:
      - Noise-based patterns
      - Procedural textures
      - Generated shapes

delegation_triggers:
  - pattern: "render|visualize|3d|mesh"
    delegate_to: threejs-3d-graphics
    context: "Need to render procedural content"

  - pattern: "gameplay|balance|difficulty"
    delegate_to: game-design
    context: "Need gameplay balancing for generated content"

  - pattern: "story|lore|narrative|name"
    delegate_to: worldbuilding
    context: "Need narrative for procedural world"

  - pattern: "texture|material|shader|art"
    delegate_to: generative-art
    context: "Need procedural textures or art"

  - pattern: "physics|pathfinding|ai"
    delegate_to: game-design
    context: "Need game logic for procedural content"

common_combinations:
  - name: Roguelike Dungeon Game
    skills:
      - procedural-generation
      - game-design
      - pixel-art-sprites
    workflow: |
      1. Design dungeon parameters (game-design)
      2. Implement dungeon generator (procedural-generation)
      3. Create tileset for rendering (pixel-art-sprites)

  - name: Open World Terrain
    skills:
      - procedural-generation
      - threejs-3d-graphics
      - worldbuilding
    workflow: |
      1. Define world lore and geography (worldbuilding)
      2. Generate terrain heightmaps (procedural-generation)
      3. Render 3D landscape (threejs-3d-graphics)

  - name: Generative Texture Pipeline
    skills:
      - procedural-generation
      - generative-art
      - threejs-3d-graphics
    workflow: |
      1. Define texture requirements (generative-art)
      2. Generate noise-based textures (procedural-generation)
      3. Apply to 3D materials (threejs-3d-graphics)

  - name: City Generator
    skills:
      - procedural-generation
      - worldbuilding
      - threejs-3d-graphics
    workflow: |
      1. Define city layout rules (worldbuilding)
      2. Generate streets and buildings (procedural-generation)
      3. Create 3D city model (threejs-3d-graphics)

cross_domain_insights:
  - domain: Biology
    insight: L-systems model plant growth mathematically
    application: Generate realistic trees, plants, and organic structures

  - domain: Geology
    insight: Erosion and tectonic processes shape terrain
    application: Apply realistic erosion algorithms

  - domain: Urban Planning
    insight: Cities follow transportation and economic patterns
    application: Generate realistic city layouts

  - domain: Music Theory
    insight: Markov chains model melodic progression
    application: Generate procedural music and sound

  - domain: Linguistics
    insight: Phonotactic rules govern valid word structures
    application: Generate plausible fantasy names

ecosystem_alternatives:
  noise_libraries:
    - name: Custom implementation
      when: Need full control, learning
      tradeoff: Development time
    - name: simplex-noise (npm)
      when: Quick setup, JavaScript
      tradeoff: Limited features
    - name: FastNoise
      when: Performance critical, many noise types
      tradeoff: More complex API
    - name: libnoise
      when: C++, full-featured
      tradeoff: Porting to JS

  dungeon_algorithms:
    - name: BSP (Binary Space Partitioning)
      when: Structured layouts, room-corridor style
      tradeoff: Less organic feel
    - name: Cellular Automata
      when: Cave-like, organic shapes
      tradeoff: Less structured
    - name: Room Placement
      when: Simple, control over room shapes
      tradeoff: Can fail placement
    - name: Wave Function Collapse
      when: Pattern-based, specific aesthetics
      tradeoff: Setup complexity, can fail

  terrain_tools:
    - name: Pure noise functions
      when: Simple heightmaps
      tradeoff: Manual biome logic
    - name: World Machine (external)
      when: Authored + procedural, AAA quality
      tradeoff: Not real-time, workflow overhead
    - name: Gaea (external)
      when: Node-based, high quality
      tradeoff: Offline only

feedback_loops:
  - from: playtesting
    incorporates:
      - Player navigation data
      - Stuck points
      - Pacing feedback
    into: Generation parameter tuning

  - from: analytics
    incorporates:
      - Level completion rates
      - Exploration patterns
      - Seed popularity
    into: Quality filtering

prerequisites:
  required_knowledge:
    - Basic mathematics (interpolation, modular arithmetic)
    - Random number generation concepts
    - Data structures (grids, graphs)
    - Game design basics

  recommended_tools:
    - VS Code
    - Visualization tools (canvas, three.js)
    - Seed logging system
    - Debugger with watch expressions

  environment_setup: |
    # JavaScript procedural generation setup
    npm create vite@latest proc-gen-demo -- --template vanilla-ts
    cd proc-gen-demo
    npm install

    # Create noise module
    cat > src/noise.ts << 'EOF'
    // Seeded random number generator
    export function createRNG(seed: number) {
      let s = seed;
      return () => {
        s = (s * 1103515245 + 12345) & 0x7fffffff;
        return s / 0x7fffffff;
      };
    }

    // Simple value noise
    export function valueNoise(x: number, y: number, seed: number = 0): number {
      const ix = Math.floor(x);
      const iy = Math.floor(y);
      const fx = x - ix;
      const fy = y - iy;

      // Smoothstep interpolation
      const sx = fx * fx * (3 - 2 * fx);
      const sy = fy * fy * (3 - 2 * fy);

      // Hash corners
      const hash = (x: number, y: number) => {
        const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
        return n - Math.floor(n);
      };

      // Bilinear interpolation
      const v00 = hash(ix, iy);
      const v10 = hash(ix + 1, iy);
      const v01 = hash(ix, iy + 1);
      const v11 = hash(ix + 1, iy + 1);

      const v0 = v00 + sx * (v10 - v00);
      const v1 = v01 + sx * (v11 - v01);

      return v0 + sy * (v1 - v0);
    }

    // Fractal Brownian Motion
    export function fbm(
      x: number,
      y: number,
      options: {
        octaves?: number;
        persistence?: number;
        lacunarity?: number;
        seed?: number;
      } = {}
    ): number {
      const { octaves = 6, persistence = 0.5, lacunarity = 2.0, seed = 0 } = options;

      let total = 0;
      let amplitude = 1;
      let frequency = 1;
      let maxValue = 0;

      for (let i = 0; i < octaves; i++) {
        total += valueNoise(x * frequency, y * frequency, seed + i) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
      }

      return total / maxValue;
    }
    EOF

    # Create terrain example
    cat > src/main.ts << 'EOF'
    import { fbm } from './noise';

    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    document.body.appendChild(canvas);

    const ctx = canvas.getContext('2d')!;
    const imageData = ctx.createImageData(512, 512);

    // Generate terrain
    const seed = 12345;
    const scale = 100;

    for (let y = 0; y < 512; y++) {
      for (let x = 0; x < 512; x++) {
        const value = fbm(x / scale, y / scale, { seed, octaves: 6 });
        const height = (value + 1) / 2; // Normalize to 0-1

        // Colorize by height
        let r, g, b;
        if (height < 0.3) {
          // Water
          r = 50; g = 100; b = 200;
        } else if (height < 0.35) {
          // Beach
          r = 240; g = 220; b = 130;
        } else if (height < 0.7) {
          // Grass
          const shade = 0.5 + height * 0.5;
          r = 50 * shade; g = 150 * shade; b = 50 * shade;
        } else {
          // Snow
          r = 220 + height * 30; g = 220 + height * 30; b = 220 + height * 30;
        }

        const idx = (y * 512 + x) * 4;
        imageData.data[idx] = r;
        imageData.data[idx + 1] = g;
        imageData.data[idx + 2] = b;
        imageData.data[idx + 3] = 255;
      }
    }

    ctx.putImageData(imageData, 0, 0);
    console.log(`Generated with seed: ${seed}`);
    EOF

    npm run dev
