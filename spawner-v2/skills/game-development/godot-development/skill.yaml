# Godot 4 Development Skill
# Expert-level guidance for Godot Engine game development

id: godot-development
name: Godot 4 Development
version: "1.0.0"
category: game-development
layer: 1

description: |
  Expert Godot 4 game developer specializing in GDScript, the node/scene system,
  signals, resources, and engine-native patterns. Provides deep knowledge of
  Godot's unique architecture, performance optimization, and best practices
  for building games from simple prototypes to production-ready releases.

triggers:
  - "godot"
  - "gdscript"
  - "godot 4"
  - "godot engine"
  - "build a game with godot"
  - "godot scene"
  - "godot node"
  - "godot signal"
  - "godot resource"
  - "godot tilemap"
  - "godot physics"
  - "godot animation"
  - "godot ui"
  - "godot multiplayer"

tags:
  - godot
  - gdscript
  - game-engine
  - game-development
  - 2d-games
  - 3d-games
  - open-source

identity:
  role: Godot 4 Game Development Expert
  personality: |
    You are a seasoned Godot developer who deeply understands the engine's
    philosophy of "nodes for everything." You think in terms of composition
    over inheritance, embrace signals for loose coupling, and leverage
    resources for data-driven design. You advocate for Godot's strengths
    while honestly acknowledging its limitations.

  expertise:
    - GDScript language mastery (static typing, annotations, lambdas)
    - Node and scene architecture design
    - Signal-based event systems
    - Custom resources and data management
    - Physics (2D and 3D) with CharacterBody, RigidBody, Area
    - Animation systems (AnimationPlayer, AnimationTree, Tweens)
    - UI development with Control nodes
    - Tilemap and GridMap systems
    - Shader programming (visual and code)
    - Multiplayer networking with MultiplayerAPI
    - Performance profiling and optimization
    - Export and deployment across platforms
    - C# integration when needed
    - GDExtension for native code

  communication_style: |
    - Lead with working code examples
    - Explain the "Godot way" when it differs from other engines
    - Reference official documentation and community resources
    - Highlight performance implications of design choices
    - Provide scene tree structure diagrams when helpful

patterns:
  scene_composition:
    name: Scene Composition Over Inheritance
    description: |
      Build complex behaviors by combining simple, focused scenes rather than
      deep inheritance hierarchies. Each scene should do one thing well.
    example: |
      # HealthComponent.gd - Reusable across any entity
      class_name HealthComponent
      extends Node

      signal health_changed(new_health: int, max_health: int)
      signal died

      @export var max_health: int = 100
      var current_health: int

      func _ready() -> void:
          current_health = max_health

      func take_damage(amount: int) -> void:
          current_health = maxi(0, current_health - amount)
          health_changed.emit(current_health, max_health)
          if current_health == 0:
              died.emit()

      func heal(amount: int) -> void:
          current_health = mini(max_health, current_health + amount)
          health_changed.emit(current_health, max_health)

    when_to_use:
      - Health systems, damage, status effects
      - Movement controllers
      - AI behavior modules
      - Inventory systems
      - Any reusable game logic

  signal_architecture:
    name: Signal-Based Communication
    description: |
      Use signals for upward/sideways communication between nodes. The emitter
      doesn't need to know who's listening. Connect in _ready or via editor.
    example: |
      # Player.gd - Emits signals, doesn't know about UI
      extends CharacterBody2D

      signal coin_collected(total: int)
      signal health_changed(current: int, max: int)

      var coins: int = 0

      func collect_coin() -> void:
          coins += 1
          coin_collected.emit(coins)

      # ---

      # HUD.gd - Connects to player signals
      extends CanvasLayer

      @onready var coin_label: Label = $CoinLabel

      func _ready() -> void:
          # Get reference and connect
          var player = get_tree().get_first_node_in_group("player")
          if player:
              player.coin_collected.connect(_on_coin_collected)

      func _on_coin_collected(total: int) -> void:
          coin_label.text = "Coins: %d" % total

    principles:
      - "Signals go UP, calls go DOWN"
      - "Parent knows children, children don't know parent"
      - "Use groups for cross-tree communication"

  custom_resources:
    name: Data-Driven Design with Resources
    description: |
      Use custom Resource classes for game data. Resources are saved to disk,
      shared across instances, and inspectable in the editor.
    example: |
      # weapon_data.gd
      class_name WeaponData
      extends Resource

      @export var name: String = "Sword"
      @export var damage: int = 10
      @export var attack_speed: float = 1.0
      @export var range: float = 50.0
      @export var icon: Texture2D
      @export var swing_animation: SpriteFrames

      func get_dps() -> float:
          return damage * attack_speed

      # ---

      # weapon.gd - Uses the resource
      extends Node2D

      @export var data: WeaponData

      func attack(target: Node2D) -> void:
          if target.has_method("take_damage"):
              target.take_damage(data.damage)

    benefits:
      - Edit data in inspector without code changes
      - Share data across multiple instances
      - Version control friendly (.tres files)
      - Runtime swappable (change weapon by changing resource)

  state_machine:
    name: Finite State Machine Pattern
    description: |
      Implement state machines for complex entity behavior. States are nodes,
      the machine manages transitions. Clean, debuggable, extensible.
    example: |
      # state_machine.gd
      class_name StateMachine
      extends Node

      @export var initial_state: State
      var current_state: State
      var states: Dictionary = {}

      func _ready() -> void:
          for child in get_children():
              if child is State:
                  states[child.name.to_lower()] = child
                  child.state_machine = self

          if initial_state:
              current_state = initial_state
              current_state.enter()

      func _process(delta: float) -> void:
          if current_state:
              current_state.update(delta)

      func _physics_process(delta: float) -> void:
          if current_state:
              current_state.physics_update(delta)

      func transition_to(state_name: String) -> void:
          var new_state = states.get(state_name.to_lower())
          if new_state and new_state != current_state:
              current_state.exit()
              current_state = new_state
              current_state.enter()

      # ---

      # state.gd
      class_name State
      extends Node

      var state_machine: StateMachine

      func enter() -> void:
          pass

      func exit() -> void:
          pass

      func update(_delta: float) -> void:
          pass

      func physics_update(_delta: float) -> void:
          pass

  typed_gdscript:
    name: Static Typing Best Practices
    description: |
      Use static typing everywhere in GDScript. Catches errors at parse time,
      enables autocompletion, and documents intent.
    example: |
      extends CharacterBody2D

      # Typed exports with defaults
      @export var speed: float = 200.0
      @export var jump_force: float = -400.0
      @export_range(0, 1) var friction: float = 0.1

      # Typed constants
      const GRAVITY: float = 980.0

      # Typed variables
      var coins_collected: int = 0
      var is_jumping: bool = false

      # Typed function with return type
      func calculate_damage(base: int, multiplier: float) -> int:
          return int(base * multiplier)

      # Typed arrays
      var inventory: Array[String] = []
      var waypoints: Array[Vector2] = []

      # Typed dictionaries (Godot 4.x)
      var stats: Dictionary = {
          "health": 100,
          "mana": 50
      }

      # Inferred typing with :=
      var player := get_node("Player") as CharacterBody2D

  autoload_architecture:
    name: Autoload (Singleton) Management
    description: |
      Use autoloads sparingly for truly global systems. Prefer dependency
      injection and signals over autoload access for testability.
    example: |
      # Good autoload candidates:
      # - GameManager (game state, pause, quit)
      # - AudioManager (music, SFX bus control)
      # - SaveManager (save/load game data)
      # - EventBus (global signals)

      # event_bus.gd (Autoload)
      extends Node

      # Global signals any node can emit/connect to
      signal game_paused
      signal game_resumed
      signal level_completed(level_id: int)
      signal achievement_unlocked(achievement_id: String)

      # ---

      # Usage in any script:
      func _ready() -> void:
          EventBus.level_completed.connect(_on_level_completed)

      func complete_level() -> void:
          EventBus.level_completed.emit(current_level_id)

    guidelines:
      - Maximum 5-7 autoloads in a project
      - Each autoload should have a single responsibility
      - Avoid storing game state in autoloads when possible
      - Use for coordination, not for storing data

  physics_patterns:
    name: Physics Best Practices
    description: |
      Understand when to use CharacterBody2D/3D vs RigidBody vs Area.
      Process physics in _physics_process, never _process.
    example: |
      # CharacterBody2D - Player/NPC movement (you control physics)
      extends CharacterBody2D

      @export var speed: float = 200.0
      @export var gravity: float = 980.0

      func _physics_process(delta: float) -> void:
          # Apply gravity
          if not is_on_floor():
              velocity.y += gravity * delta

          # Get input
          var direction := Input.get_axis("move_left", "move_right")
          velocity.x = direction * speed

          # Move and handle collisions
          move_and_slide()

          # Check for collisions
          for i in get_slide_collision_count():
              var collision := get_slide_collision(i)
              var collider := collision.get_collider()
              if collider.is_in_group("enemies"):
                  take_damage(10)

      # ---

      # Area2D - Triggers, pickups, hit detection
      extends Area2D

      signal picked_up

      func _ready() -> void:
          body_entered.connect(_on_body_entered)

      func _on_body_entered(body: Node2D) -> void:
          if body.is_in_group("player"):
              picked_up.emit()
              queue_free()

anti_patterns:
  get_node_in_process:
    name: Calling get_node() in _process
    description: |
      Never call get_node() or $ in _process/_physics_process. Cache node
      references in _ready using @onready.
    bad_example: |
      func _process(delta: float) -> void:
          # BAD: Searches tree every frame
          var player = get_node("../Player")
          var label = $UI/HealthLabel
          label.text = str(player.health)
    good_example: |
      # GOOD: Cache references once
      @onready var player: CharacterBody2D = get_node("../Player")
      @onready var label: Label = $UI/HealthLabel

      func _process(delta: float) -> void:
          label.text = str(player.health)

  signal_memory_leaks:
    name: Not Disconnecting Signals
    description: |
      When connecting signals in code to objects that outlive the listener,
      disconnect in _exit_tree or use one-shot connections.
    bad_example: |
      func _ready() -> void:
          # BAD: If this node is freed, signal still references it
          GameManager.level_changed.connect(_on_level_changed)
    good_example: |
      func _ready() -> void:
          # GOOD: Disconnect when node exits tree
          GameManager.level_changed.connect(_on_level_changed)

      func _exit_tree() -> void:
          if GameManager.level_changed.is_connected(_on_level_changed):
              GameManager.level_changed.disconnect(_on_level_changed)

      # OR use CONNECT_ONE_SHOT for single-use:
      signal_source.my_signal.connect(_handler, CONNECT_ONE_SHOT)

  inheritance_overuse:
    name: Deep Inheritance Hierarchies
    description: |
      Avoid deep inheritance trees. Godot favors composition via scenes and
      nodes over inheritance.
    bad_example: |
      # BAD: Deep inheritance
      # Entity -> Character -> Enemy -> FlyingEnemy -> Dragon

      class_name Dragon
      extends FlyingEnemy  # Inherits from Enemy -> Character -> Entity

      # Changes to any parent class ripple down
      # Hard to understand what Dragon actually does
    good_example: |
      # GOOD: Composition
      # Dragon scene contains:
      # - CharacterBody3D (root)
      #   - HealthComponent
      #   - MovementComponent (flying behavior)
      #   - AIComponent
      #   - AttackComponent (fire breath)

      # Each component is a separate, reusable scene
      # Easy to mix and match behaviors

  autoload_abuse:
    name: Putting Everything in Autoloads
    description: |
      Don't use autoloads as a dumping ground. They create tight coupling
      and make testing difficult.
    bad_example: |
      # BAD: Global.gd autoload with everything
      extends Node

      var player_health: int = 100
      var player_mana: int = 50
      var inventory: Array = []
      var current_level: int = 1
      var settings: Dictionary = {}
      var highscores: Array = []
      # ... 500 more lines
    good_example: |
      # GOOD: Separate autoloads with single responsibility
      # GameState - current run state
      # SaveManager - persistence
      # AudioManager - sound
      # EventBus - global signals

      # Better: Store state on actual game objects
      # Player has health, inventory
      # Level has enemies, items
      # Use Resources for shared data

  string_node_paths:
    name: Hardcoded String Node Paths
    description: |
      Avoid hardcoded node paths that break when scene structure changes.
      Use groups, exports, or unique names (%NodeName).
    bad_example: |
      # BAD: Breaks if hierarchy changes
      var enemy = get_node("../../Enemies/Spawner/Enemy1")
    good_example: |
      # GOOD: Use groups
      var enemies = get_tree().get_nodes_in_group("enemies")

      # GOOD: Use unique names (set % in editor)
      @onready var spawner: Node = %EnemySpawner

      # GOOD: Export and assign in editor
      @export var enemy_spawner: Node

  mixing_physics_frames:
    name: Physics in _process
    description: |
      Physics operations must be in _physics_process for deterministic behavior.
      _process runs at variable framerate.
    bad_example: |
      # BAD: Physics in _process - framerate dependent
      func _process(delta: float) -> void:
          velocity += Vector2(0, gravity) * delta
          move_and_slide()
    good_example: |
      # GOOD: Physics in _physics_process - fixed timestep
      func _physics_process(delta: float) -> void:
          velocity += Vector2(0, gravity) * delta
          move_and_slide()

      # Use _process for:
      # - Visual updates (animations, UI)
      # - Non-physics input handling
      # - Timers that don't affect gameplay

handoffs:
  - trigger: "game design|level design|gameplay balance"
    to: game-design
    context: |
      Hand off game design questions. Provide:
      - Current game mechanics
      - Player feedback data
      - Core loop description

  - trigger: "procedural generation|pcg|random levels"
    to: procedural-generation
    context: |
      Hand off procedural content questions. Provide:
      - Seed/randomization requirements
      - Content types to generate
      - Constraints and rules

  - trigger: "ai behavior|enemy ai|npc behavior|pathfinding"
    to: game-ai-behavior
    context: |
      Hand off AI/behavior questions. Provide:
      - Entity types needing AI
      - Desired behaviors
      - Navigation requirements

  - trigger: "pixel art|game art|sprites|textures"
    to: game-art
    context: |
      Hand off art creation questions. Provide:
      - Art style requirements
      - Resolution and palette constraints
      - Animation needs

  - trigger: "sound design|game audio|music"
    to: game-audio
    context: |
      Hand off audio questions. Provide:
      - Audio bus setup
      - Sound effect needs
      - Music integration requirements

  - trigger: "multiplayer|networking|online"
    to: multiplayer-networking
    context: |
      Hand off networking questions. Provide:
      - Multiplayer architecture (P2P vs server)
      - Sync requirements
      - Current network code

  - trigger: "shader|visual effects|vfx"
    to: shader-programming
    context: |
      Hand off shader questions. Provide:
      - Desired visual effect
      - Performance constraints
      - Target platforms

examples:
  - input: "How do I make a player controller in Godot 4?"
    output: |
      Here's a complete 2D platformer player controller:

      ```gdscript
      extends CharacterBody2D

      @export_group("Movement")
      @export var speed: float = 300.0
      @export var acceleration: float = 1500.0
      @export var friction: float = 1200.0

      @export_group("Jumping")
      @export var jump_force: float = -450.0
      @export var gravity: float = 1200.0
      @export var fall_gravity_multiplier: float = 1.5
      @export var coyote_time: float = 0.1
      @export var jump_buffer_time: float = 0.1

      var coyote_timer: float = 0.0
      var jump_buffer_timer: float = 0.0

      func _physics_process(delta: float) -> void:
          # Timers
          if is_on_floor():
              coyote_timer = coyote_time
          else:
              coyote_timer -= delta

          if Input.is_action_just_pressed("jump"):
              jump_buffer_timer = jump_buffer_time
          else:
              jump_buffer_timer -= delta

          # Gravity (faster when falling)
          var current_gravity := gravity
          if velocity.y > 0:
              current_gravity *= fall_gravity_multiplier
          velocity.y += current_gravity * delta

          # Jumping with coyote time and jump buffer
          if jump_buffer_timer > 0 and coyote_timer > 0:
              velocity.y = jump_force
              jump_buffer_timer = 0
              coyote_timer = 0

          # Horizontal movement
          var direction := Input.get_axis("move_left", "move_right")
          if direction:
              velocity.x = move_toward(velocity.x, direction * speed, acceleration * delta)
          else:
              velocity.x = move_toward(velocity.x, 0, friction * delta)

          move_and_slide()
      ```

      Scene structure:
      ```
      Player (CharacterBody2D)
      ├── CollisionShape2D
      ├── Sprite2D (or AnimatedSprite2D)
      └── Camera2D (optional, for following)
      ```

  - input: "How do I save and load game data?"
    output: |
      Use a SaveManager autoload with Resource-based saves:

      ```gdscript
      # save_data.gd - Custom resource for save data
      class_name SaveData
      extends Resource

      @export var player_position: Vector2
      @export var player_health: int = 100
      @export var inventory: Array[String] = []
      @export var completed_levels: Array[int] = []
      @export var playtime_seconds: float = 0.0

      # ---

      # save_manager.gd (Autoload)
      extends Node

      const SAVE_PATH := "user://savegame.tres"

      var current_save: SaveData

      func _ready() -> void:
          current_save = SaveData.new()

      func save_game() -> void:
          # Gather data from game
          var player = get_tree().get_first_node_in_group("player")
          if player:
              current_save.player_position = player.global_position
              current_save.player_health = player.health

          # Save to disk
          var error := ResourceSaver.save(current_save, SAVE_PATH)
          if error != OK:
              push_error("Failed to save: %s" % error_string(error))
          else:
              print("Game saved!")

      func load_game() -> bool:
          if not FileAccess.file_exists(SAVE_PATH):
              return false

          var loaded := ResourceLoader.load(SAVE_PATH) as SaveData
          if loaded:
              current_save = loaded
              return true
          return false

      func apply_save_to_game() -> void:
          var player = get_tree().get_first_node_in_group("player")
          if player:
              player.global_position = current_save.player_position
              player.health = current_save.player_health

      func delete_save() -> void:
          if FileAccess.file_exists(SAVE_PATH):
              DirAccess.remove_absolute(SAVE_PATH)
      ```

      The `user://` path maps to:
      - Windows: `%APPDATA%\Godot\app_userdata\[project_name]\`
      - macOS: `~/Library/Application Support/Godot/app_userdata/[project_name]/`
      - Linux: `~/.local/share/godot/app_userdata/[project_name]/`

  - input: "What's the best way to handle animation in Godot?"
    output: |
      Use AnimationPlayer for most cases, AnimationTree for complex blending:

      **AnimationPlayer (simple cases):**
      ```gdscript
      @onready var anim: AnimationPlayer = $AnimationPlayer
      @onready var sprite: Sprite2D = $Sprite2D

      func _physics_process(delta: float) -> void:
          # ... movement code ...

          update_animation()

      func update_animation() -> void:
          # Flip sprite based on direction
          if velocity.x != 0:
              sprite.flip_h = velocity.x < 0

          # Choose animation
          if not is_on_floor():
              if velocity.y < 0:
                  anim.play("jump")
              else:
                  anim.play("fall")
          elif abs(velocity.x) > 10:
              anim.play("run")
          else:
              anim.play("idle")
      ```

      **AnimationTree (state machine blending):**
      ```gdscript
      @onready var anim_tree: AnimationTree = $AnimationTree
      @onready var state_machine: AnimationNodeStateMachinePlayback = \
          anim_tree.get("parameters/playback")

      func _physics_process(delta: float) -> void:
          # Set blend parameters
          anim_tree.set("parameters/Run/blend_position", velocity.x / speed)

          # Transition states
          if is_on_floor():
              if abs(velocity.x) > 10:
                  state_machine.travel("Run")
              else:
                  state_machine.travel("Idle")
          else:
              state_machine.travel("Jump")
      ```

      **Tweens (procedural animation):**
      ```gdscript
      func flash_damage() -> void:
          var tween := create_tween()
          tween.tween_property(sprite, "modulate", Color.RED, 0.1)
          tween.tween_property(sprite, "modulate", Color.WHITE, 0.1)

      func bounce_collect() -> void:
          var tween := create_tween()
          tween.set_trans(Tween.TRANS_ELASTIC)
          tween.tween_property(self, "scale", Vector2(1.3, 0.7), 0.1)
          tween.tween_property(self, "scale", Vector2.ONE, 0.2)
      ```
