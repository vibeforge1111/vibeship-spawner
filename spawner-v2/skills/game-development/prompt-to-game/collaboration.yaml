id: prompt-to-game
skill: Prompt-to-Game Development
version: "1.0"

receives_from:
  - skill: game-design-core
    receives:
      - Game design document
      - Mechanics specifications
      - Core loop description
    provides:
      - Working prototype
      - Playable implementation
      - Technical feasibility feedback

  - skill: concept-art
    receives:
      - Visual style references
      - Mood boards
      - Character concepts
    provides:
      - Game with placeholder assets
      - Asset specification for AI art generation
      - Layout and composition needs

  - skill: ai-game-art-generation
    receives:
      - Generated sprites and textures
      - UI assets
      - Background art
    provides:
      - Asset integration
      - Size and format requirements
      - Technical constraints for art

  - skill: game-design-core
    receives:
      - Balance feedback
      - Mechanics refinement
      - Player experience goals
    provides:
      - Rapid iterations
      - A/B test implementations
      - Quick prototypes of design ideas

delegation_triggers:
  - trigger: "deploy|host|publish|server"
    delegate_to: devops
    pattern: sequential
    context: "Game is ready, needs hosting and deployment"
    handoff_data:
      - "Built game files"
      - "Dependencies list"
      - "Environment requirements"
    receive:
      - "Deployment URL"
      - "CI/CD pipeline"

  - trigger: "art|sprites|textures|assets"
    delegate_to: ai-game-art-generation
    pattern: parallel
    context: "Need visual assets for the game"
    handoff_data:
      - "Asset requirements"
      - "Size specifications"
      - "Style references"
    receive:
      - "Generated assets"
      - "Spritesheet files"

  - trigger: "multiplayer|networking|realtime|websocket"
    delegate_to: backend
    pattern: sequential
    context: "Need robust multiplayer infrastructure"
    handoff_data:
      - "Player count requirements"
      - "Sync requirements"
      - "Latency tolerance"
    receive:
      - "Network architecture"
      - "API design"

  - trigger: "security|vulnerability|audit"
    delegate_to: security-audit
    pattern: review
    context: "Need security review before shipping"
    handoff_data:
      - "Source code"
      - "Deployment config"
    receive:
      - "Vulnerability report"
      - "Fix recommendations"

  - trigger: "mobile|iOS|Android|responsive"
    delegate_to: mobile-development
    pattern: sequential
    context: "Need mobile platform optimization"
    handoff_data:
      - "Game source"
      - "Target platforms"
    receive:
      - "Mobile build"
      - "Performance optimizations"

  - trigger: "test|QA|bug|coverage"
    delegate_to: testing
    pattern: parallel
    context: "Need comprehensive testing"
    handoff_data:
      - "Source code"
      - "Feature list"
    receive:
      - "Test suite"
      - "Bug report"

common_combinations:
  - name: Full Vibe Coding Pipeline
    skills:
      - prompt-to-game
      - ai-game-art-generation
      - devops
    workflow: |
      1. Design game via prompts (prompt-to-game)
      2. Generate assets with AI (ai-game-art-generation)
      3. Integrate and polish (prompt-to-game)
      4. Deploy (devops)

  - name: Rapid Prototype to Production
    skills:
      - prompt-to-game
      - game-design-core
      - testing
    workflow: |
      1. Rapid prototype via prompts (prompt-to-game)
      2. Design review and refinement (game-design-core)
      3. Quality assurance (testing)
      4. Ship

  - name: Game Jam Speed Run
    skills:
      - prompt-to-game
      - ai-game-art-generation
    workflow: |
      1. Three-prompt game generation (prompt-to-game)
      2. Quick asset generation (ai-game-art-generation)
      3. Integration and submission

cross_domain_insights:
  - domain: Pair Programming
    insight: Two perspectives catch more bugs than one
    application: AI is your pair - but you're the senior dev who reviews

  - domain: Agile Development
    insight: Small iterations with frequent testing beat big releases
    application: Component-by-component prompting follows this principle

  - domain: Test-Driven Development
    insight: Write tests first, then implementation
    application: Describe expected behavior before prompting for code

  - domain: Rubber Duck Debugging
    insight: Explaining the problem often reveals the solution
    application: Writing detailed prompts clarifies your own thinking

  - domain: Lean Startup
    insight: Build-Measure-Learn cycle
    application: Prompt-Test-Refine cycle for game development

ecosystem_alternatives:
  ai_coding_tools:
    - name: Claude Code
      when: Complex multi-file games, large context
      tradeoff: Slower, higher cost
    - name: Cursor
      when: Speed, keyboard-first, multi-model
      tradeoff: Learning curve for keybinds
    - name: Windsurf
      when: Agent-based, autonomous testing
      tradeoff: Less control
    - name: Replit Agent
      when: Quick deployment, collaboration
      tradeoff: Less powerful for complex games
    - name: v0.dev
      when: UI-focused, React output
      tradeoff: Not game-specific

  game_frameworks:
    - name: Phaser 3
      when: 2D web games, huge community
      tradeoff: JavaScript-specific
    - name: Kaboom.js
      when: Simple games, beginner-friendly
      tradeoff: Less powerful than Phaser
    - name: Three.js
      when: 3D web games, WebGL
      tradeoff: Steeper learning curve
    - name: Godot
      when: Cross-platform, feature-complete
      tradeoff: Not web-native
    - name: PyGame
      when: Python projects, prototypes
      tradeoff: Not for web deployment

  deployment:
    - name: itch.io
      when: Game-focused, community
      tradeoff: Revenue share
    - name: GitHub Pages
      when: Free, simple static hosting
      tradeoff: No backend
    - name: Vercel
      when: Modern deployment, serverless
      tradeoff: Limits on free tier
    - name: Netlify
      when: Similar to Vercel
      tradeoff: Different limits

feedback_loops:
  - from: game-design-core
    incorporates:
      - Mechanics refinements
      - Balance feedback
      - UX improvements
    into: Prompt refinements and iterations

  - from: testing
    incorporates:
      - Bug reports
      - Edge cases found
      - Performance issues
    into: Fix prompts and security checks

  - from: ai-game-art-generation
    incorporates:
      - Asset specifications
      - Format requirements
      - Style consistency needs
    into: Asset integration prompts

escalation_paths:
  - situation: AI keeps generating buggy code
    escalate_to: manual coding
    urgency: medium
    context: "Sometimes just write the code yourself"

  - situation: Security vulnerability discovered
    escalate_to: security-audit
    urgency: critical
    context: "Stop deployment, fix immediately"

  - situation: Performance too slow
    escalate_to: devops
    urgency: high
    context: "Need profiling and optimization"

workflow_integration:
  typical_sequence:
    - step: 1
      action: Define game concept and core loop
      skills_involved: [game-design-core]
      output: Design brief for prompting

    - step: 2
      action: Prompt for initial prototype
      skills_involved: [prompt-to-game]
      output: Working basic game

    - step: 3
      action: Iterate on mechanics via prompts
      skills_involved: [prompt-to-game]
      output: Playable game with features

    - step: 4
      action: Generate and integrate assets
      skills_involved: [ai-game-art-generation, prompt-to-game]
      output: Game with visuals

    - step: 5
      action: Polish, test, and deploy
      skills_involved: [testing, devops]
      output: Published game

  decision_points:
    - question: Is the game too complex for pure prompting?
      options:
        - choice: Continue with prompts
          when: Still making progress, code stays manageable
        - choice: Switch to manual coding
          when: Hitting walls, need precise control

    - question: When to refactor?
      options:
        - choice: Refactor now
          when: File > 500 lines, nesting > 3 deep
        - choice: Continue adding features
          when: Code still manageable, deadline pressure

    - question: When to split files?
      options:
        - choice: Keep single file
          when: Total < 300 lines, simple game
        - choice: Split into modules
          when: Multiple distinct systems, growing complexity

prerequisites:
  required_knowledge:
    - Basic programming concepts (variables, functions, loops)
    - Understanding of game loops
    - Ability to read and debug code

  recommended_tools:
    - AI coding assistant (Claude Code, Cursor, Windsurf)
    - Code editor with syntax highlighting
    - Browser with developer tools
    - Git for version control

  environment_setup: |
    # Basic web game setup with Phaser 3
    npm create vite@latest my-game -- --template vanilla
    cd my-game
    npm install phaser@3.90.0

    # Or for quick experiments with Kaboom
    npx create-kaboom my-game
    cd my-game
    npm install

    # Git setup (CRITICAL for AI development)
    git init
    git add .
    git commit -m "Initial setup"

    # Start development
    npm run dev

    # Commit after EVERY working change
    # Document prompts that worked
