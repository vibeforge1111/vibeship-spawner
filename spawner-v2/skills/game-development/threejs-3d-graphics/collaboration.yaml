id: threejs-3d-graphics
skill: Three.js 3D Graphics
version: "1.0"

receives_from:
  - skill: ui-design
    receives:
      - Visual design requirements
      - Color palette and branding
      - Animation style guidelines
    provides:
      - 3D implementation of design
      - Interactive 3D components
      - WebGL visual effects

  - skill: game-design
    receives:
      - Game mechanics specifications
      - Camera behavior requirements
      - Interaction patterns
    provides:
      - 3D scene implementation
      - Performance optimization
      - Asset integration

  - skill: procedural-generation
    receives:
      - Generated geometry data
      - Procedural textures
      - Algorithm outputs
    provides:
      - Three.js rendering pipeline
      - Real-time visualization
      - Performance profiling

  - skill: vr-ar-development
    receives:
      - XR session requirements
      - Controller input patterns
      - Immersive design specs
    provides:
      - WebXR scene setup
      - VR-optimized rendering
      - XR controller integration

  - skill: generative-art
    receives:
      - Visual algorithms
      - Shader concepts
      - Generative patterns
    provides:
      - WebGL implementation
      - Real-time rendering
      - Interactive controls

delegation_triggers:
  - pattern: "blender|3d model|asset creation|sculpt"
    delegate_to: 3d-modeling
    context: "Need 3D assets created or optimized for web"

  - pattern: "vr|ar|xr|webxr|immersive"
    delegate_to: vr-ar-development
    context: "Need VR/AR integration"

  - pattern: "procedural|generate|noise|terrain"
    delegate_to: procedural-generation
    context: "Need procedural content generation"

  - pattern: "physics|collision|rigid body"
    delegate_to: game-design
    context: "Need physics simulation"

  - pattern: "react|vue|component|frontend"
    delegate_to: frontend
    context: "Need frontend framework integration"

common_combinations:
  - name: 3D Product Configurator
    skills:
      - threejs-3d-graphics
      - ui-design
      - frontend
    workflow: |
      1. Design UI/UX for configurator (ui-design)
      2. Implement 3D viewer (threejs-3d-graphics)
      3. Build React/Vue integration (frontend)

  - name: 3D Game
    skills:
      - threejs-3d-graphics
      - game-design
      - procedural-generation
    workflow: |
      1. Design game mechanics (game-design)
      2. Generate level content (procedural-generation)
      3. Build and optimize 3D scene (threejs-3d-graphics)

  - name: WebXR Experience
    skills:
      - threejs-3d-graphics
      - vr-ar-development
      - generative-art
    workflow: |
      1. Design immersive experience (vr-ar-development)
      2. Create visual effects (generative-art)
      3. Implement WebXR scene (threejs-3d-graphics)

  - name: Data Visualization 3D
    skills:
      - threejs-3d-graphics
      - data-visualization
      - frontend
    workflow: |
      1. Design data mappings (data-visualization)
      2. Build 3D scene (threejs-3d-graphics)
      3. Integrate with dashboard (frontend)

cross_domain_insights:
  - domain: Video Game Graphics
    insight: GPU optimization techniques apply directly
    application: Use batching, LOD, and culling from game dev

  - domain: Film VFX
    insight: Compositing and post-processing concepts
    application: Apply bloom, DOF, color grading in real-time

  - domain: CAD Software
    insight: Precision modeling and measurement
    application: Technical visualization and product configurators

  - domain: Scientific Visualization
    insight: Complex data representation techniques
    application: 3D charts, molecular visualization, terrain mapping

ecosystem_alternatives:
  rendering:
    - name: Three.js
      when: General purpose, large community
      tradeoff: Bundle size, learning curve
    - name: Babylon.js
      when: Game-focused, built-in physics
      tradeoff: Larger bundle, different paradigm
    - name: PlayCanvas
      when: Full game engine, editor included
      tradeoff: Less flexible, cloud-based editor

  react_integration:
    - name: React Three Fiber
      when: React projects, declarative scene
      tradeoff: React dependency, abstraction layer
    - name: Vanilla Three.js
      when: Full control, any framework
      tradeoff: More boilerplate
    - name: Threlte
      when: Svelte projects
      tradeoff: Smaller community

  physics:
    - name: Cannon.js
      when: Simple physics, pure JS
      tradeoff: Performance limits
    - name: Rapier
      when: Performance, WASM
      tradeoff: Setup complexity
    - name: Ammo.js
      when: Bullet physics port, full featured
      tradeoff: Large bundle, complex API

feedback_loops:
  - from: browser-devtools
    incorporates:
      - FPS measurements
      - Memory profiles
      - GPU utilization
    into: Performance optimization

  - from: user-analytics
    incorporates:
      - Device capabilities
      - Performance metrics
      - Error rates
    into: Quality settings adjustment

prerequisites:
  required_knowledge:
    - JavaScript fundamentals
    - Basic 3D math (vectors, matrices)
    - DOM and Canvas concepts
    - Understanding of rendering pipeline

  recommended_tools:
    - VS Code with GLSL extension
    - Spector.js for WebGL debugging
    - Blender for asset creation
    - Chrome DevTools Performance tab

  environment_setup: |
    # Project setup with Vite
    npm create vite@latest my-3d-app -- --template vanilla
    cd my-3d-app

    # Install Three.js
    npm install three
    npm install @types/three  # For TypeScript

    # Common addons
    npm install lil-gui  # Debug UI
    npm install gsap     # Animation

    # Project structure
    mkdir -p src/{shaders,models,textures}

    # Basic setup
    cat > src/main.js << 'EOF'
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // Scene
    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 2, 5);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // Test cube
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({ color: 0x00ff00 })
    );
    scene.add(cube);

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    }

    animate();
    EOF

    # Start dev server
    npm run dev
