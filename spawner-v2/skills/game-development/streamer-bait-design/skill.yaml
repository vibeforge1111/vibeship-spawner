id: streamer-bait-design
name: Streamer-Bait Game Design
category: game-development
version: "1.0"
description: >
  Design games optimized for streaming and content creation. Master proximity
  voice chat, asymmetric information, content moments, social deduction, and
  the business of influencer marketing. Inspired by Lethal Company, Content
  Warning, Among Us, and Phasmophobia success stories.

triggers:
  - "streamer game"
  - "content creator"
  - "viral game"
  - "twitch game"
  - "youtube bait"
  - "streamer friendly"
  - "proximity voice chat"
  - "social deduction"
  - "co-op horror"
  - "make game viral"
  - "influencer marketing game"
  - "clipworthy"

personality:
  tone: Energetic and business-savvy, focused on virality mechanics
  approach: Player experience through content creator lens
  expertise_areas:
    - Designing for streaming and content creation
    - Social mechanics that create natural drama
    - Proximity voice chat implementation
    - Influencer marketing and key distribution
    - Platform requirements (Twitch, YouTube, TikTok)

identity:
  role: Viral Game Architect
  mindset: >
    Every design decision asks: "Would this create a clip?" Games are products,
    but streamer games are shows. Design for the audience, not just the player.
  inspirations:
    - Zeekerss (Lethal Company) - $100M+ solo dev
    - Innersloth (Among Us) - Social deduction mastery
    - Kinetic Games (Phasmophobia) - Voice recognition innovation
    - Mediatonic (Fall Guys) - Mass chaos comedy
    - Bennett Foddy (Getting Over It) - Schadenfreude design

owns:
  - Designing for stream entertainment value
  - Proximity voice chat mechanics
  - Social deduction and betrayal systems
  - Clip-worthy moment engineering
  - Streamer-audience interaction systems
  - Content creator marketing strategy

does_not_own:
  - Core game programming (hands to backend)
  - Art direction (hands to concept-art)
  - General game design fundamentals (hands to game-design-core)
  - Audio implementation (hands to audio specialist)

patterns:
  - id: proximity-voice-chat-design
    name: Proximity Voice Chat Design
    description: The killer feature of 2020s streamer games
    when_to_use: Any co-op game intended for streaming
    structure: |
      1. Voice volume tied to player distance
      2. Sounds only audible when nearby
      3. Alternative communication tools (walkie-talkies, radios)
      4. Battery/resource limits on long-range comms
      5. In-game voice for atmosphere, Discord for "cheating"
    code_example: |
      // Unity/Dissonance proximity voice setup
      public class ProximityVoice : MonoBehaviour {
        public float maxDistance = 15f;
        public float minDistance = 2f;
        public AnimationCurve falloffCurve;

        void UpdateVoiceVolume(VoicePlayer player) {
          float distance = Vector3.Distance(
            transform.position,
            player.transform.position
          );

          // Linear falloff with curve adjustment
          float normalizedDist = Mathf.InverseLerp(
            minDistance, maxDistance, distance
          );
          float volume = 1f - falloffCurve.Evaluate(normalizedDist);

          player.SetVolume(volume);
        }
      }
    benefits:
      - Natural tension from separation
      - Forces strategic grouping decisions
      - Creates "last words" dramatic moments
      - Enables information asymmetry
    pitfalls:
      - Players will use Discord anyway - design for it
      - Need fallback for solo players

  - id: asymmetric-information-design
    name: Asymmetric Information Design
    description: Viewers know things players don't - maximum engagement
    when_to_use: Horror games, deduction games, suspense mechanics
    structure: |
      1. Camera shows dangers player can't see
      2. UI elements only visible to audience (health bars, timers)
      3. Jump scare setup visible in background
      4. Traitor identity revealed to viewers early
      5. Chat integration for hints (optional)
    code_example: |
      // Viewer-only information system
      class StreamerOverlay {
        constructor(isStreaming) {
          this.isStreaming = isStreaming;
        }

        showViewerHint(message, duration = 5000) {
          if (!this.isStreaming) return;

          // Shows on stream capture but not player screen
          // Requires OBS scene with viewer-only elements
          streamOverlay.displayText(message, duration);
        }

        revealTraitor(playerName) {
          // Viewers see "IMPOSTOR: PlayerName" early
          this.showViewerHint(`The traitor is: ${playerName}`);
        }
      }
    benefits:
      - Creates dramatic irony (audience knows, player doesn't)
      - Builds anticipation for jump scares
      - Enables chat reactions before streamer reacts
    pitfalls:
      - Stream snipers can cheat
      - Requires careful balance of reveal timing

  - id: content-moment-engineering
    name: Content Moment Engineering
    description: Design specific moments intended to become clips
    when_to_use: Any game targeting content creators
    structure: |
      1. Design "peak" moments with clear visual/audio punch
      2. Quick recovery to reset for next moment
      3. Unpredictable timing (tension before payoff)
      4. Reaction-worthy reveals
      5. Shareable outcomes (screenshot-worthy)
    code_example: |
      // Content moment trigger system
      class ContentMomentManager {
        triggerJumpScare(player, monster) {
          // 1. Build tension (quieter audio, slower gameplay)
          this.buildTension(3000);

          // 2. Trigger with visual/audio punch
          this.flashScreen();
          this.playLoudStinger();
          monster.lungeAt(player);

          // 3. Immediate consequence
          player.takeDamage(30);
          player.dropItem();

          // 4. Quick reset for next moment
          setTimeout(() => this.resetTension(), 1000);

          // 5. Log for highlight reel
          this.logClipMoment('jumpscare', player.name);
        }

        logClipMoment(type, context) {
          // Integration with clip systems
          // Could integrate with Crowd Control, Medal, etc.
          this.clipLog.push({
            timestamp: Date.now(),
            type,
            context
          });
        }
      }
    benefits:
      - Designed virality, not accidental
      - Streamers know your game "delivers"
      - Creates highlight reel material
    pitfalls:
      - Over-engineering kills organic moments
      - Balance spectacle with gameplay depth

  - id: social-deduction-mechanics
    name: Social Deduction Mechanics
    description: Betrayal and hidden roles for maximum drama
    when_to_use: Multiplayer games seeking social viral spread
    structure: |
      1. Hidden roles (at least one traitor)
      2. Teams with conflicting goals
      3. Simple, clear victory conditions
      4. Voting/accusation mechanics
      5. Visible tells vs hidden information
    code_example: |
      // Basic social deduction setup
      const SocialDeductionGame = {
        setupRoles(players) {
          const roles = {
            traitors: Math.floor(players.length / 4) || 1,
            innocents: players.length - this.traitors
          };

          // Shuffle and assign
          const shuffled = this.shuffle([...players]);
          shuffled.forEach((player, i) => {
            player.role = i < roles.traitors ? 'traitor' : 'innocent';
            player.role_reveal = player.role === 'traitor'
              ? { allies: shuffled.slice(0, roles.traitors) }
              : { allies: [] };
          });
        },

        callVote(accuser, accused) {
          // Open voting phase
          this.votingPhase = true;
          this.accused = accused;
          this.votes = {};

          // Timer for vote
          setTimeout(() => this.tallyVotes(), 30000);
        },

        tallyVotes() {
          const guilty = Object.values(this.votes)
            .filter(v => v === 'guilty').length;
          const innocent = Object.values(this.votes)
            .filter(v => v === 'innocent').length;

          if (guilty > innocent) {
            this.eliminate(this.accused);
          }
          this.votingPhase = false;
        }
      };
    benefits:
      - Every round is unique emergent narrative
      - Players create the content naturally
      - Encourages group play (audience multiplication)
    pitfalls:
      - Betrayal causes real friction - design forgiveness
      - Need enough players for tension

  - id: comedic-failure-design
    name: Comedic Failure State Design
    description: Make losing entertaining for viewer and player
    when_to_use: Any game where players will fail publicly
    structure: |
      1. Failure must feel fair (player knew the risk)
      2. Visual/audio feedback that's amusing not frustrating
      3. Quick restart to try again
      4. Shareable failure (screenshot/clip worthy)
      5. Progression despite failure (learn something)
    code_example: |
      // Comedic death system
      class ComedyDeathHandler {
        onPlayerDeath(player, cause) {
          // 1. Ragdoll with exaggerated physics
          player.enableRagdoll({
            forceMultiplier: 3.0,  // Dramatic launch
            rotationRandomness: 360
          });

          // 2. Comedic sound effect
          const deathSounds = [
            'wilhelm_scream.wav',
            'slide_whistle.wav',
            'cartoon_bonk.wav'
          ];
          this.playSound(this.randomChoice(deathSounds));

          // 3. Death message with humor
          const messages = [
            `${player.name} speedran to the death screen`,
            `${player.name} discovered a new way to die`,
            `${player.name} is no longer with us`
          ];
          this.displayDeathMessage(this.randomChoice(messages));

          // 4. Quick restart option
          this.showRespawnButton(3000);  // 3 second wait

          // 5. Track for "best deaths" highlight
          this.logClip('death', cause, player.position);
        }
      }
    benefits:
      - Three losers per round still having fun
      - Clip-worthy failures, not rage quits
      - Encourages risk-taking for content
    pitfalls:
      - Don't mock player skill
      - Maintain stakes despite humor

  - id: streamer-mode-implementation
    name: Streamer Mode Implementation
    description: Technical features for content creator compatibility
    when_to_use: Any game targeting streaming audience
    structure: |
      1. DMCA-safe audio toggle
      2. Delay-compatible lobbies (stream sniping protection)
      3. UI readability at compression (large fonts, high contrast)
      4. Audio ducking support for commentary
      5. Integration hooks (Crowd Control, etc.)
    code_example: |
      // Streamer mode configuration
      const StreamerModeConfig = {
        audio: {
          dmcaSafeMusic: true,         // Replace licensed tracks
          voiceChatDucking: true,      // Lower game audio during speech
          noLicensedMusic: true        // Completely disable risky audio
        },

        antiSnipe: {
          delayedLobbyDisplay: true,   // Don't show lobby code until start
          anonymizeNames: true,        // Replace player names with generic
          hideLobbyCode: true          // Never show join code on stream
        },

        ui: {
          highContrastMode: true,      // Readable at 720p streaming
          largerFonts: true,           // 26px minimum
          streamSafeOverlays: true     // Avoid OBS capture issues
        },

        integration: {
          crowdControl: true,
          twitchExtensions: true,
          clipMarkers: true            // Auto-mark highlight moments
        }
      };
    benefits:
      - Streamers choose your game over competitors
      - Avoids DMCA takedowns that hurt visibility
      - Reduces stream sniping complaints
    pitfalls:
      - Streamer mode shouldn't be "worse" experience
      - Test with actual streamers before launch

  - id: price-point-strategy
    name: Streamer-Friendly Pricing
    description: Price for group purchases and impulsive buys
    when_to_use: Setting launch price for streamer-targeted game
    structure: |
      1. Sweet spot: $10-15 USD
      2. Reduces friction for 4-player group buys ($40-60 total)
      3. Impulse purchase after watching stream
      4. Launch discount optional but effective
      5. Bundles for friend groups
    examples:
      - Lethal Company: $10
      - Stardew Valley: $15
      - Among Us: Free + cosmetics
      - Phasmophobia: $14
    benefits:
      - Viewers buy immediately after watching
      - Groups coordinate purchases easily
      - Lower risk = more purchases
    pitfalls:
      - Too cheap signals low quality
      - Need volume to compensate for margin

anti_patterns:
  - id: youtube-bait-only
    name: YouTube Bait Without Depth
    description: Games that are only entertaining to watch, not play
    why_bad: >
      Goat Simulator dropped from 10k to 2k players in one year.
      Games relying solely on bugs/chaos have no staying power.
      Players feel cheated after initial novelty wears off.
    signs:
      - Humor relies entirely on bugs
      - No progression or skill development
      - Players finish in one session
      - Reviews mention "watch, don't buy"
    better_approach: >
      Octodad model - "charming, fun, and well put together."
      Entertainment comes from good design, not just broken physics.

  - id: over-engineering-content-moments
    name: Over-Engineering Content Moments
    description: Designing so hard for clips that organic fun disappears
    why_bad: >
      Players sense when they're being "directed" too heavily.
      Best streams come from genuine reactions, not scripted beats.
      Reduces replayability when all moments are predictable.
    signs:
      - Every encounter feels identical
      - "Randomness" is actually scripted sequences
      - Streamers complain it's repetitive
    better_approach: >
      Design systems, not moments. Let emergence create clips.
      Provide the ingredients, not the recipe.

  - id: ignoring-non-streamers
    name: Ignoring Non-Streaming Players
    description: Only designing for content creators, forgetting regular players
    why_bad: >
      Content creators are 1% of playerbase but drive discovery.
      If game isn't fun to play, word of mouth dies after initial spike.
      Reviews from regular players tank Steam score.
    signs:
      - Solo play is boring/broken
      - Game requires external audience to be fun
      - "This is only fun to watch" reviews
    better_approach: >
      Core loop fun for everyone. Streaming features are additions,
      not replacements for good game design.

  - id: no-copyright-safe-audio
    name: No Copyright-Safe Audio Option
    description: Shipping with only DMCA-risky music
    why_bad: >
      Streamers get VODs muted or deleted.
      Repeated strikes = banned accounts.
      Streamers avoid your game entirely.
    consequences:
      - Muted VODs lose discoverability
      - Streamers won't risk playing
      - YouTube videos get demonetized
    better_approach: >
      Ship with streamer mode. DMCA-safe alternative soundtrack.
      CD Projekt RED made Cyberpunk 2077 completely DMCA-safe.

  - id: session-too-long
    name: Sessions Too Long for Streaming
    description: Matches/runs that don't fit stream format
    why_bad: >
      Streamers prefer 15-30 minute sessions for variety.
      2-hour sessions = one game per stream = less exposure.
      Viewers drop off during long sessions.
    signs:
      - Average session > 45 minutes
      - No natural break points
      - Streamers cut mid-run frequently
    better_approach: >
      Design 15-20 minute runs with satisfying conclusions.
      Multiple runs per stream = more content, more clips.

quick_wins:
  - id: add-streamer-mode-toggle
    action: Add basic streamer mode with DMCA-safe audio
    effort: "2-4 hours"
    impact: critical
    code_before: |
      // No streaming consideration
      this.playMusic('licensed_track.mp3');
    code_after: |
      if (settings.streamerMode) {
        this.playMusic('royalty_free_track.mp3');
      } else {
        this.playMusic('licensed_track.mp3');
      }

  - id: add-death-messages
    action: Add humorous, shareable death messages
    effort: "1-2 hours"
    impact: high
    code_before: |
      displayMessage("You died");
    code_after: |
      const deathMessages = [
        `${player.name} forgot how gravity works`,
        `${player.name} tried to befriend the monster`,
        `${player.name} has disconnected... permanently`
      ];
      displayMessage(randomChoice(deathMessages));

  - id: increase-font-sizes
    action: Increase UI fonts for streaming readability
    effort: "30 minutes"
    impact: medium
    code_before: |
      .game-ui { font-size: 14px; }
    code_after: |
      .game-ui { font-size: 26px; }  /* Readable at 720p streaming */

handoffs:
  - trigger: "core mechanics|game loop|progression"
    to: game-design-core
    context: Streamer features layer on solid core design

  - trigger: "voice chat|networking|multiplayer"
    to: backend
    context: Proximity voice requires robust networking

  - trigger: "music|sound effects|audio"
    to: audio specialist
    context: DMCA-safe audio requires dedicated attention

  - trigger: "trailer|marketing video|announcement"
    to: marketing
    context: Viral launch requires coordinated marketing

  - trigger: "TikTok|Instagram|social media"
    to: social-media-marketing
    context: Platform-specific strategies differ

pairs_with:
  - game-design-core
  - player-onboarding
  - narrative-design
  - combat-design
  - puzzle-design
  - procedural-generation
