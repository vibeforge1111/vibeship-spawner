id: vr-ar-development
skill: VR/AR Development
version: "1.0"

receives_from:
  - skill: threejs-3d-graphics
    receives:
      - 3D scene composition
      - Rendering pipeline
      - Material systems
    provides:
      - XR camera setup
      - Stereo rendering requirements
      - Performance constraints

  - skill: hand-gesture-recognition
    receives:
      - Gesture detection algorithms
      - Hand tracking data processing
      - Gesture vocabulary
    provides:
      - XR hand tracking integration
      - Spatial gesture requirements
      - Controller fallback patterns

  - skill: ui-design
    receives:
      - UI/UX principles
      - Interaction patterns
      - Visual hierarchy
    provides:
      - Spatial UI requirements
      - Distance constraints
      - 3D interaction patterns

  - skill: game-design
    receives:
      - Game mechanics
      - Player engagement
      - Level design
    provides:
      - VR comfort requirements
      - Locomotion constraints
      - Spatial gameplay patterns

delegation_triggers:
  - pattern: "3d scene|three.js|rendering"
    delegate_to: threejs-3d-graphics
    context: "Need 3D scene development"

  - pattern: "hand tracking|gesture|finger"
    delegate_to: hand-gesture-recognition
    context: "Need hand tracking implementation"

  - pattern: "game|gameplay|level"
    delegate_to: game-design
    context: "Need game design for VR/AR"

  - pattern: "ui|interface|menu"
    delegate_to: ui-design
    context: "Need UI/UX design"

  - pattern: "procedural|generate|terrain"
    delegate_to: procedural-generation
    context: "Need procedural content for XR"

common_combinations:
  - name: VR Game
    skills:
      - vr-ar-development
      - threejs-3d-graphics
      - game-design
    workflow: |
      1. Design VR-safe gameplay (game-design)
      2. Build 3D scene (threejs-3d-graphics)
      3. Implement XR features (vr-ar-development)

  - name: Hand-Tracked Experience
    skills:
      - vr-ar-development
      - hand-gesture-recognition
      - ui-design
    workflow: |
      1. Design spatial UI (ui-design)
      2. Implement hand tracking (hand-gesture-recognition)
      3. Integrate into VR/AR (vr-ar-development)

  - name: AR Product Viewer
    skills:
      - vr-ar-development
      - threejs-3d-graphics
      - ui-design
    workflow: |
      1. Design product interaction (ui-design)
      2. Optimize 3D models (threejs-3d-graphics)
      3. Implement AR placement (vr-ar-development)

  - name: VR Training Simulation
    skills:
      - vr-ar-development
      - worldbuilding
      - game-design
    workflow: |
      1. Design training scenarios (game-design)
      2. Create environment (worldbuilding)
      3. Build VR simulation (vr-ar-development)

cross_domain_insights:
  - domain: Psychology
    insight: Presence and embodiment research
    application: Design for maximum presence

  - domain: Ergonomics
    insight: Human factors and fatigue
    application: Comfortable session lengths and UI placement

  - domain: Neuroscience
    insight: Vestibular system and motion perception
    application: Motion sickness prevention

  - domain: Architecture
    insight: Spatial design and wayfinding
    application: Virtual environment design

  - domain: Theater
    insight: Directing attention and staging
    application: Spatial narrative and focus

ecosystem_alternatives:
  xr_frameworks:
    - name: WebXR + Three.js
      when: Web-based, cross-platform
      tradeoff: Performance ceiling
    - name: A-Frame
      when: Quick prototyping, declarative
      tradeoff: Less control
    - name: Babylon.js WebXR
      when: Full engine, more features
      tradeoff: Larger bundle
    - name: Unity XR
      when: Native performance, full-featured
      tradeoff: Not web

  platforms:
    - name: WebXR
      when: Cross-platform, no install
      tradeoff: Browser limitations
    - name: Meta Quest Native
      when: Best Quest performance
      tradeoff: Platform-specific
    - name: SteamVR
      when: PC VR, high-end
      tradeoff: Desktop only

  hand_tracking:
    - name: WebXR Hand Input
      when: Standard, cross-platform
      tradeoff: Device dependent
    - name: Meta Hand SDK
      when: Quest-specific features
      tradeoff: Platform lock-in
    - name: MediaPipe + WebXR
      when: Custom processing
      tradeoff: More setup

feedback_loops:
  - from: user-testing
    incorporates:
      - Comfort feedback
      - Session length data
      - Motion sickness reports
    into: Locomotion and UI refinement

  - from: analytics
    incorporates:
      - Frame rate data
      - Tracking quality
      - Feature usage
    into: Performance optimization

prerequisites:
  required_knowledge:
    - 3D graphics fundamentals
    - Three.js or similar
    - Understanding of VR/AR hardware
    - User comfort considerations

  recommended_tools:
    - VR headset for testing (Quest 2/3, etc.)
    - Chrome DevTools WebXR emulator
    - WebXR API Emulator extension
    - Performance profiler

  environment_setup: |
    # WebXR project setup
    npm create vite@latest xr-project -- --template vanilla-ts
    cd xr-project

    # Install dependencies
    npm install three @types/three
    npm install troika-three-text  # For VR text

    # Basic VR setup
    cat > src/main.ts << 'EOF'
    import * as THREE from 'three';
    import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x505050);

    // Camera
    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 1.6, 3);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // VR Button
    document.body.appendChild(VRButton.createButton(renderer));

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 10),
      new THREE.MeshStandardMaterial({ color: 0x222222 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Test cube
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(0.3, 0.3, 0.3),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    cube.position.set(0, 1.5, -1);
    scene.add(cube);

    // Lighting
    scene.add(new THREE.AmbientLight(0x404040));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 1).normalize();
    scene.add(light);

    // Controller
    const controller = renderer.xr.getController(0);
    controller.addEventListener('selectstart', () => {
      cube.material.color.setHex(Math.random() * 0xffffff);
    });
    scene.add(controller);

    // Pointer line
    const line = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -1)
      ])
    );
    line.scale.z = 5;
    controller.add(line);

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    renderer.setAnimationLoop(() => {
      cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    });
    EOF

    # Start dev server (need HTTPS for WebXR)
    npm run dev
    # Use ngrok or similar for HTTPS testing on device
