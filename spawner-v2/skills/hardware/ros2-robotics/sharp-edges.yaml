id: ros2-robotics-sharp-edges
skill: ros2-robotics
version: 1.0.0

sharp_edges:

  - id: topic-name-typo
    severity: critical
    title: "Topic Name Typo Causes Silent Failure"
    summary: "Mistyped topic name creates no connection and no error"
    symptoms:
      - "Publisher publishes but subscriber receives nothing"
      - "Node appears to work but no data flows"
      - "ros2 topic list shows separate topics"
    why: |
      ROS2 doesn't validate topic names at compile or launch time.
      If you type '/odom' in one place and '\odom' in another,
      you get two separate topics with no warning.

      Common typos:
      - Missing leading slash: 'cmd_vel' vs '/cmd_vel'
      - Underscore vs no underscore: 'laser_scan' vs 'laserscan'
      - Namespace issues: '/robot1/cmd_vel' vs '/cmd_vel'

      This is the #1 debugging issue for ROS beginners.
    gotcha: |
      # Publisher uses one name
      self.pub = self.create_publisher(Twist, '/cmd_vel', 10)

      # Subscriber has typo (no error!)
      self.sub = self.create_subscription(Twist, 'cmd_vel', callback, 10)
      # Missing leading '/' - creates separate topic!

      # Both nodes run fine, but no data flows
    solution: |
      # Use constants for topic names
      class Topics:
          CMD_VEL = '/cmd_vel'
          ODOM = '/odom'
          SCAN = '/scan'

      self.pub = self.create_publisher(Twist, Topics.CMD_VEL, 10)
      self.sub = self.create_subscription(Twist, Topics.CMD_VEL, callback, 10)

      # Use remapping in launch files for flexibility
      # Verify with: ros2 topic list
      # Check connections: ros2 topic info /topic_name --verbose

  - id: qos-mismatch
    severity: critical
    title: "QoS Mismatch Causes Silent Connection Failure"
    summary: "Publisher and subscriber QoS incompatibility prevents connection"
    symptoms:
      - "ros2 topic list shows topic exists"
      - "ros2 topic info shows both pub and sub"
      - "No data flows, no error messages"
    why: |
      ROS2 enforces QoS compatibility at connection time.
      If publisher offers less than subscriber requires, no connection.

      Most common mismatch:
      - Publisher: BEST_EFFORT (sensor default)
      - Subscriber: RELIABLE (default for many packages)

      Result: Silent failure, no error message.
    gotcha: |
      # Sensor driver publishes with BEST_EFFORT
      sensor_qos = QoSProfile(reliability=ReliabilityPolicy.BEST_EFFORT, ...)
      self.pub = self.create_publisher(LaserScan, '/scan', sensor_qos)

      # Your node subscribes with default (RELIABLE)
      self.sub = self.create_subscription(LaserScan, '/scan', callback, 10)
      # Connection fails silently!
    solution: |
      # Check QoS with verbose info
      # ros2 topic info /scan --verbose

      # Match publisher's QoS
      from rclpy.qos import qos_profile_sensor_data
      self.sub = self.create_subscription(
          LaserScan, '/scan', callback,
          qos_profile_sensor_data  # Matches sensor publishers
      )

      # Or explicitly set compatible QoS
      sensor_qos = QoSProfile(
          reliability=ReliabilityPolicy.BEST_EFFORT,
          history=HistoryPolicy.KEEP_LAST,
          depth=10
      )

  - id: blocking-callback
    severity: high
    title: "Blocking Operations in Callbacks"
    summary: "Long operations block all other callbacks"
    symptoms:
      - "Timer callbacks become irregular"
      - "Subscribers stop receiving messages"
      - "Node becomes unresponsive"
    why: |
      ROS2 executors are single-threaded by default.
      If one callback takes 1 second, ALL other callbacks wait.

      This means:
      - 100Hz control loop becomes 1Hz
      - Watchdogs trigger
      - Robot stops responding
    gotcha: |
      def callback(self, msg):
          # This blocks the entire executor
          result = self.expensive_computation(msg)  # Takes 500ms
          # All other callbacks wait

      def timer_callback(self):
          # Expected: 100Hz
          # Actual: Whenever expensive_computation finishes
          self.publish_command()
    solution: |
      # Option 1: Use MultiThreadedExecutor
      executor = MultiThreadedExecutor(num_threads=4)

      # With separate callback groups
      from rclpy.callback_groups import MutuallyExclusiveCallbackGroup

      self._sensor_group = MutuallyExclusiveCallbackGroup()
      self._compute_group = MutuallyExclusiveCallbackGroup()

      self.sub = self.create_subscription(
          ..., callback_group=self._sensor_group
      )
      self.timer = self.create_timer(
          0.01, self.control_callback,
          callback_group=self._compute_group
      )

      # Option 2: Async callbacks (ROS2 Humble+)
      async def callback(self, msg):
          result = await asyncio.to_thread(self.expensive_computation, msg)

  - id: tf-timeout
    severity: high
    title: "Transform Lookup Without Timeout"
    summary: "Missing TF transform blocks forever"
    symptoms:
      - "Node hangs waiting for transform"
      - "No error until Ctrl+C"
      - "Works sometimes, hangs other times"
    why: |
      lookup_transform with default timeout blocks forever if
      the transform doesn't exist. This can happen:
      - During startup (TF not published yet)
      - If publishing node dies
      - If frame name is wrong

      No error is raised until you interrupt.
    gotcha: |
      # This blocks forever if transform doesn't exist
      transform = self.tf_buffer.lookup_transform(
          'map', 'base_link',
          rclpy.time.Time()  # Now
      )
    solution: |
      # Always use timeout
      try:
          transform = self.tf_buffer.lookup_transform(
              'map', 'base_link',
              rclpy.time.Time(),
              timeout=rclpy.duration.Duration(seconds=1.0)
          )
      except TransformException as e:
          self.get_logger().warning(f'Transform failed: {e}')
          return  # Handle gracefully

      # Check if transform exists before lookup
      if self.tf_buffer.can_transform('map', 'base_link', rclpy.time.Time()):
          transform = self.tf_buffer.lookup_transform(...)

  - id: parameter-not-declared
    severity: medium
    title: "Using Parameters Without Declaration"
    summary: "get_parameter fails if parameter not declared first"
    symptoms:
      - "ParameterNotDeclaredException on startup"
      - "Works in some nodes, fails in others"
      - "Parameter files seem ignored"
    why: |
      ROS2 requires parameters to be declared before use.
      This is different from ROS1's dynamic parameters.

      If you try to get an undeclared parameter, you get
      an exception, not a default value.
    gotcha: |
      # ROS1 style (doesn't work in ROS2)
      speed = self.get_parameter('max_speed').value
      # Throws: ParameterNotDeclaredException

      # Even if max_speed is in your YAML file!
    solution: |
      # Declare parameter first
      self.declare_parameter('max_speed', 1.0)  # With default
      speed = self.get_parameter('max_speed').value

      # Or declare without default (requires YAML)
      self.declare_parameter('max_speed')

      # Bulk declaration
      self.declare_parameters('', [
          ('max_speed', 1.0),
          ('min_speed', 0.1),
          ('topic_name', '/cmd_vel')
      ])

  - id: time-zero-transform
    severity: high
    title: "Transform Lookup at Time Zero"
    summary: "Requesting latest transform can get stale data"
    symptoms:
      - "Transform is slightly behind"
      - "Sensor data doesn't align with transform"
      - "Inconsistent behavior with sim vs real"
    why: |
      Time(0) means "give me the latest available transform."
      But if you're processing a sensor message from 100ms ago,
      the latest TF might be 100ms newer than your data.

      This causes sensor data to be in the wrong place.
    solution: |
      # Use message timestamp for transform lookup
      def sensor_callback(self, msg):
          try:
              # Use sensor message timestamp
              transform = self.tf_buffer.lookup_transform(
                  'map',
                  msg.header.frame_id,
                  msg.header.stamp,  # Sensor timestamp, not Time(0)
                  timeout=Duration(seconds=0.1)
              )
          except TransformException as e:
              self.get_logger().warning(f'TF lookup failed: {e}')

detection:
  file_patterns:
    - "**/*.py"
    - "**/*.cpp"
    - "**/launch/*.py"
    - "**/config/*.yaml"
