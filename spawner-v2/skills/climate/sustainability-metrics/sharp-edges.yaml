id: sustainability-metrics-sharp-edges
skill: sustainability-metrics
version: 1.0.0

sharp_edges:

  - id: greenwashing-risk
    severity: critical
    title: "Greenwashing Through Selective Disclosure"
    summary: "Cherry-picking metrics creates legal and reputational risk"
    symptoms:
      - "Only positive metrics reported"
      - "Negative trends explained away"
      - "Claims don't match operations"
      - "Regulatory investigation"
      - "NGO or media criticism"
    why: |
      Greenwashing occurs when:
      - Highlighting small positive actions while ignoring large negatives
      - Using vague language without quantification
      - Reporting aspirations as achievements
      - Claiming carbon neutrality without addressing Scope 3
      - Offsetting instead of reducing

      Consequences:
      - SEC/FTC enforcement actions
      - Shareholder lawsuits
      - Brand damage
      - ESG rating downgrades
      - Lost customer trust
    gotcha: |
      # Sustainability report
      report = {
          'renewable_energy': "Achieved 100% renewable electricity",
          'carbon_neutral': "Carbon neutral certified",
          'sustainable_products': "80% of products eco-friendly"
      }

      # What's not in the report:
      # - Scope 3 emissions (90% of footprint) increased 15%
      # - "Carbon neutral" includes low-quality offsets
      # - "Eco-friendly" has no clear definition
      # - Water use increased 40% at key facility
      # - Major supplier has labor violations
    solution: |
      # 1. Report on all material topics - good and bad
      def prepare_balanced_disclosure(metrics: Dict) -> Dict:
          disclosure = {}

          for topic, data in metrics.items():
              if data['is_material']:
                  disclosure[topic] = {
                      'performance': data['value'],
                      'trend': data['yoy_change'],
                      'target': data['target'],
                      'gap': data['value'] - data['target'],
                      'actions_taken': data['actions'],
                      'challenges': data['challenges'],  # Include challenges!
                      'outlook': data['forward_looking']
                  }

          return disclosure

      # 2. Verify claims before publication
      def verify_claims(claims: List[str], evidence: Dict) -> List[Dict]:
          verified = []
          for claim in claims:
              verification = {
                  'claim': claim,
                  'evidence': evidence.get(claim),
                  'verified': evidence.get(claim) is not None,
                  'third_party_verified': evidence.get(claim, {}).get('assurance')
              }

              if not verification['verified']:
                  raise ValueError(f"Unsubstantiated claim: {claim}")

              verified.append(verification)

          return verified

      # 3. Use specific, measurable language
      # Bad: "We are committed to sustainability"
      # Good: "We reduced Scope 1+2 emissions 15% vs 2020 baseline"

      # 4. Disclose methodology and limitations
      # "Scope 3 Category 1 estimated using spend-based method
      #  with Â±20% uncertainty"

      # 5. Include third-party verification
      # "GHG inventory verified by [Auditor] per ISO 14064-3"

  - id: materiality-single-dimension
    severity: high
    title: "Single Materiality in Double Materiality World"
    summary: "CSRD requires both financial AND impact materiality"
    symptoms:
      - "EU reporting non-compliant"
      - "Topics material to society missing"
      - "Stakeholder criticism"
      - "Auditor flags materiality gaps"
    why: |
      Single materiality: Topics material to financial performance only
      Double materiality: Topics material to company OR to society

      CSRD/ESRS requires double materiality:
      - Financial materiality: Affects enterprise value
      - Impact materiality: Company affects society/environment

      Example: Chemical company
      - Single: Focus on regulatory cost of pollution
      - Double: Also disclose actual pollution impact on community

      Many topics are only impact-material (no direct financial effect)
      but must still be reported under double materiality.
    gotcha: |
      # Traditional materiality assessment
      def assess_materiality(topic, financial_impact, stakeholder_input):
          # Only considers financial impact
          score = 0.6 * financial_impact + 0.4 * stakeholder_input
          return score > 3.5

      topics = [
          ('Climate Change', 4.5, 4.8),  # Material
          ('Biodiversity', 2.0, 4.5),    # NOT material (low financial)
          ('Water Stress', 1.5, 4.2),    # NOT material (low financial)
      ]

      # Biodiversity might have high impact on ecosystems
      # but low immediate financial impact
      # Single materiality misses this
    solution: |
      # 1. Assess both dimensions separately
      def assess_double_materiality(topic: str) -> Dict:
          # Financial materiality (inside-out)
          financial = assess_financial_materiality(topic)

          # Impact materiality (outside-in)
          impact = assess_impact_materiality(topic)

          return {
              'topic': topic,
              'financial_materiality': financial,
              'impact_materiality': impact,
              'is_material': financial['score'] > 3.5 or impact['score'] > 3.5,
              'materiality_type': classify_materiality(financial, impact)
          }

      def assess_financial_materiality(topic: str) -> Dict:
          """How topic affects company's financial position."""
          return {
              'score': ...,
              'time_horizon': ...,  # short, medium, long
              'likelihood': ...,
              'magnitude': ...,
              'sources': ['investor survey', 'risk register', 'analyst reports']
          }

      def assess_impact_materiality(topic: str) -> Dict:
          """How company affects society/environment on this topic."""
          return {
              'score': ...,
              'scale': ...,  # Number of people/hectares/etc affected
              'severity': ...,
              'remediability': ...,  # Can harm be undone?
              'sources': ['impact assessment', 'stakeholder input', 'science']
          }

      # 2. Engage diverse stakeholders
      # Investors care about financial materiality
      # NGOs, communities care about impact materiality
      # Both perspectives needed

      # 3. Document the process
      # ESRS requires disclosure of materiality assessment process

  - id: metric-inconsistency
    severity: high
    title: "Inconsistent Metrics Across Time or Frameworks"
    summary: "Changing definitions breaks trend analysis and comparability"
    symptoms:
      - "Trend appears to improve but methodology changed"
      - "Same metric reported differently to different frameworks"
      - "Stakeholders confused by conflicting numbers"
      - "Auditor qualification on comparability"
    why: |
      Consistency issues:
      - Changing calculation methodology year-to-year
      - Different boundaries for different reports
      - Different units or normalization factors
      - Restating history without explanation

      Example:
      - 2022: Report Scope 1 for owned facilities only
      - 2023: Include leased facilities = "20% reduction!"
      - Reality: Boundary expanded, not emissions reduced
    gotcha: |
      # 2022 Report
      scope1_2022 = calculate_emissions(owned_facilities)  # 10,000 tCO2e

      # 2023 Report - changed methodology
      scope1_2023 = calculate_emissions(owned_facilities + leased)  # 12,000 tCO2e

      # Report says: "Scope 1 increased 20%"
      # But owned facilities actually decreased 10%!
      # Misleading comparison

      # Or: Report to CDP in location-based, to investors in market-based
      # Different numbers for "same" metric
    solution: |
      # 1. Maintain methodology register
      class MetricMethodology:
          def __init__(self, metric_id: str):
              self.metric_id = metric_id
              self.versions = []

          def add_version(self, year: int, methodology: Dict):
              self.versions.append({
                  'effective_year': year,
                  'boundary': methodology['boundary'],
                  'calculation': methodology['calculation'],
                  'data_sources': methodology['data_sources'],
                  'assumptions': methodology['assumptions'],
                  'change_reason': methodology.get('change_reason')
              })

          def get_methodology(self, year: int) -> Dict:
              # Return methodology effective for given year
              for v in sorted(self.versions, key=lambda x: -x['effective_year']):
                  if v['effective_year'] <= year:
                      return v
              return self.versions[0]

      # 2. Restate historical data when methodology changes
      def restate_history(old_values: List, old_method: Dict, new_method: Dict) -> List:
          """Restate historical values under new methodology."""
          restated = []
          for year, value in old_values:
              # Apply adjustment factor
              adjustment = calculate_adjustment(old_method, new_method)
              restated.append((year, value * adjustment))

          return restated

      # 3. Disclose methodology clearly
      # "Scope 1 includes all facilities under operational control.
      #  Prior years restated to reflect inclusion of leased facilities
      #  acquired in 2022. Without restatement, 2023 would show
      #  10% reduction on like-for-like basis."

      # 4. Use same boundaries for all frameworks
      # One source of truth for each metric

  - id: no-assurance
    severity: medium
    title: "ESG Data Without Third-Party Verification"
    summary: "Unverified data undermines credibility"
    symptoms:
      - "Stakeholder skepticism"
      - "Lower ESG ratings"
      - "Due diligence questions"
      - "Investor requests for verification"
      - "Regulatory scrutiny"
    why: |
      ESG data historically less rigorous than financial data.
      Issues:
      - Data from multiple unconnected systems
      - Manual calculations prone to error
      - No segregation of duties
      - Different standards than financial audit

      Verification provides:
      - Error detection
      - Process improvement
      - Stakeholder confidence
      - Regulatory compliance (CSRD requires limited assurance)
    gotcha: |
      # Internal ESG reporting
      emissions = calculate_from_spreadsheets()  # No controls
      water = sum_facility_meters()  # Some meters broken
      safety = hr_database.injury_count()  # Classification unclear

      report = {
          'ghg_emissions': emissions,
          'water_use': water,
          'injury_rate': safety
      }

      # Published without verification
      # Later discovered: emissions 30% understated
      # Major restatement required
      # Stakeholder trust damaged
    solution: |
      # 1. Implement internal controls
      class ESGDataControl:
          def __init__(self, metric_id: str):
              self.metric_id = metric_id
              self.controls = []

          def add_control(self, control: Dict):
              """Add internal control."""
              self.controls.append({
                  'type': control['type'],  # 'reconciliation', 'review', 'validation'
                  'frequency': control['frequency'],
                  'owner': control['owner'],
                  'evidence': control['evidence_required']
              })

          def verify_controls(self) -> bool:
              for control in self.controls:
                  if not control_executed(control):
                      return False
              return True

      # 2. Prepare for external assurance
      def assurance_readiness(metric: str) -> Dict:
          """Check readiness for external verification."""
          return {
              'data_trail': has_source_documentation(metric),
              'controls': controls_documented(metric),
              'responsibility': ownership_clear(metric),
              'methodology': methodology_documented(metric),
              'reconciliation': values_reconcile(metric)
          }

      # 3. Phase in assurance coverage
      # Year 1: Limited assurance on Scope 1+2
      # Year 2: Add Scope 3 categories
      # Year 3: Reasonable assurance on material metrics

      # 4. Choose appropriate standard
      # ISAE 3000: General sustainability assurance
      # ISAE 3410: Specific to GHG statements
      # AA1000AS: Stakeholder-focused

  - id: target-without-pathway
    severity: high
    title: "Net Zero Target Without Credible Pathway"
    summary: "Long-term commitment without near-term action"
    symptoms:
      - "2050 target but no 2030 milestones"
      - "Target relies heavily on offsets"
      - "No capital expenditure aligned"
      - "SBTi rejects target"
      - "Stakeholders call out hollow commitment"
    why: |
      "Net zero by 2050" is easy to announce, hard to achieve.
      Credibility requires:
      - Near-term interim targets (2025, 2030)
      - Sector-specific decarbonization pathway
      - Capital allocation aligned with targets
      - Executive incentives linked to progress
      - Transparent progress reporting

      SBTi requirements:
      - 90%+ emissions reduction before offsets
      - Neutralization of residual emissions only
      - Annual reporting on progress
    gotcha: |
      # Net zero commitment
      targets = {
          'net_zero_year': 2050,
          'pathway': 'Under development',
          'interim_targets': None,
          'offset_strategy': 'To be determined',
          'capex_aligned': 'Future commitment'
      }

      # Press release: "Committed to Net Zero by 2050!"
      # Reality: No plan, no milestones, no investment

      # 5 years later: No progress
      # "We remain committed to our 2050 target"
    solution: |
      # 1. Set science-aligned interim targets
      def create_target_pathway(base_year: int, base_emissions: float,
                                 target_year: int = 2050) -> Dict:
          """Create SBTi-aligned target pathway."""
          # 1.5C requires ~4.2% annual reduction
          annual_reduction = 0.042

          pathway = {}
          emissions = base_emissions

          for year in range(base_year, target_year + 1):
              pathway[year] = {
                  'target_emissions': emissions,
                  'reduction_from_base': (base_emissions - emissions) / base_emissions,
                  'is_interim_target': year in [base_year + 5, base_year + 10]
              }
              emissions *= (1 - annual_reduction)

          return pathway

      # 2. Map reduction actions to targets
      def action_roadmap(pathway: Dict, actions: List[Dict]) -> Dict:
          """Align specific actions to target pathway."""
          roadmap = {}

          for year, target in pathway.items():
              year_actions = [
                  a for a in actions
                  if a['implementation_year'] <= year
              ]
              expected_reduction = sum(a['reduction_tco2e'] for a in year_actions)

              roadmap[year] = {
                  'target': target['target_emissions'],
                  'actions': year_actions,
                  'expected_reduction': expected_reduction,
                  'gap': target['target_emissions'] - expected_reduction
              }

          return roadmap

      # 3. Link to capital expenditure
      # Climate capex should match target ambition

      # 4. Limit offset reliance
      # SBTi: >90% actual reduction, offsets for residual only

      # 5. Report progress annually
      # Show actual vs. target with variance explanation

detection:
  file_patterns:
    - "**/*esg*.py"
    - "**/*sustainability*.py"
    - "**/*report*.py"
    - "**/*disclosure*.py"
    - "**/*metric*.py"
