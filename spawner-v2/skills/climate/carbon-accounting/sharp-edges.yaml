id: carbon-accounting-sharp-edges
skill: carbon-accounting
version: 1.0.0

sharp_edges:

  - id: scope-boundary-confusion
    severity: critical
    title: "Emissions Counted in Wrong Scope"
    summary: "Misclassifying emissions leads to inaccurate inventories and double counting"
    symptoms:
      - "Total emissions don't match peer companies"
      - "Scope 3 suspiciously low or high"
      - "Auditor flags boundary issues"
      - "Double counting between company and suppliers"
    why: |
      GHG Protocol defines clear boundaries:
      - Scope 1: Direct emissions from owned/controlled sources
      - Scope 2: Indirect from purchased energy
      - Scope 3: All other value chain emissions

      Common boundary errors:
      - Leased vehicles: depends on operational vs financial control
      - Franchises: can be Scope 1 or 3 depending on control
      - CHP plants: allocation between heat and power
      - Joint ventures: equity vs control approach

      Consequences:
      - Understated inventory misses reduction opportunities
      - Overstated inventory creates impossible targets
      - Double counting inflates industry totals
    gotcha: |
      # Company leases vehicle fleet
      fleet_emissions = calculate_fleet_emissions(vehicles)

      # Where does this go?
      scope_1['fleet'] = fleet_emissions  # Wrong if operating lease
      scope_3['leased_assets'] = fleet_emissions  # Wrong if finance lease

      # Both can be wrong depending on lease type
      # Auditor flags inconsistent treatment
    solution: |
      # 1. Define organizational boundary first
      class OrganizationalBoundary:
          def __init__(self, approach: str):
              # GHG Protocol approaches
              assert approach in ['equity_share', 'financial_control', 'operational_control']
              self.approach = approach

          def classify_source(self, source: dict) -> str:
              if self.approach == 'operational_control':
                  if source.get('operational_control'):
                      return 'scope_1' if source['type'] == 'direct' else 'scope_2'
                  else:
                      return 'scope_3'
              elif self.approach == 'equity_share':
                  # Proportional allocation based on equity
                  return self._equity_classification(source)

      # 2. Document boundary decisions
      boundary_decisions = {
          'leased_vehicles': {
              'classification': 'scope_1',  # Or scope_3
              'rationale': 'Operating leases under operational control approach',
              'ghg_protocol_reference': 'Chapter 3, Table 1'
          }
      }

      # 3. Check for double counting
      def verify_no_double_counting(inventory):
          sources = set()
          for scope in ['scope_1', 'scope_2', 'scope_3']:
              for source_id in inventory[scope]:
                  if source_id in sources:
                      raise ValueError(f"Double counting: {source_id}")
                  sources.add(source_id)

  - id: emission-factor-mismatch
    severity: high
    title: "Wrong Emission Factor Applied"
    summary: "Using outdated, wrong region, or wrong fuel emission factors"
    symptoms:
      - "Emissions vary wildly year-to-year despite stable operations"
      - "Results don't match calculator tools"
      - "Peer benchmarking shows outliers"
      - "Verification identifies factor errors"
    why: |
      Emission factors vary by:
      - Geography (US grid vs EU grid vs China grid)
      - Time (grid decarbonizes over time)
      - Fuel specification (natural gas composition varies)
      - Technology (vehicle type, boiler efficiency)
      - Data source (EPA vs DEFRA vs ecoinvent)

      Common errors:
      - Using global average for specific location
      - Using outdated factors (2010 factors in 2024)
      - Mixing units (per kWh vs per MWh)
      - Using higher heating value vs lower heating value
    gotcha: |
      # Natural gas emissions
      gas_consumption_therms = 50000

      # Using wrong factor
      ef_natural_gas = 5.3  # kg CO2/therm - this is combustion only

      emissions = gas_consumption_therms * ef_natural_gas / 1000  # 265 tonnes

      # But should include CH4 and N2O
      # And factor varies by source (pipeline vs LNG)
      # And HHV vs LHV matters

      # Actual emissions could be 280 tonnes (5% higher)
    solution: |
      # 1. Use structured emission factor database
      class EmissionFactorDB:
          def __init__(self):
              self.factors = {}
              self.metadata = {}

          def get_factor(self, fuel: str, region: str, year: int) -> dict:
              key = (fuel, region, year)

              # Check for exact match
              if key in self.factors:
                  return self.factors[key]

              # Fallback with warnings
              fallback_key = self._find_best_fallback(fuel, region, year)
              warnings.warn(
                  f"Using fallback factor: {fallback_key} for {key}"
              )
              return self.factors[fallback_key]

          def add_factor(self, fuel, region, year, values, source, notes):
              self.factors[(fuel, region, year)] = {
                  'co2': values['co2'],
                  'ch4': values.get('ch4', 0),
                  'n2o': values.get('n2o', 0),
                  'unit': values['unit'],
                  'basis': values.get('basis', 'hhv'),  # HHV or LHV
                  'source': source,
                  'notes': notes
              }

      # 2. Document all factor sources
      ef_db = EmissionFactorDB()
      ef_db.add_factor(
          fuel='natural_gas',
          region='US',
          year=2023,
          values={
              'co2': 53.06,  # kg/MMBtu
              'ch4': 0.001,  # kg/MMBtu
              'n2o': 0.0001,  # kg/MMBtu
              'unit': 'kg/MMBtu',
              'basis': 'hhv'
          },
          source='EPA GHG Emission Factors Hub 2023',
          notes='Commercial sector, utility gas'
      )

      # 3. Convert to CO2e with current GWPs
      def to_co2e(co2, ch4, n2o, gwp_source='AR6'):
          gwps = {
              'AR5': {'ch4': 28, 'n2o': 265},
              'AR6': {'ch4': 27.9, 'n2o': 273}  # 100-year
          }
          gwp = gwps[gwp_source]
          return co2 + ch4 * gwp['ch4'] + n2o * gwp['n2o']

  - id: scope2-method-confusion
    severity: high
    title: "Location vs Market-Based Scope 2 Misapplied"
    summary: "Mixing methods or using wrong approach for context"
    symptoms:
      - "RECs claimed but location-based reported"
      - "Grid factor used despite renewable contract"
      - "Dual reporting inconsistent"
      - "REC claims exceed consumption"
    why: |
      GHG Protocol Scope 2 Guidance requires dual reporting:
      - Location-based: Grid average emission factor
      - Market-based: Reflects contractual instruments

      Market-based hierarchy:
      1. Energy attribute certificates (RECs, GOs)
      2. Direct contracts (PPAs)
      3. Supplier-specific factors
      4. Residual mix factors
      5. Grid average (last resort)

      Double counting risks:
      - Same REC claimed by multiple parties
      - REC vintage mismatch with consumption year
      - Geographic scope mismatch
    gotcha: |
      # Company buys RECs
      electricity_mwh = 10000
      recs_purchased = 10000  # Matching RECs

      # Location-based (correct)
      grid_ef = 0.4  # kg CO2/kWh
      location_based = electricity_mwh * 1000 * grid_ef / 1000  # 4000 tonnes

      # Market-based (seems correct)
      market_based = 0  # RECs cover everything!

      # But wait:
      # - RECs from different grid region?
      # - RECs from different year?
      # - Unbundled RECs vs bundled PPAs?
      # - Do RECs meet quality criteria?
    solution: |
      # 1. Validate REC quality criteria
      class RECValidator:
          def __init__(self):
              self.quality_criteria = {
                  'vintage': 'same_reporting_year',
                  'geography': 'same_market_boundary',
                  'tracking_system': 'recognized_registry',
                  'additionality': 'preferred_but_not_required'
              }

          def validate(self, rec: dict, consumption: dict) -> dict:
              issues = []

              # Vintage check
              if rec['generation_year'] != consumption['year']:
                  issues.append(f"Vintage mismatch: REC {rec['generation_year']}, consumption {consumption['year']}")

              # Geographic check
              if rec['market_boundary'] != consumption['market_boundary']:
                  issues.append(f"Market boundary mismatch")

              # Tracking system
              if rec['registry'] not in ['M-RETS', 'NEPOOL-GIS', 'WREGIS', 'PJM-GATS']:
                  issues.append(f"Unrecognized registry: {rec['registry']}")

              return {
                  'valid': len(issues) == 0,
                  'issues': issues,
                  'recommendation': 'Use residual mix if issues exist'
              }

      # 2. Proper dual reporting
      def calculate_scope2(consumption_mwh, grid_ef, contractual_instruments):
          # Location-based: always grid average
          location_based = consumption_mwh * grid_ef

          # Market-based: apply hierarchy
          remaining = consumption_mwh
          market_based = 0

          for instrument in sorted(contractual_instruments, key=lambda x: x['hierarchy_rank']):
              if remaining <= 0:
                  break

              applied = min(instrument['mwh'], remaining)
              market_based += applied * instrument['emission_factor']
              remaining -= applied

          # Remaining uses residual mix
          if remaining > 0:
              residual_ef = get_residual_mix_factor()
              market_based += remaining * residual_ef

          return {
              'location_based': location_based,
              'market_based': market_based,
              'instruments_applied': contractual_instruments
          }

  - id: scope3-incompleteness
    severity: high
    title: "Incomplete Scope 3 Inventory"
    summary: "Missing material categories or using poor screening"
    symptoms:
      - "Scope 3 is small fraction of total"
      - "Major categories show zero emissions"
      - "Peer comparison shows large gaps"
      - "SBTi rejects target due to incomplete Scope 3"
    why: |
      Scope 3 typically 70-90% of total for most companies.
      15 categories in GHG Protocol:

      Upstream:
      1. Purchased goods and services
      2. Capital goods
      3. Fuel and energy related
      4. Transportation and distribution
      5. Waste generated in operations
      6. Business travel
      7. Employee commuting
      8. Leased assets

      Downstream:
      9. Transportation and distribution
      10. Processing of sold products
      11. Use of sold products
      12. End-of-life treatment
      13. Leased assets
      14. Franchises
      15. Investments

      Screening shortcuts often miss material categories.
    gotcha: |
      # Quick Scope 3 screening
      scope3 = {}

      # Only calculate "easy" categories
      scope3['business_travel'] = calculate_travel_emissions()  # 500 tonnes
      scope3['employee_commuting'] = calculate_commute_emissions()  # 300 tonnes

      total_scope3 = 800  # tonnes

      # But we're a manufacturer!
      # Purchased goods might be 50,000 tonnes
      # Use of sold products might be 100,000 tonnes

      # Scope 3 is actually 99% of footprint, not 10%
    solution: |
      # 1. Screen all 15 categories systematically
      SCOPE3_CATEGORIES = {
          'upstream': {
              1: 'purchased_goods_services',
              2: 'capital_goods',
              3: 'fuel_energy_related',
              4: 'upstream_transport',
              5: 'waste',
              6: 'business_travel',
              7: 'employee_commuting',
              8: 'upstream_leased_assets'
          },
          'downstream': {
              9: 'downstream_transport',
              10: 'processing_sold_products',
              11: 'use_of_sold_products',
              12: 'end_of_life',
              13: 'downstream_leased_assets',
              14: 'franchises',
              15: 'investments'
          }
      }

      def screen_scope3_categories(company_profile: dict) -> dict:
          screening = {}

          for direction in ['upstream', 'downstream']:
              for cat_num, cat_name in SCOPE3_CATEGORIES[direction].items():
                  screening[cat_name] = {
                      'category': cat_num,
                      'relevant': assess_relevance(company_profile, cat_name),
                      'materiality': 'unknown',
                      'data_availability': assess_data_availability(cat_name),
                      'calculation_approach': None,
                      'estimated_magnitude': None
                  }

          return screening

      # 2. Estimate materiality before detailed calculation
      def estimate_materiality(screening: dict, threshold: float = 0.05):
          # Use spend-based estimates for quick sizing
          total_estimate = sum(
              s['estimated_magnitude'] or 0
              for s in screening.values()
          )

          for cat, data in screening.items():
              if data['estimated_magnitude']:
                  share = data['estimated_magnitude'] / total_estimate
                  data['materiality'] = 'high' if share > threshold else 'low'

      # 3. Document exclusions with rationale
      def document_exclusions(screening: dict) -> list:
          exclusions = []
          for cat, data in screening.items():
              if not data['relevant']:
                  exclusions.append({
                      'category': cat,
                      'reason': data.get('exclusion_reason', 'Not applicable'),
                      'verification': 'Confirmed not applicable per GHG Protocol guidance'
                  })
          return exclusions

  - id: baseline-manipulation
    severity: critical
    title: "Baseline Year Selection or Adjustment Issues"
    summary: "Baseline chosen or adjusted to make targets easier"
    symptoms:
      - "Reduction claims seem too good"
      - "Baseline year was anomalous"
      - "Structural changes not properly adjusted"
      - "Target doesn't align with science"
    why: |
      Baseline issues:
      - Cherry-picking high-emission year
      - Not adjusting for M&A activity
      - Inconsistent methodology between years
      - Not recalculating for structural changes

      GHG Protocol requires:
      - Consistent methodology
      - Recalculation for significant changes (>5%)
      - Documented recalculation policy
      - Fixed or rolling baseline approach

      SBTi requires:
      - Recent baseline (within 2 years of submission)
      - Representative of typical operations
    gotcha: |
      # 2019 baseline
      baseline_2019 = 100000  # tonnes CO2e

      # 2019 was unusually high due to:
      # - Temporary production surge
      # - Extreme weather (more heating/cooling)
      # - Inefficient equipment before upgrade

      # 2023 emissions
      current_2023 = 85000  # tonnes

      reduction_claim = (100000 - 85000) / 100000  # 15% reduction!

      # But normalized operations would have been:
      # 2019 adjusted: 90000 tonnes
      # Actual reduction: only 5.5%
    solution: |
      # 1. Baseline selection criteria
      def select_baseline_year(historical_data: dict) -> dict:
          candidates = []

          for year, data in historical_data.items():
              score = 0

              # Data quality
              score += data['verification_level'] * 2  # Verified better

              # Recency
              years_ago = CURRENT_YEAR - year
              if years_ago <= 2:
                  score += 3
              elif years_ago <= 5:
                  score += 1

              # Representativeness
              if data['anomalies']:
                  score -= 2
                  for anomaly in data['anomalies']:
                      logging.warning(f"Year {year} anomaly: {anomaly}")

              # Completeness
              score += data['scope3_completeness'] * 2

              candidates.append({'year': year, 'score': score, 'data': data})

          return max(candidates, key=lambda x: x['score'])

      # 2. Recalculation policy
      class BaselineRecalculation:
          SIGNIFICANCE_THRESHOLD = 0.05  # 5%

          def __init__(self, baseline_year: int, baseline_emissions: float):
              self.baseline_year = baseline_year
              self.original_baseline = baseline_emissions
              self.current_baseline = baseline_emissions
              self.adjustments = []

          def check_trigger(self, change: dict) -> bool:
              """Check if change triggers recalculation."""
              triggers = [
                  'acquisition',
                  'divestiture',
                  'methodology_change',
                  'boundary_change',
                  'emission_factor_update',
                  'error_correction'
              ]

              if change['type'] not in triggers:
                  return False

              # Check significance
              impact = abs(change['emissions_impact']) / self.current_baseline
              return impact >= self.SIGNIFICANCE_THRESHOLD

          def recalculate(self, change: dict):
              if not self.check_trigger(change):
                  return

              adjustment = {
                  'date': change['date'],
                  'type': change['type'],
                  'description': change['description'],
                  'impact': change['emissions_impact'],
                  'previous_baseline': self.current_baseline
              }

              self.current_baseline += change['emissions_impact']
              adjustment['new_baseline'] = self.current_baseline
              self.adjustments.append(adjustment)

              logging.info(
                  f"Baseline recalculated: {adjustment['previous_baseline']:.0f} -> "
                  f"{adjustment['new_baseline']:.0f} due to {change['type']}"
              )

detection:
  file_patterns:
    - "**/*carbon*.py"
    - "**/*emission*.py"
    - "**/*ghg*.py"
    - "**/*scope*.py"
    - "**/*footprint*.py"
