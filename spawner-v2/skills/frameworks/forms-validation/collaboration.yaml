# Collaboration - Forms & Validation
# How this skill works with other skills

version: 1.0.0
skill_id: forms-validation

prerequisites:
  required:
    - skill: react-patterns
      reason: "React fundamentals"
      what_to_know:
        - "useState, useEffect"
        - "Controlled vs uncontrolled components"
        - "Form events"

  recommended:
    - skill: typescript-strict
      reason: "Type-safe forms"
      what_to_know:
        - "Generic types"
        - "Type inference"

    - skill: accessibility
      reason: "Accessible forms"
      what_to_know:
        - "ARIA attributes"
        - "Focus management"

delegation_triggers:
  - trigger: "user needs API endpoint"
    delegate_to: api-design
    context: "Form submission endpoint"

  - trigger: "user needs authentication"
    delegate_to: authentication-oauth
    context: "Login/signup form"

  - trigger: "user needs file upload"
    delegate_to: file-uploads
    context: "Form with file inputs"

  - trigger: "user needs database storage"
    delegate_to: postgres-wizard
    context: "Storing form data"

receives_context_from:
  - skill: api-design
    receives:
      - "Expected request format"
      - "Validation requirements"
      - "Error response format"

  - skill: nextjs-app-router
    receives:
      - "Server Action patterns"
      - "Route structure"

provides_context_to:
  - skill: api-design
    provides:
      - "Form data structure"
      - "Validation rules"

  - skill: testing-strategies
    provides:
      - "Form test patterns"
      - "Validation test cases"

collaboration_patterns:
  with_nextjs:
    when: "Forms in Next.js App Router"
    approach: |
      ## Server Actions Pattern

      // actions/form.ts
      "use server";

      import { formSchema } from "@/lib/schemas";
      import { revalidatePath } from "next/cache";

      export async function submitForm(
        prevState: FormState,
        formData: FormData
      ) {
        const parsed = formSchema.safeParse(
          Object.fromEntries(formData)
        );

        if (!parsed.success) {
          return {
            errors: parsed.error.flatten().fieldErrors,
          };
        }

        await db.insert(entries).values(parsed.data);
        revalidatePath("/entries");

        return { success: true };
      }


      // components/Form.tsx
      "use client";

      import { useActionState } from "react";
      import { submitForm } from "@/actions/form";

      export function Form() {
        const [state, action, pending] = useActionState(
          submitForm,
          {}
        );

        return (
          <form action={action}>
            {/* Progressive enhancement: works without JS */}
          </form>
        );
      }

  with_react_query:
    when: "Form with server state"
    approach: |
      ## React Query Mutation

      import { useMutation, useQueryClient } from "@tanstack/react-query";
      import { useForm } from "react-hook-form";

      function ContactForm() {
        const queryClient = useQueryClient();

        const mutation = useMutation({
          mutationFn: submitContact,
          onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ["contacts"] });
            form.reset();
          },
        });

        const form = useForm({
          resolver: zodResolver(schema),
        });

        return (
          <form onSubmit={form.handleSubmit(mutation.mutate)}>
            {mutation.error && (
              <div role="alert">{mutation.error.message}</div>
            )}

            {/* form fields */}

            <button
              type="submit"
              disabled={mutation.isPending}
            >
              {mutation.isPending ? "Sending..." : "Send"}
            </button>
          </form>
        );
      }

  with_shadcn:
    when: "Using shadcn/ui form components"
    approach: |
      ## shadcn Form Component

      import { useForm } from "react-hook-form";
      import { zodResolver } from "@hookform/resolvers/zod";
      import {
        Form,
        FormControl,
        FormField,
        FormItem,
        FormLabel,
        FormMessage,
      } from "@/components/ui/form";
      import { Input } from "@/components/ui/input";
      import { Button } from "@/components/ui/button";

      export function ProfileForm() {
        const form = useForm({
          resolver: zodResolver(profileSchema),
          defaultValues: { name: "", email: "" },
        });

        return (
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)}>
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Name</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input type="email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <Button type="submit">Save</Button>
            </form>
          </Form>
        );
      }

ecosystem:
  form_libraries:
    - name: "react-hook-form"
      use_when: "Most React forms"
    - name: "formik"
      use_when: "Legacy projects"
    - name: "conform"
      use_when: "Progressive enhancement focus"

  validation:
    - name: "zod"
      use_when: "TypeScript projects"
    - name: "yup"
      use_when: "Legacy projects"
    - name: "valibot"
      use_when: "Bundle size critical"

  ui_components:
    - name: "shadcn/ui"
      use_when: "Customizable components"
    - name: "react-aria"
      use_when: "Maximum accessibility"
