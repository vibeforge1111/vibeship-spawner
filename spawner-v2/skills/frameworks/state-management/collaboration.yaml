# Collaboration - State Management
# How this skill works with other skills

version: 1.0.0
skill_id: state-management

prerequisites:
  required:
    - skill: react-patterns
      reason: "React fundamentals required"
      what_to_know:
        - "Hooks (useState, useEffect)"
        - "Component lifecycle"
        - "Props and children"

  recommended:
    - skill: typescript
      reason: "Type-safe state management"
      what_to_know:
        - "Generics"
        - "Type inference"

  knowledge:
    - "React hooks basics"
    - "Component re-rendering"
    - "Immutability concepts"

delegation_triggers:
  - trigger: "user needs form handling"
    delegate_to: react-patterns
    context: "react-hook-form patterns"

  - trigger: "user needs API design"
    delegate_to: api-design
    context: "API structure affects state"

  - trigger: "user needs testing"
    delegate_to: testing-strategies
    context: "Testing state management"

  - trigger: "user needs performance optimization"
    delegate_to: performance-optimization
    context: "Re-render optimization"

receives_context_from:
  - skill: react-patterns
    receives:
      - "Component structure"
      - "Data flow requirements"
      - "Form handling needs"

  - skill: nextjs-app-router
    receives:
      - "Server/client component split"
      - "Data fetching approach"
      - "Route structure"

  - skill: backend
    receives:
      - "API endpoint structure"
      - "Data models"
      - "Real-time requirements"

provides_context_to:
  - skill: react-patterns
    provides:
      - "State management solution"
      - "Store structure"
      - "Selector patterns"

  - skill: testing-strategies
    provides:
      - "Store mocking patterns"
      - "State setup for tests"
      - "Query client configuration"

  - skill: performance-optimization
    provides:
      - "Re-render patterns"
      - "Selector optimization"
      - "Memoization needs"

escalation_paths:
  - situation: "Complex form logic"
    escalate_to: react-patterns
    context: "react-hook-form integration"

  - situation: "API caching issues"
    escalate_to: backend
    context: "Cache invalidation strategy"

  - situation: "Performance issues"
    escalate_to: performance-optimization
    context: "Re-render profiling"

workflow_integration:
  typical_sequence:
    1:
      step: "Identify state needs"
      skills: [state-management]
      output: "Server vs client state classification"

    2:
      step: "Choose solutions"
      skills: [state-management]
      output: "React Query for server, Zustand for client"

    3:
      step: "Setup React Query"
      skills: [state-management]
      output: "Query client, hooks, optimistic updates"

    4:
      step: "Setup client stores"
      skills: [state-management]
      output: "Zustand stores with persistence"

    5:
      step: "Integrate with components"
      skills: [react-patterns, state-management]
      output: "Connected components"

    6:
      step: "Add tests"
      skills: [testing-strategies]
      output: "Store and hook tests"

  decision_points:
    - question: "Redux or Zustand?"
      guidance: |
        Redux when:
        - Large team, need conventions
        - Complex interconnected state
        - Want Redux DevTools history
        - Using RTK Query for everything

        Zustand when:
        - Smaller codebase
        - Want simplicity
        - Minimal boilerplate
        - Using React Query for server state

    - question: "Zustand or Jotai?"
      guidance: |
        Zustand when:
        - Single store pattern
        - Actions defined centrally
        - Familiar with Redux patterns
        - Want middleware (persist, immer)

        Jotai when:
        - Atomic state model
        - Bottom-up approach
        - Recoil-like patterns
        - Many independent atoms

    - question: "Context or external store?"
      guidance: |
        Context when:
        - Static values (theme, locale)
        - Values change rarely
        - No performance concerns
        - Simple provider/consumer

        External store when:
        - Frequently changing values
        - Many consumers
        - Need selectors
        - Performance matters

collaboration_patterns:
  with_nextjs:
    when: "State management in Next.js App Router"
    approach: |
      Next.js App Router + State:

      ## Server state with React Query

      // providers.tsx (client component)
      'use client';

      import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
      import { useState } from 'react';

      export function Providers({ children }) {
        const [queryClient] = useState(() => new QueryClient({
          defaultOptions: {
            queries: {
              staleTime: 60 * 1000,
            },
          },
        }));

        return (
          <QueryClientProvider client={queryClient}>
            {children}
          </QueryClientProvider>
        );
      }


      ## Zustand in client components

      // store.ts
      import { create } from 'zustand';
      import { persist } from 'zustand/middleware';

      export const useUIStore = create(
        persist(
          (set) => ({
            sidebarOpen: true,
            toggleSidebar: () => set((s) => ({
              sidebarOpen: !s.sidebarOpen
            })),
          }),
          { name: 'ui-store' }
        )
      );


      ## Hydration for persisted stores

      // HydrationBoundary.tsx
      'use client';

      import { useEffect, useState } from 'react';

      export function HydrationBoundary({ children }) {
        const [hydrated, setHydrated] = useState(false);

        useEffect(() => {
          setHydrated(true);
        }, []);

        if (!hydrated) {
          return <div>Loading...</div>;
        }

        return children;
      }

  with_forms:
    when: "Form state management"
    approach: |
      Forms with React Hook Form:

      // Don't put form state in global store!

      import { useForm } from 'react-hook-form';
      import { zodResolver } from '@hookform/resolvers/zod';
      import { z } from 'zod';

      const schema = z.object({
        email: z.string().email(),
        password: z.string().min(8),
      });

      function LoginForm() {
        const {
          register,
          handleSubmit,
          formState: { errors, isSubmitting },
        } = useForm({
          resolver: zodResolver(schema),
        });

        const loginMutation = useMutation({
          mutationFn: login,
          onSuccess: (user) => {
            // Only put result in global state
            useUserStore.getState().setUser(user);
          },
        });

        return (
          <form onSubmit={handleSubmit(loginMutation.mutate)}>
            <input {...register('email')} />
            {errors.email && <span>{errors.email.message}</span>}
            <input {...register('password')} type="password" />
            <button disabled={isSubmitting}>Login</button>
          </form>
        );
      }

  with_testing:
    when: "Testing state management"
    approach: |
      Testing State:

      ## Testing Zustand

      import { act, renderHook } from '@testing-library/react';
      import { useStore } from './store';

      // Reset store between tests
      beforeEach(() => {
        useStore.setState({ count: 0 });
      });

      test('increment increases count', () => {
        const { result } = renderHook(() => useStore());

        act(() => {
          result.current.increment();
        });

        expect(result.current.count).toBe(1);
      });


      ## Testing React Query

      import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
      import { renderHook, waitFor } from '@testing-library/react';

      function createWrapper() {
        const queryClient = new QueryClient({
          defaultOptions: {
            queries: { retry: false },
          },
        });

        return ({ children }) => (
          <QueryClientProvider client={queryClient}>
            {children}
          </QueryClientProvider>
        );
      }

      test('useUser fetches user', async () => {
        const { result } = renderHook(() => useUser('123'), {
          wrapper: createWrapper(),
        });

        await waitFor(() => {
          expect(result.current.isSuccess).toBe(true);
        });

        expect(result.current.data.name).toBe('John');
      });

platform_integration:
  react_query_devtools:
    setup: |
      # React Query DevTools

      npm install @tanstack/react-query-devtools

      // In providers
      import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

      <QueryClientProvider client={queryClient}>
        {children}
        <ReactQueryDevtools initialIsOpen={false} />
      </QueryClientProvider>
    considerations:
      - "Only in development"
      - "Inspect queries and cache"
      - "Trigger refetches manually"

  zustand_devtools:
    setup: |
      # Zustand DevTools

      import { devtools } from 'zustand/middleware';

      const useStore = create(
        devtools(
          (set) => ({
            count: 0,
            increment: () => set(
              (s) => ({ count: s.count + 1 }),
              false,
              'increment'  // Action name for devtools
            ),
          }),
          { name: 'MyStore' }
        )
      );

      // Use Redux DevTools extension
    considerations:
      - "Name your store"
      - "Name your actions"
      - "Time-travel debugging"

ecosystem:
  server_state:
    - name: "@tanstack/react-query"
      use_when: "Data fetching, caching, sync"
    - name: "swr"
      use_when: "Simpler API, Vercel ecosystem"
    - name: "RTK Query"
      use_when: "Already using Redux"

  client_state:
    - name: "zustand"
      use_when: "Simple global state"
    - name: "jotai"
      use_when: "Atomic state model"
    - name: "@reduxjs/toolkit"
      use_when: "Complex state, large teams"

  url_state:
    - name: "nuqs"
      use_when: "Type-safe URL state in Next.js"
    - name: "next-usequerystate"
      use_when: "Simple URL state"

  forms:
    - name: "react-hook-form"
      use_when: "Complex forms, validation"
    - name: "@hookform/resolvers"
      use_when: "Zod/Yup validation"

  alternatives:
    - name: "valtio"
      use_when: "Proxy-based reactivity"
      avoid_when: "Team prefers immutability"

    - name: "mobx"
      use_when: "OOP patterns, observables"
      avoid_when: "Prefer functional patterns"
