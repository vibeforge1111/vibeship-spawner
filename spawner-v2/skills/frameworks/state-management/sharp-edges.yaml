# Sharp Edges - State Management
# The gotchas that cause bugs, re-renders, and frustration

version: 1.0.0
skill_id: state-management

sharp_edges:
  - id: stale-closure
    summary: Stale closures in state updates
    severity: critical
    situation: |
      Your counter increments once, then stops. Or worse, it jumps between
      values randomly. You're using count inside setCount, but count is
      always the old value. Classic stale closure trap.
    why: |
      When you use a state variable inside a callback, the callback captures
      the value at the time it was created. If the callback persists (like
      in useEffect or event handlers), it keeps the old value even after
      state changes.
    solution: |
      # USE FUNCTIONAL UPDATES

      // WRONG: Stale closure
      function Counter() {
        const [count, setCount] = useState(0);

        useEffect(() => {
          const timer = setInterval(() => {
            setCount(count + 1);  // count is always 0!
          }, 1000);
          return () => clearInterval(timer);
        }, []);  // Missing count dependency
      }


      // WRONG: Adding count to deps causes infinite restarts
      useEffect(() => {
        const timer = setInterval(() => {
          setCount(count + 1);
        }, 1000);
        return () => clearInterval(timer);
      }, [count]);  // Timer restarts every second!


      // RIGHT: Functional update
      useEffect(() => {
        const timer = setInterval(() => {
          setCount((c) => c + 1);  // Uses current value
        }, 1000);
        return () => clearInterval(timer);
      }, []);  // No dependency needed


      // With Zustand - use get()
      const useStore = create((set, get) => ({
        count: 0,
        increment: () => {
          // WRONG
          set({ count: get().count + 1 });  // Fine for sync

          // Inside async, use set with function
          setTimeout(() => {
            set((state) => ({ count: state.count + 1 }));
          }, 1000);
        },
      }));


      // With useCallback
      const handleClick = useCallback(() => {
        setCount((c) => c + 1);  // Always current
      }, []);  // Stable reference
    symptoms:
      - Counter only increments once
      - State updates seem to reset
      - Values jump unexpectedly
    detection_pattern: 'setInterval.*set[A-Z].*[^(]\\+|setTimeout.*set[A-Z].*[^(]\\+'

  - id: object-reference-equality
    summary: Object/array state not triggering updates
    severity: high
    situation: |
      You push to an array or modify an object property. Component doesn't
      re-render. You check - state is updated! But React doesn't see it
      because the reference is the same.
    why: |
      React uses reference equality to detect changes. If you mutate an
      object/array, the reference stays the same. React thinks nothing
      changed. You must create new references.
    solution: |
      # CREATE NEW REFERENCES

      // WRONG: Mutating array
      const [items, setItems] = useState([]);
      items.push(newItem);  // Mutates, same reference
      setItems(items);      // React: "same array, no update"


      // RIGHT: New array
      setItems([...items, newItem]);

      // Or
      setItems((prev) => [...prev, newItem]);


      // WRONG: Mutating object
      const [user, setUser] = useState({ name: 'John', age: 30 });
      user.name = 'Jane';  // Mutates
      setUser(user);       // Same reference


      // RIGHT: New object
      setUser({ ...user, name: 'Jane' });

      // Or
      setUser((prev) => ({ ...prev, name: 'Jane' }));


      // WRONG: Nested mutation
      const [data, setData] = useState({
        user: { profile: { name: 'John' } }
      });
      data.user.profile.name = 'Jane';
      setData(data);


      // RIGHT: New references at each level
      setData({
        ...data,
        user: {
          ...data.user,
          profile: {
            ...data.user.profile,
            name: 'Jane',
          },
        },
      });


      // BETTER: Use Immer
      import { produce } from 'immer';

      setData(produce(data, (draft) => {
        draft.user.profile.name = 'Jane';  // Immer handles immutability
      }));


      // Zustand with Immer middleware
      import { immer } from 'zustand/middleware/immer';

      const useStore = create(immer((set) => ({
        user: { profile: { name: 'John' } },
        updateName: (name) => set((state) => {
          state.user.profile.name = name;  // Direct mutation OK
        }),
      })));
    symptoms:
      - Component doesn't re-render after state update
      - Stale UI despite state change
      - Push/mutation doesn't trigger update
    detection_pattern: '\\.push\\(|state\\.[a-z]+\\s*='

  - id: context-re-renders
    summary: Context causing unnecessary re-renders
    severity: high
    situation: |
      You add theme context. Now every component re-renders when theme
      changes, even components that don't use theme. App becomes sluggish.
      React DevTools shows everything re-rendering.
    why: |
      When Context value changes, ALL consumers re-render. If your context
      value is an object created inline, it's a new object every render.
      Even unchanged consumers think there's an update.
    solution: |
      # OPTIMIZE CONTEXT

      // WRONG: Object created every render
      function Provider({ children }) {
        const [user, setUser] = useState(null);

        return (
          <UserContext.Provider value={{ user, setUser }}>
            {children}
          </UserContext.Provider>
        );
      }


      // RIGHT: Memoize the value
      function Provider({ children }) {
        const [user, setUser] = useState(null);

        const value = useMemo(() => ({ user, setUser }), [user]);

        return (
          <UserContext.Provider value={value}>
            {children}
          </UserContext.Provider>
        );
      }


      // BETTER: Separate contexts for separate concerns
      const UserContext = createContext(null);
      const SetUserContext = createContext(null);

      function Provider({ children }) {
        const [user, setUser] = useState(null);

        return (
          <UserContext.Provider value={user}>
            <SetUserContext.Provider value={setUser}>
              {children}
            </SetUserContext.Provider>
          </UserContext.Provider>
        );
      }

      // Components that only set don't re-render when user changes
      function LogoutButton() {
        const setUser = useContext(SetUserContext);
        return <button onClick={() => setUser(null)}>Logout</button>;
      }


      // BEST: Use Zustand for frequently changing state
      const useUserStore = create((set) => ({
        user: null,
        setUser: (user) => set({ user }),
      }));

      // Only components using user re-render
      function UserName() {
        const user = useUserStore((s) => s.user);  // Selector
        return <span>{user?.name}</span>;
      }
    symptoms:
      - All consumers re-render on any change
      - Sluggish app with context
      - DevTools shows cascade of renders
    detection_pattern: 'Provider value=\\{\\{'

  - id: zustand-selector-rerenders
    summary: Zustand re-rendering on unrelated state changes
    severity: medium
    situation: |
      You have a big Zustand store. Component only uses `user`, but
      re-renders when `cart` changes. You're selecting the whole state
      or using equality check wrong.
    why: |
      Zustand re-renders when selector result changes (by reference).
      If you select multiple values or objects, you need proper selectors.
      Default shallow comparison might not work for nested objects.
    solution: |
      # USE PROPER SELECTORS

      // WRONG: Selecting whole state
      function Component() {
        const state = useStore();  // Re-renders on ANY change
        return <div>{state.user.name}</div>;
      }


      // RIGHT: Select specific values
      function Component() {
        const userName = useStore((s) => s.user.name);
        return <div>{userName}</div>;
      }


      // WRONG: Selecting object without shallow
      function Component() {
        const user = useStore((s) => s.user);  // Object reference
        // Re-renders even if user content is same
      }


      // RIGHT: Use shallow for objects
      import { shallow } from 'zustand/shallow';

      function Component() {
        const user = useStore((s) => s.user, shallow);
        // Only re-renders if user properties change
      }


      // RIGHT: Select multiple with shallow
      function Component() {
        const { user, cart } = useStore(
          (s) => ({ user: s.user, cart: s.cart }),
          shallow
        );
      }


      // BEST: Create selector hooks
      const useUser = () => useStore((s) => s.user, shallow);
      const useCart = () => useStore((s) => s.cart, shallow);
      const useCartCount = () => useStore((s) => s.cart.length);

      function Header() {
        const cartCount = useCartCount();  // Only count
        return <span>Cart: {cartCount}</span>;
      }
    symptoms:
      - Component re-renders on unrelated state
      - Objects trigger re-renders when content unchanged
      - Performance issues with large store
    detection_pattern: 'useStore\\(\\)(?!\\s*\\()'

  - id: react-query-cache-misses
    summary: React Query not caching as expected
    severity: medium
    situation: |
      You navigate away and back. React Query fetches again. You expected
      it to use cache. Or you update data but the list doesn't refresh.
      Query keys don't match, cache is missed.
    why: |
      React Query caches by query key (array). If keys don't match exactly,
      it's a cache miss. Common issue: object in key that changes reference,
      or forgetting to include all dependencies.
    solution: |
      # QUERY KEYS MUST BE CONSISTENT

      // WRONG: Object reference in key
      const filters = { status: 'active' };
      useQuery({
        queryKey: ['todos', filters],  // New object every render!
        queryFn: () => fetchTodos(filters),
      });


      // RIGHT: Stable key
      const status = 'active';
      useQuery({
        queryKey: ['todos', { status }],  // Same shape = same cache
        queryFn: () => fetchTodos({ status }),
      });


      // Use query key factories
      const todoKeys = {
        all: ['todos'] as const,
        lists: () => [...todoKeys.all, 'list'] as const,
        list: (filters: Filters) => [...todoKeys.lists(), filters] as const,
        details: () => [...todoKeys.all, 'detail'] as const,
        detail: (id: string) => [...todoKeys.details(), id] as const,
      };

      // Consistent keys
      useQuery({
        queryKey: todoKeys.list({ status }),
        queryFn: () => fetchTodos({ status }),
      });


      // Invalidation that works
      const queryClient = useQueryClient();

      // Invalidate all todos
      queryClient.invalidateQueries({ queryKey: todoKeys.all });

      // Invalidate just lists
      queryClient.invalidateQueries({ queryKey: todoKeys.lists() });


      // Keep previous data during refetch
      useQuery({
        queryKey: todoKeys.list({ status }),
        queryFn: () => fetchTodos({ status }),
        placeholderData: keepPreviousData,  // Show old data while loading new
      });
    symptoms:
      - Data refetches on navigation
      - Updates don't reflect in lists
      - Cache seems to not work
    detection_pattern: 'queryKey.*\\{'

  - id: server-client-state-duplication
    summary: Duplicating server data in client state
    severity: medium
    situation: |
      You fetch users with React Query, then copy them to Redux "for easier
      access". Now you have two sources of truth. They get out of sync.
      Bugs everywhere because you're not sure which is correct.
    why: |
      Server state (from API) and client state (UI preferences) are different.
      React Query already caches and synchronizes server state. Copying to
      Redux creates duplication and sync issues.
    solution: |
      # DON'T DUPLICATE SERVER STATE

      // WRONG: Copy to Redux
      const { data } = useQuery({ queryKey: ['users'], queryFn: fetchUsers });

      useEffect(() => {
        if (data) {
          dispatch(setUsers(data));  // Now in two places!
        }
      }, [data]);


      // RIGHT: Use React Query as the source
      function useUsers() {
        return useQuery({
          queryKey: ['users'],
          queryFn: fetchUsers,
          staleTime: 5 * 60 * 1000,
        });
      }

      // Just use the hook wherever needed
      function UserList() {
        const { data: users } = useUsers();
        return users?.map(u => <User key={u.id} user={u} />);
      }

      function UserCount() {
        const { data: users } = useUsers();  // Same cache!
        return <span>{users?.length ?? 0} users</span>;
      }


      // For derived state, use select
      function useActiveUsers() {
        return useQuery({
          queryKey: ['users'],
          queryFn: fetchUsers,
          select: (users) => users.filter(u => u.active),
        });
      }


      // Client state is different
      const useUIStore = create((set) => ({
        selectedUserId: null,
        setSelectedUser: (id) => set({ selectedUserId: id }),
        sidebarOpen: false,
        toggleSidebar: () => set((s) => ({ sidebarOpen: !s.sidebarOpen })),
      }));

      // Combine server + client state in component
      function UserDetail() {
        const selectedId = useUIStore((s) => s.selectedUserId);
        const { data: user } = useUser(selectedId);  // Server state
        const [editing, setEditing] = useState(false);  // Local state
      }
    symptoms:
      - Data out of sync between stores
      - Updates in one place don't reflect elsewhere
      - "Which store has the right data?"
    detection_pattern: 'useQuery.*dispatch\\(|useEffect.*dispatch.*data'
