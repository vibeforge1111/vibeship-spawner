# Validations - Angular
# Automated checks for common Angular issues

version: 1.0.0
skill_id: angular

validations:
  # Performance issues
  - id: default-change-detection
    name: Component using default change detection
    severity: info
    type: regex
    pattern:
      - '@Component\s*\(\s*\{(?![\s\S]*changeDetection)[\s\S]*?\}\s*\)'
    message: "Consider using ChangeDetectionStrategy.OnPush for better performance"
    fix_action: "Add changeDetection: ChangeDetectionStrategy.OnPush"
    applies_to:
      - "*.component.ts"

  - id: template-method-call
    name: Method call in template
    severity: warning
    type: regex
    pattern:
      - '\{\{\s*\w+\s*\([^)]*\)\s*\}\}'
      - '\[[\w.]+\]="[^"]*\w+\s*\([^)]*\)[^"]*"'
    message: "Method calls in templates run on every change detection cycle"
    fix_action: "Use computed signal, pipe, or pre-compute in component"
    applies_to:
      - "*.component.html"
      - "*.component.ts"

  # Memory leaks
  - id: subscribe-without-cleanup
    name: Subscribe without unsubscribe mechanism
    severity: warning
    type: regex
    pattern:
      - '\.subscribe\s*\([^)]+\)(?![\s\S]*takeUntil|[\s\S]*takeUntilDestroyed|[\s\S]*unsubscribe)'
    message: "Subscription may not be properly cleaned up"
    fix_action: "Use async pipe, toSignal, takeUntilDestroyed, or manual unsubscribe"
    applies_to:
      - "*.component.ts"

  - id: nested-subscribe
    name: Nested subscribe calls
    severity: warning
    type: regex
    pattern:
      - '\.subscribe\s*\([^}]*\.subscribe\s*\('
    message: "Nested subscribes cause callback hell - use RxJS operators"
    fix_action: "Use switchMap, mergeMap, or forkJoin instead"
    applies_to:
      - "*.ts"

  # Type safety
  - id: any-type-usage
    name: Using 'any' type
    severity: info
    type: regex
    pattern:
      - ':\s*any\s*[;=\)]'
      - '<any>'
      - 'as\s+any'
    message: "Using 'any' bypasses TypeScript benefits"
    fix_action: "Define proper types or interfaces"
    applies_to:
      - "*.ts"

  - id: non-strict-equals
    name: Using == instead of ===
    severity: info
    type: regex
    pattern:
      - '[^!=]==\s*[^=]'
      - '[^!]==[^=]'
    message: "Use strict equality (===) for type-safe comparisons"
    fix_action: "Replace == with ==="
    applies_to:
      - "*.ts"

  # Architecture issues
  - id: logic-in-component
    name: HTTP calls directly in component
    severity: info
    type: regex
    pattern:
      - '@Component[\s\S]*HttpClient[\s\S]*\.get\s*\('
      - '@Component[\s\S]*HttpClient[\s\S]*\.post\s*\('
    message: "HTTP calls should be in services, not components"
    fix_action: "Move HTTP logic to a dedicated service"
    applies_to:
      - "*.component.ts"

  - id: ngmodule-in-new-project
    name: NgModule usage in standalone project
    severity: info
    type: regex
    pattern:
      - '@NgModule\s*\('
    message: "Consider using standalone components for new Angular 17+ projects"
    fix_action: "Migrate to standalone components with imports array"
    applies_to:
      - "*.module.ts"

  # Template issues
  - id: missing-trackby
    name: ngFor without trackBy (old syntax)
    severity: info
    type: regex
    pattern:
      - '\*ngFor="[^"]*"(?![\s\S]*trackBy)'
    message: "ngFor without trackBy can cause performance issues"
    fix_action: "Add trackBy function or migrate to @for with track"
    applies_to:
      - "*.html"
      - "*.component.ts"

  - id: missing-track-in-for
    name: "@for without track expression"
    severity: warning
    type: regex
    pattern:
      - '@for\s*\([^)]+\)\s*\{(?![^}]*track\s)'
    message: "@for requires a track expression"
    fix_action: "Add 'track item.id' or 'track $index'"
    applies_to:
      - "*.html"
      - "*.component.ts"

  # Form issues
  - id: template-driven-complex-form
    name: Template-driven form with complex validation
    severity: info
    type: regex
    pattern:
      - 'ngModel[\s\S]*ngModel[\s\S]*ngModel[\s\S]*ngModel'
    message: "Consider reactive forms for complex form handling"
    fix_action: "Migrate to ReactiveFormsModule for better control"
    applies_to:
      - "*.html"

  # Security
  - id: innerhtml-binding
    name: Direct innerHTML binding
    severity: warning
    type: regex
    pattern:
      - '\[innerHTML\]="'
    message: "innerHTML can be an XSS vector - ensure content is sanitized"
    fix_action: "Use DomSanitizer or avoid innerHTML if possible"
    applies_to:
      - "*.html"
      - "*.component.ts"

  - id: bypass-security
    name: Bypassing Angular security
    severity: warning
    type: regex
    pattern:
      - 'bypassSecurityTrust'
    message: "Bypassing security should be a last resort with trusted content only"
    fix_action: "Ensure content is from trusted source, document why bypass is needed"
    applies_to:
      - "*.ts"

code_smells:
  - id: component-too-large
    name: Component with too many lines
    description: "Components over 200 lines often do too much"
    pattern: null
    suggestion: "Break into smaller components or extract logic to services"

  - id: constructor-injection-overload
    name: Too many dependencies injected
    description: "Component with 5+ injected dependencies"
    pattern: 'constructor\s*\([^)]*,[^)]*,[^)]*,[^)]*,[^)]*\)'
    suggestion: "Component may be doing too much - consider splitting"

  - id: mixing-signals-and-observables
    name: Inconsistent reactive patterns
    description: "Using both signals and BehaviorSubject for similar purposes"
    pattern: null
    suggestion: "Choose one pattern and be consistent within a feature"

best_practices:
  component_structure:
    recommendation: |
      Angular component organization:

      @Component({
        selector: 'app-user-profile',
        standalone: true,
        imports: [CommonModule, RouterLink, UserAvatarComponent],
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: `...`,
        styles: `...`
      })
      export class UserProfileComponent {
        // 1. Dependency injection
        private userService = inject(UserService);
        private router = inject(Router);

        // 2. Inputs and outputs
        @Input({ required: true }) userId!: string;
        @Output() userUpdated = new EventEmitter<User>();

        // 3. Signals and state
        user = signal<User | null>(null);
        loading = signal(true);

        // 4. Computed values
        fullName = computed(() =>
          `${this.user()?.firstName} ${this.user()?.lastName}`
        );

        // 5. Constructor effects
        constructor() {
          effect(() => {
            console.log('User changed:', this.user());
          });
        }

        // 6. Lifecycle hooks
        ngOnInit() { ... }

        // 7. Public methods
        updateUser(data: Partial<User>) { ... }

        // 8. Private methods
        private loadUser() { ... }
      }

  testing_setup:
    recommendation: |
      Angular testing patterns:

      // Component test
      describe('UserProfileComponent', () => {
        let component: UserProfileComponent;
        let fixture: ComponentFixture<UserProfileComponent>;
        let userServiceSpy: jasmine.SpyObj<UserService>;

        beforeEach(async () => {
          userServiceSpy = jasmine.createSpyObj('UserService', ['getUser']);

          await TestBed.configureTestingModule({
            imports: [UserProfileComponent],
            providers: [
              { provide: UserService, useValue: userServiceSpy }
            ]
          }).compileComponents();

          fixture = TestBed.createComponent(UserProfileComponent);
          component = fixture.componentInstance;
        });

        it('should load user on init', () => {
          userServiceSpy.getUser.and.returnValue(of(mockUser));
          fixture.detectChanges();
          expect(component.user()).toEqual(mockUser);
        });
      });

  file_naming:
    recommendation: |
      Angular naming conventions:

      # Components
      user-profile.component.ts
      user-profile.component.html
      user-profile.component.scss
      user-profile.component.spec.ts

      # Services
      user.service.ts
      user.service.spec.ts

      # Pipes
      format-date.pipe.ts

      # Guards
      auth.guard.ts

      # Interceptors
      auth.interceptor.ts

      # Directives
      highlight.directive.ts

      # Models/Interfaces
      user.model.ts  or  user.interface.ts

      # Standalone approach (preferred)
      features/
        users/
          user-profile.component.ts
          user-list.component.ts
          user.service.ts
          user.routes.ts
