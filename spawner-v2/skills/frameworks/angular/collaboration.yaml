# Collaboration - Angular
# How this skill works with other skills

version: 1.0.0
skill_id: angular

prerequisites:
  required: []

  recommended:
    - skill: typescript-advanced
      reason: "Angular is deeply integrated with TypeScript"
      what_to_know:
        - "Decorators and metadata"
        - "Generics"
        - "Strict type checking"

    - skill: rxjs
      reason: "Angular uses RxJS extensively"
      what_to_know:
        - "Observables and operators"
        - "Subject types"
        - "Error handling patterns"

  knowledge:
    - "TypeScript fundamentals"
    - "HTML and CSS"
    - "Component-based architecture concepts"
    - "npm/package management"

delegation_triggers:
  - trigger: "user needs complex state management"
    delegate_to: ngrx
    context: "NgRx for Redux-style state management"

  - trigger: "user needs end-to-end testing"
    delegate_to: testing
    context: "Playwright or Cypress for E2E tests"

  - trigger: "user needs CI/CD pipeline"
    delegate_to: devops
    context: "Angular build and deployment automation"

  - trigger: "user needs backend API"
    delegate_to: backend
    context: "REST or GraphQL API design"

  - trigger: "user needs design system"
    delegate_to: tailwind-ui
    context: "Tailwind CSS with Angular"

receives_context_from:
  - skill: tailwind-ui
    receives:
      - "Design tokens and styling approach"
      - "Component styling patterns"

  - skill: graphql-schema
    receives:
      - "API schema for typed clients"
      - "Query and mutation definitions"

  - skill: firebase
    receives:
      - "Authentication patterns"
      - "Firestore integration approach"

provides_context_to:
  - skill: testing
    provides:
      - "Component structure for test setup"
      - "Service interfaces for mocking"
      - "E2E user flows"

  - skill: devops
    provides:
      - "Build configuration (angular.json)"
      - "Environment configurations"
      - "Bundle analysis needs"

  - skill: ngrx
    provides:
      - "Feature structure"
      - "State shape requirements"
      - "Effect patterns needed"

escalation_paths:
  - situation: "Complex reactive state across features"
    escalate_to: ngrx
    context: "Consider NgRx Store or SignalStore for global state"

  - situation: "Performance issues with large lists"
    escalate_to: performance-profiling
    context: "Virtual scrolling, trackBy, OnPush needed"

  - situation: "Complex form workflows"
    escalate_to: frontend
    context: "Multi-step forms, dynamic fields, complex validation"

workflow_integration:
  typical_sequence:
    1:
      step: "Create Angular project"
      skills: [angular]
      output: "ng new with standalone, strict mode"

    2:
      step: "Set up routing"
      skills: [angular]
      output: "Lazy-loaded feature routes"

    3:
      step: "Create feature components"
      skills: [angular, tailwind-ui]
      output: "Styled standalone components"

    4:
      step: "Implement services and HTTP"
      skills: [angular, backend]
      output: "Type-safe API integration"

    5:
      step: "Add state management"
      skills: [angular, ngrx]
      output: "Predictable state flow"

    6:
      step: "Write tests"
      skills: [angular, testing]
      output: "Unit and E2E coverage"

    7:
      step: "Deploy"
      skills: [devops]
      output: "CI/CD pipeline, hosting"

  decision_points:
    - question: "Standalone or NgModule?"
      guidance: |
        Standalone (recommended for new projects):
        - Angular 17+ projects
        - Simpler mental model
        - Better tree-shaking
        - Explicit imports

        NgModule (still valid):
        - Existing projects
        - Third-party libraries requiring modules
        - Complex provider scoping

    - question: "Signals or RxJS?"
      guidance: |
        Use Signals for:
        - Component state
        - Derived/computed values
        - Synchronous reactivity

        Use RxJS for:
        - HTTP calls and async operations
        - Complex event streams
        - Debouncing, throttling
        - Multiple subscribers

        They work together:
        user$ = this.http.get<User>('/api/user');
        user = toSignal(this.user$);

    - question: "Template-driven or Reactive forms?"
      guidance: |
        Template-driven:
        - Simple forms (login, contact)
        - Two-way binding sufficient
        - Minimal validation

        Reactive:
        - Complex forms
        - Dynamic fields
        - Cross-field validation
        - Unit testing form logic

collaboration_patterns:
  with_tailwind:
    when: "Styling Angular components"
    approach: |
      Tailwind CSS with Angular:

      # Install Tailwind
      npm install -D tailwindcss postcss autoprefixer
      npx tailwindcss init

      # tailwind.config.js
      module.exports = {
        content: ["./src/**/*.{html,ts}"],
        theme: { extend: {} },
        plugins: []
      };

      # styles.scss
      @tailwind base;
      @tailwind components;
      @tailwind utilities;

      # In components
      @Component({
        template: `
          <button class="bg-blue-500 hover:bg-blue-700 text-white
                         font-bold py-2 px-4 rounded">
            Click me
          </button>
        `
      })

  with_firebase:
    when: "Firebase backend integration"
    approach: |
      Angular + Firebase:

      # Install
      npm install @angular/fire firebase

      # app.config.ts
      import { provideFirebaseApp, initializeApp } from '@angular/fire/app';
      import { provideFirestore, getFirestore } from '@angular/fire/firestore';
      import { provideAuth, getAuth } from '@angular/fire/auth';

      export const appConfig: ApplicationConfig = {
        providers: [
          provideFirebaseApp(() => initializeApp(environment.firebase)),
          provideFirestore(() => getFirestore()),
          provideAuth(() => getAuth())
        ]
      };

      # Service
      @Injectable({ providedIn: 'root' })
      export class UserService {
        private firestore = inject(Firestore);

        getUsers() {
          const usersRef = collection(this.firestore, 'users');
          return collectionData(usersRef, { idField: 'id' }) as Observable<User[]>;
        }
      }

  with_ngrx:
    when: "Complex state management needed"
    approach: |
      NgRx SignalStore (modern approach):

      // users.store.ts
      import { signalStore, withState, withMethods, patchState } from '@ngrx/signals';

      type UsersState = {
        users: User[];
        loading: boolean;
        error: string | null;
      };

      const initialState: UsersState = {
        users: [],
        loading: false,
        error: null
      };

      export const UsersStore = signalStore(
        { providedIn: 'root' },
        withState(initialState),
        withMethods((store, userService = inject(UserService)) => ({
          loadUsers: rxMethod<void>(
            pipe(
              tap(() => patchState(store, { loading: true })),
              switchMap(() => userService.getUsers()),
              tap(users => patchState(store, { users, loading: false }))
            )
          ),
          addUser(user: User) {
            patchState(store, { users: [...store.users(), user] });
          }
        }))
      );

      // Component
      @Component({
        template: `
          @if (store.loading()) {
            <spinner />
          } @else {
            @for (user of store.users(); track user.id) {
              <user-card [user]="user" />
            }
          }
        `
      })
      export class UsersComponent {
        store = inject(UsersStore);

        constructor() {
          this.store.loadUsers();
        }
      }

platform_integration:
  ssr:
    setup: |
      # Angular SSR (Server-Side Rendering)

      # Add SSR to existing project
      ng add @angular/ssr

      # Project structure
      src/
        app/
          app.component.ts
          app.config.ts          # Browser config
          app.config.server.ts   # Server config
        main.ts
        main.server.ts
        server.ts                # Express server

      # Check if running on server
      import { isPlatformServer } from '@angular/common';
      import { PLATFORM_ID, inject } from '@angular/core';

      @Component({ ... })
      export class MyComponent {
        private platformId = inject(PLATFORM_ID);

        ngOnInit() {
          if (isPlatformServer(this.platformId)) {
            // Server-only code
          }
        }
      }

      # Build and run
      npm run build
      npm run serve:ssr:my-app
    considerations:
      - "Avoid direct DOM manipulation"
      - "Check platform before browser APIs"
      - "Transfer state from server to client"

  nx_monorepo:
    setup: |
      # Nx Monorepo with Angular

      # Create workspace
      npx create-nx-workspace@latest myorg --preset=angular-monorepo

      # Add application
      nx g @nx/angular:app myapp

      # Add library
      nx g @nx/angular:lib shared-ui

      # Build/test affected
      nx affected -t build
      nx affected -t test

      # Project structure
      apps/
        myapp/
        myapp-e2e/
      libs/
        shared/
          ui/
          data-access/
          util/
        feature-users/
    considerations:
      - "Use libs for shared code"
      - "Enforce module boundaries"
      - "Use affected commands in CI"

ecosystem:
  primary_tools:
    - "Angular CLI (ng)"
    - "Angular DevTools (Chrome extension)"
    - "Angular Language Service (VS Code)"

  libraries:
    - name: Angular Material
      use_when: "Material Design UI"
    - name: PrimeNG
      use_when: "Rich enterprise components"
    - name: ngx-translate
      use_when: "i18n beyond built-in"
    - name: Apollo Angular
      use_when: "GraphQL client"

  alternatives:
    - name: React
      use_when: "More flexibility, larger ecosystem"
      avoid_when: "Need opinionated structure, TypeScript-first"

    - name: Vue
      use_when: "Simpler learning curve, smaller apps"
      avoid_when: "Enterprise requirements, full framework needed"

  deprecated:
    - "AngularJS (v1.x) - completely different framework"
    - "View Engine (use Ivy)"
    - "karma + jasmine (consider Jest)"
    - "Protractor (use Playwright)"
