# Collaboration - Vue & Nuxt
# How this skill works with other skills

version: 1.0.0
skill_id: vue-nuxt

prerequisites:
  required: []

  recommended:
    - skill: frontend
      reason: "General frontend patterns and web fundamentals"
      what_to_know:
        - "HTML, CSS, JavaScript basics"
        - "DOM manipulation concepts"
        - "Component architecture principles"

    - skill: typescript-strict
      reason: "Type-safe Vue development"
      what_to_know:
        - "Generic types for composables"
        - "defineProps type syntax"
        - "Ref and computed types"

  knowledge:
    - "Understanding of reactive programming concepts"
    - "Familiarity with component-based architecture"
    - "Basic understanding of SSR vs CSR"

delegation_triggers:
  - trigger: "user needs CSS/styling system"
    delegate_to: tailwind-ui
    context: "Styling and design system"

  - trigger: "user needs backend API"
    delegate_to: backend
    context: "Server-side API development"

  - trigger: "user needs component testing"
    delegate_to: testing
    context: "Vue component testing with Vitest"

  - trigger: "user needs deployment"
    delegate_to: devops
    context: "Nuxt deployment to Vercel/Netlify/etc"

  - trigger: "user needs database"
    delegate_to: supabase-backend
    context: "Backend and database for Nuxt app"

receives_from:
  - skill: frontend
    receives:
      - "Component architecture patterns"
      - "Accessibility requirements"
      - "Performance budgets"

  - skill: tailwind-ui
    receives:
      - "Design tokens and themes"
      - "Component variants"
      - "Responsive patterns"

  - skill: api-design
    receives:
      - "API contracts to consume"
      - "Response schemas"
      - "Error formats"

provides_context_to:
  - skill: testing
    provides:
      - "Components to test"
      - "Composables to unit test"
      - "User flows for e2e"

  - skill: devops
    provides:
      - "Build configuration"
      - "Environment requirements"
      - "SSR considerations"

  - skill: performance-thinker
    provides:
      - "Bundle size concerns"
      - "Render performance"
      - "SSR timing"

escalation_paths:
  - situation: "Need complex animations"
    escalate_to: frontend
    context: "Motion design with GSAP or Framer Motion"

  - situation: "State management at enterprise scale"
    escalate_to: backend
    context: "Architecture patterns for large apps"

  - situation: "Performance issues"
    escalate_to: performance-thinker
    context: "Vue DevTools analysis, bundle optimization"

  - situation: "Accessibility audit"
    escalate_to: frontend
    context: "WCAG compliance, screen reader testing"

workflow_integration:
  typical_sequence:
    1:
      step: "Set up Nuxt 3 project"
      skills: [vue-nuxt]
      output: "Project scaffold with TypeScript"

    2:
      step: "Configure styling"
      skills: [tailwind-ui]
      output: "Tailwind config, theme tokens"

    3:
      step: "Build components"
      skills: [vue-nuxt]
      output: "SFC components with composition API"

    4:
      step: "Add data layer"
      skills: [supabase-backend, vue-nuxt]
      output: "useFetch composables, API routes"

    5:
      step: "Add state management"
      skills: [vue-nuxt]
      output: "Pinia stores for global state"

    6:
      step: "Write tests"
      skills: [testing]
      output: "Component and e2e tests"

    7:
      step: "Deploy"
      skills: [devops]
      output: "CI/CD, hosting setup"

  decision_points:
    - question: "Vue or Nuxt?"
      guidance: |
        Vue (Vite):
        - SPA without SSR
        - Widget/embed for other apps
        - Existing backend serves pages

        Nuxt 3:
        - Full-stack Vue apps
        - Need SSR/SSG/ISR
        - File-based routing
        - API routes with Nitro
        - Auto-imports

    - question: "Options API or Composition API?"
      guidance: |
        Composition API (always for new code):
        - Better TypeScript
        - Logic reuse via composables
        - Smaller bundles
        - Industry direction

        Options API (only for):
        - Legacy codebases
        - Maintaining old code

    - question: "Pinia or composables for state?"
      guidance: |
        Composables (local shared state):
        - 2-3 components sharing state
        - Scoped to feature
        - No persistence needed

        Pinia (global state):
        - App-wide state
        - Needs persistence
        - DevTools debugging
        - SSR state transfer

collaboration_patterns:
  with_typescript:
    when: "Building type-safe Vue apps"
    approach: |
      TypeScript enhances Vue:

      // Props with types
      const props = defineProps<{
        user: User
        count?: number
      }>()

      // Emits with types
      const emit = defineEmits<{
        (e: 'select', id: string): void
        (e: 'update', value: number): void
      }>()

      // Composables with generics
      function useFetch<T>(url: string) {
        const data = ref<T | null>(null)
        const error = ref<Error | null>(null)
        // ...
        return { data, error }
      }

  with_tailwind:
    when: "Styling Vue components"
    approach: |
      Tailwind works great with Vue:

      <template>
        <button
          :class="[
            'px-4 py-2 rounded',
            variant === 'primary'
              ? 'bg-blue-500 text-white'
              : 'bg-gray-200 text-gray-800'
          ]"
          @click="emit('click')"
        >
          <slot />
        </button>
      </template>

      // Use CVA for complex variants
      import { cva } from 'class-variance-authority'

      const button = cva('px-4 py-2 rounded', {
        variants: {
          intent: {
            primary: 'bg-blue-500 text-white',
            secondary: 'bg-gray-200 text-gray-800'
          },
          size: {
            sm: 'text-sm',
            lg: 'text-lg px-6 py-3'
          }
        }
      })

  with_testing:
    when: "Testing Vue components"
    approach: |
      Vue Test Utils with Vitest:

      import { mount } from '@vue/test-utils'
      import { describe, it, expect } from 'vitest'
      import Counter from './Counter.vue'

      describe('Counter', () => {
        it('increments count', async () => {
          const wrapper = mount(Counter)

          expect(wrapper.text()).toContain('0')

          await wrapper.find('button').trigger('click')

          expect(wrapper.text()).toContain('1')
        })

        it('emits update event', async () => {
          const wrapper = mount(Counter)

          await wrapper.find('button').trigger('click')

          expect(wrapper.emitted('update')).toHaveLength(1)
          expect(wrapper.emitted('update')[0]).toEqual([1])
        })
      })

platform_integration:
  vite:
    setup: |
      npm create vite@latest my-vue-app -- --template vue-ts
      cd my-vue-app
      npm install
      npm run dev
    considerations:
      - "Use @vitejs/plugin-vue for SFC support"
      - "Configure alias: '@': './src'"
      - "Add vitest for testing"

  nuxt:
    setup: |
      npx nuxi@latest init my-nuxt-app
      cd my-nuxt-app
      npm install
      npm run dev
    considerations:
      - "Auto-imports enabled by default"
      - "composables/ and components/ are auto-scanned"
      - "Use runtime config for env vars"
      - "Nitro handles API routes automatically"

  pinia:
    setup: |
      # Already included in Nuxt 3
      # For Vue only:
      npm install pinia

      // main.ts
      import { createPinia } from 'pinia'
      app.use(createPinia())

      // stores/counter.ts
      import { defineStore } from 'pinia'

      export const useCounterStore = defineStore('counter', () => {
        const count = ref(0)
        const increment = () => count.value++
        return { count, increment }
      })
    considerations:
      - "Use composition API style (function) over options"
      - "storeToRefs for destructuring reactive values"
      - "Actions don't need storeToRefs"

ecosystem:
  primary_tools:
    - "Vue DevTools browser extension"
    - "Volar VS Code extension"
    - "Vitest for unit testing"
    - "Playwright for e2e testing"

  alternatives:
    - name: React
      use_when: "Need larger ecosystem, job market priority"
      avoid_when: "Want simpler reactivity, prefer Vue DX"

    - name: Svelte
      use_when: "Want compile-time reactivity, smaller bundles"
      avoid_when: "Need mature ecosystem, TypeScript-first"

  deprecated:
    - "Vue 2 (EOL Dec 2023)"
    - "Vuex (replaced by Pinia)"
    - "Options API for new code"
    - "@vue/composition-api (built into Vue 3)"
