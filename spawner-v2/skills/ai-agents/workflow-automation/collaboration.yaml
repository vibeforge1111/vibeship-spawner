# Collaboration - Workflow Automation
# How this skill works with other skills

version: 1.0.0
skill_id: workflow-automation

prerequisites:
  required: []

  recommended:
    - skill: backend
      reason: "Implementing workflow activities and handlers"
      what_to_know:
        - "Async programming patterns"
        - "Error handling and retries"
        - "External API integration"

    - skill: devops
      reason: "Deploying and monitoring workflow platforms"
      what_to_know:
        - "Container orchestration for Temporal workers"
        - "Serverless deployment for Inngest"
        - "Self-hosting n8n"

    - skill: database
      reason: "Workflow state and activity data"
      what_to_know:
        - "Transaction patterns"
        - "Idempotency keys in database"
        - "Event sourcing concepts"

delegation_triggers:
  - trigger: "user needs multi-agent coordination"
    delegate_to: multi-agent-orchestration
    context: "Workflow provides infrastructure, orchestration provides patterns"

  - trigger: "user needs tool building for workflows"
    delegate_to: agent-tool-builder
    context: "Tools that workflows can invoke"

  - trigger: "user needs Zapier/Make integration"
    delegate_to: zapier-make-patterns
    context: "No-code automation platforms"

  - trigger: "user needs browser automation in workflow"
    delegate_to: browser-automation
    context: "Playwright/Puppeteer activities"

  - trigger: "user needs computer control in workflow"
    delegate_to: computer-use-agents
    context: "Desktop automation activities"

  - trigger: "user needs LLM integration in workflow"
    delegate_to: llm-architect
    context: "AI-powered workflow steps"

receives_context_from:
  - skill: multi-agent-orchestration
    receives:
      - "Agent coordination patterns to implement as durable workflows"
      - "Handoff requirements between agents"
      - "Memory and state management needs"

  - skill: product-strategy
    receives:
      - "Business processes requiring automation"
      - "SLA requirements for workflow completion"
      - "Cost constraints for platform selection"

  - skill: backend
    receives:
      - "API endpoints to orchestrate"
      - "Service dependencies and timeouts"
      - "Error types and retry strategies"

  - skill: devops
    receives:
      - "Infrastructure constraints"
      - "Deployment platform preferences"
      - "Monitoring requirements"

provides_context_to:
  - skill: multi-agent-orchestration
    provides:
      - "Durable execution infrastructure for agents"
      - "Event-driven trigger patterns"
      - "Recovery and retry mechanisms"

  - skill: devops
    provides:
      - "Worker deployment requirements"
      - "Platform resource needs"
      - "Monitoring and alerting setup"

  - skill: agent-evaluation
    provides:
      - "Workflow reliability metrics"
      - "Execution traces for analysis"
      - "Failure patterns to test"

  - skill: backend
    provides:
      - "Activity implementation requirements"
      - "Timeout and retry expectations"
      - "Idempotency key patterns"

escalation_paths:
  - situation: "Workflow performance issues"
    escalate_to: performance-thinker
    context: "Step optimization, parallelization"

  - situation: "Platform deployment and scaling"
    escalate_to: devops
    context: "Worker scaling, container orchestration"

  - situation: "Security concerns with workflow data"
    escalate_to: security-specialist
    context: "Secrets management, data encryption"

  - situation: "Complex event processing patterns"
    escalate_to: event-architect
    context: "Event sourcing, CQRS patterns"

  - situation: "Workflow costs too high"
    escalate_to: cost-optimizer
    context: "Platform selection, execution optimization"

workflow_integration:
  typical_sequence:
    1:
      step: "Identify automation needs"
      skills: [product-strategy]
      output: "Business processes requiring automation"

    2:
      step: "Select workflow platform"
      skills: [workflow-automation]
      output: "Platform choice based on requirements"

    3:
      step: "Design workflow structure"
      skills: [workflow-automation, multi-agent-orchestration]
      output: "Workflow definition with steps"

    4:
      step: "Implement activities"
      skills: [backend]
      output: "Activity functions with error handling"

    5:
      step: "Deploy and configure"
      skills: [devops]
      output: "Running workflow infrastructure"

    6:
      step: "Test reliability"
      skills: [agent-evaluation]
      output: "Verified retry and recovery behavior"

  decision_points:
    - question: "Which workflow platform to use?"
      guidance: |
        Use n8n when:
        - Non-technical team members need to build workflows
        - Visual workflow design is important
        - Quick prototyping needed
        - Self-hosting is acceptable

        Use Temporal when:
        - Mission-critical financial workflows
        - Complex saga patterns with compensation
        - Long-running workflows (days/weeks)
        - Maximum reliability required

        Use Inngest when:
        - TypeScript/JavaScript codebase
        - Serverless deployment preferred
        - Good developer experience matters
        - Event-driven architecture

        Use AWS Step Functions when:
        - Already in AWS ecosystem
        - Existing Lambda functions to orchestrate
        - JSON-based workflow definition acceptable

    - question: "Durable execution or simple queue?"
      guidance: |
        Use durable execution (Temporal, Inngest, Step Functions) when:
        - Money is involved (payments, refunds)
        - State changes are hard to reverse
        - Multi-step processes must complete
        - Recovery from failure is critical

        Use simple queue (SQS, Redis, BullMQ) when:
        - Fire-and-forget is acceptable
        - Steps are independent
        - Failure can be logged and ignored
        - Simple retry is sufficient

    - question: "Event-driven or scheduled?"
      guidance: |
        Event-driven when:
        - Reacting to user actions
        - Webhook-triggered processes
        - Real-time requirements
        - Variable workload patterns

        Scheduled when:
        - Batch processing
        - Daily/weekly reports
        - Periodic sync operations
        - Predictable workload patterns

collaboration_patterns:
  with_agents:
    when: "Building agentic workflows"
    approach: |
      - Use workflow as durable backbone for agent execution
      - Each agent action becomes a durable step
      - Store agent state between steps
      - Handle agent failures with workflow retries

      Example:
      export const agentWorkflow = inngest.createFunction(
        { id: "agent-task" },
        { event: "agent/task" },
        async ({ event, step }) => {
          // Step 1: Agent plans
          const plan = await step.run("plan", () =>
            agent.plan(event.data.task)
          );

          // Step 2-N: Execute plan steps
          for (const action of plan.actions) {
            await step.run(`execute-${action.id}`, () =>
              agent.execute(action)
            );
          }

          // Final: Synthesize result
          return step.run("synthesize", () =>
            agent.synthesize(plan.results)
          );
        }
      );

  with_payments:
    when: "Payment processing workflows"
    approach: |
      - Always use idempotency keys
      - Separate charge and capture for flexibility
      - Implement compensation for refunds
      - Log all state transitions

  with_external_apis:
    when: "Orchestrating third-party services"
    approach: |
      - Add timeout to all API calls
      - Implement circuit breaker pattern
      - Cache repeated calls when appropriate
      - Handle rate limits with backoff

  with_notifications:
    when: "User notification workflows"
    approach: |
      - Deduplicate notifications
      - Batch when possible
      - Implement user preferences check
      - Track delivery status

platform_specifics:
  n8n:
    strengths:
      - "400+ pre-built integrations"
      - "Visual workflow builder"
      - "Self-hostable"
      - "Active community"
    considerations:
      - "Less suitable for complex programming logic"
      - "Credentials stored in database"
      - "No built-in versioning"
    deployment:
      - "Docker self-host recommended"
      - "n8n.cloud for managed option"
      - "Postgres for production database"

  temporal:
    strengths:
      - "Strongest durability guarantees"
      - "Saga pattern support"
      - "Replay debugging"
      - "Multi-language SDKs"
    considerations:
      - "Steeper learning curve"
      - "Need to understand workflow vs activity distinction"
      - "Determinism rules are strict"
    deployment:
      - "Temporal Cloud for managed option"
      - "Self-host with Kubernetes"
      - "Workers are separate deployment"

  inngest:
    strengths:
      - "Best developer experience"
      - "Works with any hosting (Vercel, Railway, etc.)"
      - "Built-in event system"
      - "Step-level retries"
    considerations:
      - "TypeScript/JavaScript only"
      - "Newer platform"
      - "Some features still maturing"
    deployment:
      - "Inngest Cloud (default)"
      - "Self-host for enterprise"
      - "Dev server for local testing"

  step_functions:
    strengths:
      - "Tight AWS integration"
      - "Visual workflow designer"
      - "Pay-per-execution"
      - "Express mode for high-volume"
    considerations:
      - "256KB payload limit"
      - "JSON Path expressions can be tricky"
      - "Vendor lock-in to AWS"
    deployment:
      - "AWS SAM or CDK"
      - "Integrated with Lambda"
      - "CloudWatch for monitoring"

migration_paths:
  from_cron_jobs:
    steps:
      - "Identify all cron jobs and their schedules"
      - "Determine which need durability (most do)"
      - "Convert to scheduled workflow functions"
      - "Add error handling and alerting"
      - "Test failure and recovery"

  from_simple_queues:
    steps:
      - "Map queue consumers to workflow steps"
      - "Identify state that needs persistence"
      - "Add idempotency keys"
      - "Implement dead letter handling"
      - "Migrate incrementally by workflow"

  to_different_platform:
    steps:
      - "Abstract business logic into activities"
      - "Keep workflow orchestration thin"
      - "Use platform-agnostic patterns where possible"
      - "Maintain activity interface compatibility"
