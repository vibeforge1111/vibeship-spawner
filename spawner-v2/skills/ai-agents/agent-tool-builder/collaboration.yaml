# Collaboration - Agent Tool Builder
# How this skill works with other skills

version: 1.0.0
skill_id: agent-tool-builder

prerequisites:
  required: []

  recommended:
    - skill: api-designer
      reason: "Tool interfaces follow API design principles"
      what_to_know:
        - "RESTful design patterns"
        - "Input/output contract design"
        - "Error handling conventions"

    - skill: llm-architect
      reason: "Understanding model capabilities and limitations"
      what_to_know:
        - "Context window constraints"
        - "Model-specific tool calling features"
        - "Token efficiency considerations"

    - skill: backend
      reason: "Implementing tool backends"
      what_to_know:
        - "Async programming"
        - "Error handling patterns"
        - "External API integration"

delegation_triggers:
  - trigger: "user needs to coordinate multiple tools"
    delegate_to: multi-agent-orchestration
    context: "Tool orchestration across agents"

  - trigger: "user needs persistent memory between tool calls"
    delegate_to: agent-memory-systems
    context: "State management for tools"

  - trigger: "user building voice agent tools"
    delegate_to: voice-agents
    context: "Audio/voice-specific tool requirements"

  - trigger: "user needs computer control tools"
    delegate_to: computer-use-agents
    context: "Desktop automation tools"

  - trigger: "user wants to test their tools"
    delegate_to: agent-evaluation
    context: "Tool testing and evaluation"

receives_context_from:
  - skill: multi-agent-orchestration
    receives:
      - "Tool requirements for multi-agent systems"
      - "Coordination constraints on tool design"
      - "Shared state requirements"

  - skill: product-strategy
    receives:
      - "Product features requiring tool implementation"
      - "User workflows tools must support"

  - skill: api-designer
    receives:
      - "API contracts to expose as tools"
      - "Existing API patterns to follow"

provides_context_to:
  - skill: multi-agent-orchestration
    provides:
      - "Working tools for agent use"
      - "Tool capabilities and limitations"
      - "Error handling behavior"

  - skill: agent-evaluation
    provides:
      - "Tools to test"
      - "Expected tool behavior"
      - "Edge cases to validate"

  - skill: backend
    provides:
      - "Implementation requirements for tool backends"
      - "Input validation requirements"
      - "Error response formats"

escalation_paths:
  - situation: "Tool needs complex API integration"
    escalate_to: api-designer
    context: "API design and integration patterns"

  - situation: "Tool security concerns"
    escalate_to: security-specialist
    context: "Input validation, injection prevention"

  - situation: "Tool performance issues"
    escalate_to: performance-thinker
    context: "Latency optimization, caching"

  - situation: "MCP server deployment"
    escalate_to: devops
    context: "Server deployment, transport configuration"

workflow_integration:
  typical_sequence:
    1:
      step: "Define tool requirements"
      skills: [product-strategy]
      output: "What tools are needed and why"

    2:
      step: "Design tool interfaces"
      skills: [agent-tool-builder, api-designer]
      output: "Tool schemas with comprehensive descriptions"

    3:
      step: "Implement tool backends"
      skills: [backend]
      output: "Working tool implementations"

    4:
      step: "Add to agent"
      skills: [agent-tool-builder]
      output: "Tools registered with agent"

    5:
      step: "Test with LLM"
      skills: [agent-evaluation]
      output: "Validated tool behavior"

  decision_points:
    - question: "Build custom tool or use MCP server?"
      guidance: |
        Use MCP server when:
        - Tool will be reused across projects
        - Need cross-provider compatibility
        - Want community-maintained tools

        Use custom tool when:
        - Tight integration with your app
        - Simple, one-off functionality
        - Performance-critical operations

    - question: "How many tools per agent?"
      guidance: |
        - Aim for < 20 tools per agent
        - Use tool search for larger libraries
        - Group related operations into smart tools
        - Remove rarely-used tools

    - question: "When to use tool examples?"
      guidance: |
        Use input_examples when:
        - Tools have nested objects
        - Format-sensitive parameters
        - Optional parameter combinations
        - Edge cases that need demonstration

collaboration_patterns:
  with_frontend:
    when: "Building tools that return UI data"
    approach: |
      - Return structured JSON that frontend can render
      - Include metadata (pagination, counts)
      - Consider streaming for large results
      - Return image URLs, not raw image data

  with_database:
    when: "Building data access tools"
    approach: |
      - Parameterized queries only
      - Return only necessary fields
      - Add pagination for large results
      - Cache repeated queries

  with_external_apis:
    when: "Wrapping third-party APIs"
    approach: |
      - Add timeout to all calls
      - Handle rate limits gracefully
      - Cache when appropriate
      - Transform responses to simpler format

  with_security:
    when: "Building tools with sensitive operations"
    approach: |
      - Validate all inputs
      - Sanitize for injection
      - Audit log all calls
      - Implement least privilege

provider_specifics:
  anthropic:
    features:
      - "Beta tool runner for automatic handling"
      - "input_examples for complex tools"
      - "Tool search for dynamic loading"
      - "Programmatic tool calling"
    considerations:
      - "Use is_error flag for failures"
      - "tool_result blocks immediately after tool_use"
      - "All parallel results in single message"

  openai:
    features:
      - "Strict mode for schema enforcement"
      - "Parallel tool calls by default"
      - "Function calling with JSON mode"
    considerations:
      - "Enable strict: true on tools"
      - "Use additionalProperties: false"
      - "Handle max_tokens truncation"

  google:
    features:
      - "Function calling in Vertex AI"
      - "JSON Schema format"
    considerations:
      - "Similar patterns to OpenAI"
      - "Check model-specific limitations"
