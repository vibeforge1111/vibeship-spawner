# Collaboration - Multi-Agent Orchestration
# How this skill works with other skills

version: 1.0.0
skill_id: multi-agent-orchestration

prerequisites:
  required:
    - skill: llm-architect
      reason: "Understanding LLM capabilities, context windows, and model selection for each agent"
      what_to_know:
        - "Which models work best for which agent roles"
        - "Context window limitations and token costs"
        - "Latency vs capability tradeoffs"

  recommended:
    - skill: system-designer
      reason: "Multi-agent systems are distributed systems"
      what_to_know:
        - "Distributed system failure modes"
        - "State synchronization patterns"
        - "Observability and monitoring"

    - skill: backend
      reason: "Implementing orchestration infrastructure"
      what_to_know:
        - "Async programming patterns"
        - "Error handling and retries"
        - "API design"

delegation_triggers:
  - trigger: "user asks about memory between agent sessions"
    delegate_to: agent-memory-systems
    context: "Long-term memory, Mem0, Zep, vector storage for agents"

  - trigger: "user needs to build tools for their agents"
    delegate_to: agent-tool-builder
    context: "Tool design, function schemas, error handling for agent tools"

  - trigger: "user wants to test their multi-agent system"
    delegate_to: agent-evaluation
    context: "Testing strategies, benchmarks, evaluation frameworks"

  - trigger: "user mentions n8n, Temporal, or workflow infrastructure"
    delegate_to: workflow-automation
    context: "Infrastructure for running agent workflows"

  - trigger: "user building voice-based agents"
    delegate_to: voice-agents
    context: "Vapi, Retell, telephony integration"

  - trigger: "user needs desktop automation with agents"
    delegate_to: computer-use-agents
    context: "Screen understanding, desktop control, Claude computer use"

receives_context_from:
  - skill: product-strategy
    receives:
      - "Product requirements driving need for multiple agents"
      - "User workflows that span multiple domains"
      - "Performance and reliability requirements"

  - skill: llm-architect
    receives:
      - "Model recommendations for different agent roles"
      - "Token budget constraints"
      - "Latency requirements per agent"

  - skill: system-designer
    receives:
      - "Overall system architecture"
      - "Integration points with existing services"
      - "Deployment environment constraints"

provides_context_to:
  - skill: agent-memory-systems
    provides:
      - "What state needs to persist between agent interactions"
      - "Coordination state that must be shared"
      - "Session vs long-term memory requirements"

  - skill: agent-evaluation
    provides:
      - "Multi-agent workflows to test"
      - "Expected behaviors at handoff points"
      - "Coordination scenarios to validate"

  - skill: workflow-automation
    provides:
      - "Orchestration patterns to implement"
      - "State machine definitions"
      - "Trigger conditions for agent activation"

escalation_paths:
  - situation: "Performance issues with agent coordination"
    escalate_to: performance-thinker
    context: "Profiling agent latency, optimizing coordination overhead"

  - situation: "Security concerns with multi-agent access"
    escalate_to: security-specialist
    context: "Agent permissions, data access, prompt injection risks"

  - situation: "Cost optimization needed for token usage"
    escalate_to: llm-architect
    context: "Model selection, context compression, caching strategies"

workflow_integration:
  typical_sequence:
    1:
      step: "Understand the problem"
      skills: [product-strategy]
      output: "Clear requirements for why multi-agent is needed"

    2:
      step: "Design agent architecture"
      skills: [multi-agent-orchestration, llm-architect]
      output: "Agent roles, routing patterns, coordination strategy"

    3:
      step: "Build individual agents"
      skills: [agent-tool-builder]
      output: "Working agents with tools and capabilities"

    4:
      step: "Implement orchestration"
      skills: [multi-agent-orchestration, backend]
      output: "Working multi-agent system"

    5:
      step: "Add memory layer"
      skills: [agent-memory-systems]
      output: "Persistent state and context management"

    6:
      step: "Test and evaluate"
      skills: [agent-evaluation]
      output: "Validated multi-agent behavior"

  decision_points:
    - question: "Single agent vs multi-agent?"
      guidance: |
        Start with single agent. Only add agents when:
        - Single agent demonstrably fails
        - Clear specialization boundary exists
        - Coordination overhead is justified

    - question: "Which orchestration pattern?"
      guidance: |
        - Sequential: Clear linear dependencies
        - Supervisor: Strict governance needed
        - Handoff: Dynamic expertise routing
        - Group Chat: Creative collaboration
        - Concurrent: Independent parallel work

    - question: "Which framework?"
      guidance: |
        - LangGraph: Production-grade, precise control
        - CrewAI: Rapid prototyping, role-based
        - AutoGen: Conversation-heavy, async
        - No framework: Simple patterns, full control

collaboration_patterns:
  with_frontend:
    when: "Building user-facing multi-agent interface"
    approach: |
      - Stream intermediate agent responses
      - Show agent handoff status to users
      - Allow user intervention in long workflows
      - Handle timeout gracefully in UI

  with_devops:
    when: "Deploying multi-agent system"
    approach: |
      - Separate agent scaling from orchestration
      - Independent health checks per agent
      - Distributed tracing across agents
      - Cost monitoring per agent

  with_security:
    when: "Securing multi-agent system"
    approach: |
      - Input validation at every agent boundary
      - Output filtering for sensitive data
      - Agent-specific permission scopes
      - Audit trail for all agent actions
