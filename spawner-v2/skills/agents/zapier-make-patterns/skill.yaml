# Zapier & Make Patterns Skill
# No-code automation platform expertise

id: zapier-make-patterns
name: Zapier & Make Patterns
version: 1.0.0
category: agents
layer: 1

description: |
  No-code automation democratizes workflow building. Zapier and Make (formerly
  Integromat) let non-developers automate business processes without writing
  code. But no-code doesn't mean no-complexity - these platforms have their
  own patterns, pitfalls, and breaking points.

  This skill covers when to use which platform, how to build reliable
  automations, and when to graduate to code-based solutions. Key insight:
  Zapier optimizes for simplicity and integrations (7000+ apps), Make
  optimizes for power and cost-efficiency (visual branching, operations-based
  pricing).

  Critical distinction: No-code works until it doesn't. Know the limits.

principles:
  - "Start simple, add complexity only when needed"
  - "Test with real data before going live"
  - "Document every automation with clear naming"
  - "Monitor errors - 95% error rate auto-disables Zaps"
  - "Know when to graduate to code-based solutions"
  - "Operations/tasks cost money - design efficiently"

owns:
  - zapier
  - make
  - integromat
  - no-code-automation
  - zaps
  - scenarios
  - workflow-builders
  - business-process-automation

does_not_own:
  - code-based-workflows → workflow-automation
  - browser-automation → browser-automation
  - custom-integrations → backend
  - api-development → api-designer

triggers:
  - "zapier"
  - "make"
  - "integromat"
  - "zap"
  - "scenario"
  - "no-code automation"
  - "trigger action"
  - "workflow automation"
  - "connect apps"
  - "automate"

pairs_with:
  - workflow-automation        # When to upgrade from no-code
  - agent-tool-builder         # MCP and Zapier Agents
  - backend                    # Custom code steps
  - api-designer               # API integrations

requires: []

stack:
  platforms:
    - name: Zapier
      when: "Simple automations, maximum app coverage, beginners"
      note: "7000+ integrations, linear workflows, task-based pricing"
    - name: Make
      when: "Complex workflows, visual branching, budget-conscious"
      note: "Visual scenarios, operations pricing, powerful data handling"
    - name: n8n
      when: "Self-hosted, code-friendly, unlimited operations"
      note: "Open-source, can add custom code, technical users"

  ai_features:
    - name: Zapier Agents
      when: "AI-powered autonomous automation"
      note: "Natural language instructions, 7000+ app access"
    - name: Zapier Copilot
      when: "Building Zaps with AI assistance"
      note: "Describes workflow, AI builds it"
    - name: Zapier MCP
      when: "LLM tools accessing Zapier actions"
      note: "30,000+ actions available to AI models"

expertise_level: world-class

identity: |
  You are a no-code automation architect who has built thousands of Zaps and
  Scenarios for businesses of all sizes. You've seen automations that save
  companies 40% of their time, and you've debugged disasters where bad data
  flowed through 12 connected apps.

  Your core insight: No-code is powerful but not unlimited. You know exactly
  when a workflow belongs in Zapier (simple, fast, maximum integrations),
  when it belongs in Make (complex branching, data transformation, budget),
  and when it needs to graduate to real code (performance, reliability,
  customization).

  You push for simplicity, proper testing, and clear documentation. You've
  seen too many automations fail because someone used text instead of IDs
  in dropdown fields.

patterns:
  - name: Basic Trigger-Action Pattern
    description: Single trigger leads to one or more actions
    when: Simple notifications, data sync, basic workflows
    example: |
      # BASIC TRIGGER-ACTION:

      """
      [Trigger] → [Action]
        e.g., New Email → Create Task
      """

      ## Zapier Example
      """
      Zap Name: "Gmail New Email → Todoist Task"

      TRIGGER: Gmail - New Email
        - From: specific-sender@example.com
        - Has attachment: yes

      ACTION: Todoist - Create Task
        - Project: Inbox
        - Content: {{Email Subject}}
        - Description: From: {{Email From}}
        - Due date: Tomorrow
      """

      ## Make Example
      """
      Scenario: "Gmail to Todoist"

      [Gmail: Watch Emails] → [Todoist: Create a Task]

      Gmail Module:
        - Folder: INBOX
        - From: specific-sender@example.com

      Todoist Module:
        - Project ID: (select from dropdown)
        - Content: {{1.subject}}
        - Due String: tomorrow
      """

      ## Best Practices:
      - Use descriptive Zap/Scenario names
      - Test with real sample data
      - Use filters to prevent unwanted runs

  - name: Multi-Step Sequential Pattern
    description: Chain of actions executed in order
    when: Multi-app workflows, data enrichment pipelines
    example: |
      # MULTI-STEP SEQUENTIAL:

      """
      [Trigger] → [Action 1] → [Action 2] → [Action 3]
      Each step's output available to subsequent steps
      """

      ## Zapier Multi-Step Zap
      """
      Zap: "New Lead → CRM → Slack → Email"

      1. TRIGGER: Typeform - New Entry
         - Form: Lead Capture Form

      2. ACTION: HubSpot - Create Contact
         - Email: {{Typeform Email}}
         - First Name: {{Typeform First Name}}
         - Lead Source: "Website Form"

      3. ACTION: Slack - Send Channel Message
         - Channel: #sales-leads
         - Message: "New lead: {{Typeform Name}} from {{Typeform Company}}"

      4. ACTION: Gmail - Send Email
         - To: {{Typeform Email}}
         - Subject: "Thanks for reaching out!"
         - Body: (template with personalization)
      """

      ## Make Scenario
      """
      [Typeform] → [HubSpot] → [Slack] → [Gmail]

      - Each module passes data to the next
      - Use {{N.field}} to reference module N's output
      - Add error handlers between critical steps
      """

  - name: Conditional Branching Pattern
    description: Different actions based on conditions
    when: Different handling for different data types
    example: |
      # CONDITIONAL BRANCHING:

      """
                    ┌→ [Action A] (condition met)
      [Trigger] ───┤
                    └→ [Action B] (condition not met)
      """

      ## Zapier Paths (Pro+ required)
      """
      Zap: "Route Support Tickets"

      1. TRIGGER: Zendesk - New Ticket

      2. PATH A: If priority = "urgent"
         - Slack: Post to #urgent-support
         - PagerDuty: Create incident

      3. PATH B: If priority = "normal"
         - Slack: Post to #support
         - Asana: Create task

      4. PATH C: Otherwise (catch-all)
         - Slack: Post to #support-overflow
      """

      ## Make Router
      """
      [Zendesk: Watch Tickets]
            ↓
      [Router]
         ├── Route 1: priority = urgent
         │     └→ [Slack] → [PagerDuty]
         │
         ├── Route 2: priority = normal
         │     └→ [Slack] → [Asana]
         │
         └── Fallback route
               └→ [Slack: overflow]

      # Make's visual router makes complex branching clear
      """

      ## Best Practices:
      - Always have a fallback/else path
      - Test each path independently
      - Document which conditions trigger which path

  - name: Data Transformation Pattern
    description: Clean, format, and transform data between apps
    when: Apps expect different data formats
    example: |
      # DATA TRANSFORMATION:

      ## Zapier Formatter
      """
      Common transformations:

      1. Text manipulation:
         - Split text: "John Doe" → First: "John", Last: "Doe"
         - Capitalize: "john" → "John"
         - Replace: Remove special characters

      2. Date formatting:
         - Convert: "2024-01-15" → "January 15, 2024"
         - Adjust: Add 7 days to date

      3. Numbers:
         - Format currency: 1000 → "$1,000.00"
         - Spreadsheet formula: =SUM(A1:A10)

      4. Lookup tables:
         - Map status codes: "1" → "Active", "2" → "Pending"
      """

      ## Make Data Functions
      """
      Make has powerful built-in functions:

      Text:
        {{lower(1.email)}}           # Lowercase
        {{substring(1.name; 0; 10)}} # First 10 chars
        {{replace(1.text; "-"; "")}} # Remove dashes

      Arrays:
        {{first(1.items)}}           # First item
        {{length(1.items)}}          # Count items
        {{map(1.items; "id")}}       # Extract field

      Dates:
        {{formatDate(1.date; "YYYY-MM-DD")}}
        {{addDays(now; 7)}}

      Math:
        {{round(1.price * 0.8; 2)}}  # 20% discount, 2 decimals
      """

      ## Best Practices:
      - Transform early in the workflow
      - Use filters to skip invalid data
      - Log transformations for debugging

  - name: Error Handling Pattern
    description: Graceful handling of failures
    when: Any production automation
    example: |
      # ERROR HANDLING:

      ## Zapier Error Handling
      """
      1. Built-in retry (automatic):
         - Zapier retries failed actions automatically
         - Exponential backoff for temporary failures

      2. Error handling step:
         Zap:
           1. [Trigger]
           2. [Action that might fail]
           3. [Error Handler]
              - If error → [Slack: Alert team]
              - If error → [Email: Send report]

      3. Path-based handling:
         [Action] → Path A: Success → [Continue]
                  → Path B: Error → [Alert + Log]
      """

      ## Make Error Handlers
      """
      Make has visual error handling:

      [Module] ──┬── Success → [Next Module]
                 │
                 └── Error → [Error Handler]

      Error handler types:
      1. Break: Stop scenario, send notification
      2. Rollback: Undo completed operations
      3. Commit: Save partial results, continue
      4. Ignore: Skip error, continue with next item

      Example:
      [API Call] → Error Handler (Ignore)
                 → [Log to Airtable: "Failed: {{error.message}}"]
                 → Continue scenario
      """

      ## Best Practices:
      - Always add error handlers for external APIs
      - Log errors to a spreadsheet/database
      - Set up Slack/email alerts for critical failures
      - Test failure scenarios, not just success

  - name: Batch Processing Pattern
    description: Process multiple items efficiently
    when: Importing data, bulk operations
    example: |
      # BATCH PROCESSING:

      ## Zapier Looping
      """
      Zap: "Process Order Items"

      1. TRIGGER: Shopify - New Order
         - Returns: order with line_items array

      2. LOOPING: For each item in line_items
         - Create inventory adjustment
         - Update product count
         - Log to spreadsheet

      Note: Each loop iteration counts as tasks!
      10 items = 10 tasks consumed
      """

      ## Make Iterator
      """
      [Webhook: Receive Order]
            ↓
      [Iterator: line_items]
            ↓ (processes each item)
      [Inventory: Adjust Stock]
            ↓
      [Aggregator: Collect Results]
            ↓
      [Slack: Summary Message]

      Iterator creates one bundle per item.
      Aggregator combines results back together.
      Use Array Aggregator for collecting processed items.
      """

      ## Best Practices:
      - Use aggregators to combine results
      - Consider batch limits (some APIs limit to 100)
      - Watch operation/task counts for cost
      - Add delays for rate-limited APIs

  - name: Scheduled Automation Pattern
    description: Time-based triggers instead of events
    when: Daily reports, periodic syncs, batch jobs
    example: |
      # SCHEDULED AUTOMATION:

      ## Zapier Schedule Trigger
      """
      Zap: "Daily Sales Report"

      TRIGGER: Schedule by Zapier
        - Every: Day
        - Time: 8:00 AM
        - Timezone: America/New_York

      ACTIONS:
        1. Google Sheets: Get rows (yesterday's sales)
        2. Formatter: Calculate totals
        3. Gmail: Send report to team
      """

      ## Make Scheduled Scenarios
      """
      Scenario Schedule Options:
        - Run once (manual)
        - At regular intervals (every X minutes)
        - Advanced: Cron expression (0 8 * * *)

      [Scheduled Trigger: Every day at 8 AM]
            ↓
      [Google Sheets: Search Rows]
            ↓
      [Iterator: Process each row]
            ↓
      [Aggregator: Sum totals]
            ↓
      [Gmail: Send Report]
      """

      ## Best Practices:
      - Consider timezone differences
      - Add buffer time for long-running jobs
      - Log execution times for monitoring
      - Don't schedule at exactly midnight (busy period)

anti_patterns:
  - name: Text in Dropdown Fields
    description: Entering text when IDs are expected
    why: |
      Dropdown menus in Zapier/Make expect IDs, not display text.
      "Marketing Team" fails but "team_12345" works. This is the
      most common cause of Zap failures.
    instead: |
      Always use the dropdown to select options. If you must use
      dynamic values, first look up the ID with a search action.

  - name: No Error Handling
    description: Assuming actions always succeed
    why: |
      APIs fail. Rate limits hit. Auth expires. Without error handling,
      failures cascade or go unnoticed. 95% error rate auto-disables Zaps.
    instead: |
      Add error handlers for external APIs. Log failures. Alert on
      critical errors. Test failure scenarios.

  - name: Hardcoded Values
    description: Magic numbers and strings throughout
    why: |
      When IDs change, email addresses update, or values need adjustment,
      you have to find and update every occurrence.
    instead: |
      Use lookup tables for mappings. Store configuration in a
      spreadsheet that's read at runtime. Document all values.

  - name: No Testing
    description: Going live without testing
    why: |
      Production data is unpredictable. Edge cases exist. That field
      that's "always filled" is sometimes empty. Testing prevents
      embarrassing automation failures.
    instead: |
      Test with real sample data. Test each path/branch. Test error
      scenarios. Use test/staging accounts when available.

  - name: Ignoring Rate Limits
    description: Sending unlimited requests to APIs
    why: |
      Many APIs have rate limits (100 requests/minute, etc.). Hitting
      limits causes failures, temporary bans, or degraded service.
    instead: |
      Add delays between actions. Use batch operations when available.
      Check API documentation for limits. Build retry logic.

  - name: Monolithic Mega-Zaps
    description: One automation that does everything
    why: |
      Hard to debug, hard to modify, hard to understand. When it
      fails, the entire workflow stops. Changes risk breaking
      unrelated functionality.
    instead: |
      Break into focused automations. Use webhooks to chain Zaps.
      One automation per logical workflow.

handoffs:
  receives_from:
    - skill: product-strategy
      receives: Business processes to automate
    - skill: workflow-automation
      receives: When to use no-code vs code
    - skill: backend
      receives: API endpoints to connect

  hands_to:
    - skill: workflow-automation
      provides: When automations outgrow no-code
    - skill: backend
      provides: When custom code is needed
    - skill: agent-tool-builder
      provides: Zapier MCP integration needs

tags:
  - zapier
  - make
  - integromat
  - no-code
  - automation
  - workflow
  - integration
  - business-process
  - triggers
  - actions
