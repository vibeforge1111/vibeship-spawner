id: docker-containerization-collaboration
skill: docker-containerization
version: 1.0.0

# ============================================================================
# RECEIVES FROM (Who delegates TO this skill)
# ============================================================================
receives_from:
  - skill: backend
    context: "Backend application needs containerization"
    receives:
      - "Application source code"
      - "Runtime requirements (Node, Python, Go, etc.)"
      - "Port configuration"
      - "Environment variables needed"
    provides: "Production-ready Dockerfile and image"

  - skill: frontend
    context: "Frontend needs container for serving static assets"
    receives:
      - "Build output requirements"
      - "Static file serving needs"
      - "Environment variable injection strategy"
    provides: "Multi-stage Dockerfile with build and serve stages"

  - skill: devops
    context: "DevOps needs containerized application"
    receives:
      - "Application type and dependencies"
      - "Build requirements"
      - "Security constraints"
    provides: "Optimized Dockerfile with caching strategy"

  - skill: infrastructure-as-code
    context: "IaC provisioned registry, needs container image"
    receives:
      - "Registry endpoint"
      - "Authentication method"
      - "Tagging strategy"
    provides: "Container image with proper tagging"

# ============================================================================
# DELEGATION TRIGGERS
# ============================================================================
delegation_triggers:
  - trigger: "kubernetes|k8s|helm|pod|deployment"
    delegate_to: kubernetes-deployment
    pattern: sequential
    context: "Container image ready, needs orchestration"
    handoff_data:
      - "Container image and tag"
      - "Port exposure"
      - "Health check endpoint"
      - "Resource requirements"
    receive: "Kubernetes manifests for deployment"

  - trigger: "ci/cd|pipeline|github actions|gitlab ci|build automation"
    delegate_to: devops
    pattern: parallel
    context: "Need automated build and push pipeline"
    handoff_data:
      - "Dockerfile location"
      - "Build arguments"
      - "Registry destination"
      - "Caching strategy"
    receive: "CI/CD pipeline configuration"

  - trigger: "security scan|trivy|vulnerability|cve"
    delegate_to: cybersecurity
    pattern: parallel
    context: "Container image needs security scanning"
    handoff_data:
      - "Image name and tag"
      - "Base image used"
      - "Installed packages"
    receive: "Security scan results and remediation steps"

  - trigger: "registry|ecr|gcr|acr|docker hub"
    delegate_to: infrastructure-as-code
    pattern: sequential
    context: "Need container registry setup"
    handoff_data:
      - "Cloud provider"
      - "Access requirements"
      - "Lifecycle policies"
    receive: "Registry endpoint and credentials"

  - trigger: "docker-compose|compose|local development"
    delegate_to: devops
    pattern: parallel
    context: "Need local development environment"
    handoff_data:
      - "Services needed"
      - "Dependencies (database, cache, etc.)"
      - "Volume mounts"
    receive: "docker-compose.yaml configuration"

# ============================================================================
# FEEDBACK LOOPS
# ============================================================================
feedback_loops:
  receives_feedback_from:
    - skill: kubernetes-deployment
      signal: "Container won't start, crashes, or fails health checks"
      action: "Fix Dockerfile - entrypoint, health checks, signal handling"

    - skill: cybersecurity
      signal: "CVEs found in base image or packages"
      action: "Update base image, remove unnecessary packages, use distroless"

    - skill: devops
      signal: "Build pipeline failures or slow builds"
      action: "Optimize layer caching, fix build dependencies"

    - skill: observability-sre
      signal: "Container performance issues or resource constraints"
      action: "Adjust resource settings, optimize image startup time"

  sends_feedback_to:
    - skill: backend
      signal: "Application not compatible with containerization"
      action: "Update application for container patterns (12-factor)"

    - skill: devops
      signal: "Image requires specific build environment"
      action: "Update CI/CD with required build tools"

    - skill: kubernetes-deployment
      signal: "New image version with different requirements"
      action: "Update Kubernetes manifests for new image"

# ============================================================================
# CROSS-DOMAIN INSIGHTS
# ============================================================================
cross_domain_insights:
  - domain: Site Reliability Engineering
    insight: |
      SREs understand container runtime behavior:
      - Container startup time matters for autoscaling
      - Image size affects pull time and cold start latency
      - Health checks must be fast and accurate
      - Signal handling determines graceful shutdown success
      Container images are SLO-impacting artifacts.
    applies_when: "Optimizing for production reliability"

  - domain: Security Engineering
    insight: |
      Security engineers see containers as attack surface:
      - Every package is a potential CVE
      - Running as root expands blast radius
      - Secrets baked in layers are exposed secrets
      - Base images need continuous updates
      Containers are perimeters, not prisons.
    applies_when: "Hardening container security"

  - domain: Platform Engineering
    insight: |
      Platform engineers care about developer experience:
      - Build times affect velocity
      - Local dev should mirror production
      - Debugging containers shouldn't require shell access
      - Standardized base images reduce cognitive load
      Good containers enable good platforms.
    applies_when: "Building internal container standards"

  - domain: FinOps
    insight: |
      FinOps practitioners see container costs:
      - Large images mean expensive storage and transfer
      - Slow pulls mean over-provisioned nodes for fast scaling
      - Many layers mean expensive registry storage
      - Build minutes are CI/CD costs
      Image optimization is cost optimization.
    applies_when: "Optimizing container-related costs"

# ============================================================================
# COMMON COMBINATIONS
# ============================================================================
common_combinations:
  - name: Full Application Stack
    skills:
      - backend
      - docker-containerization
      - kubernetes-deployment
    workflow: |
      1. Build application (backend)
      2. Containerize with multi-stage Dockerfile (docker-containerization)
      3. Deploy to Kubernetes (kubernetes-deployment)
      4. Iterate on resource tuning

  - name: Secure Container Pipeline
    skills:
      - docker-containerization
      - cybersecurity
      - devops
    workflow: |
      1. Build minimal container image (docker-containerization)
      2. Security scan and hardening (cybersecurity)
      3. Automated build pipeline (devops)
      4. Continuous scanning in pipeline

  - name: Multi-Environment Containers
    skills:
      - docker-containerization
      - infrastructure-as-code
      - devops
    workflow: |
      1. Create environment-agnostic Dockerfile (docker-containerization)
      2. Set up registries per environment (infrastructure-as-code)
      3. Build and promote through environments (devops)

  - name: Local Development Setup
    skills:
      - docker-containerization
      - backend
      - devops
    workflow: |
      1. Create Dockerfile for production parity (docker-containerization)
      2. Create docker-compose for local stack (devops)
      3. Document local development workflow (backend)

# ============================================================================
# ECOSYSTEM
# ============================================================================
ecosystem:
  primary_tools:
    - "Docker - Container runtime and build tool"
    - "BuildKit - Advanced Docker build features"
    - "docker-compose - Multi-container local development"
    - "Podman - Daemonless container engine (Docker alternative)"
    - "Trivy - Container vulnerability scanning"
    - "dive - Image layer analysis and optimization"

  base_images:
    - name: Alpine
      size: "~5MB"
      use_when: "Need small images, shell access for debugging"
      avoid_when: "C library compatibility issues (musl vs glibc)"

    - name: Distroless
      size: "~20MB"
      use_when: "Maximum security, no shell needed, Go/Java/Python/Node"
      avoid_when: "Need interactive debugging, shell access"

    - name: Scratch
      size: "0 bytes"
      use_when: "Statically compiled Go/Rust binaries"
      avoid_when: "Need any runtime dependencies or dynamic linking"

    - name: Slim variants
      size: "~100-200MB"
      use_when: "Need glibc compatibility, apt packages"
      avoid_when: "Size is critical concern"

    - name: Chainguard
      size: "Varies"
      use_when: "Security-focused, regularly updated, SBOM included"
      avoid_when: "Budget constraints, unfamiliar with image"

  alternatives:
    - name: Podman
      use_when: "Rootless containers, no daemon, Docker compatibility"
      avoid_when: "Team Docker expertise, complex Docker features"

    - name: Buildah
      use_when: "Scripted image builds, no daemon needed"
      avoid_when: "Standard Dockerfile workflow preferred"

    - name: Kaniko
      use_when: "Build in Kubernetes, no Docker daemon in CI"
      avoid_when: "Local development, simple CI setups"

    - name: ko
      use_when: "Go applications, no Dockerfile needed"
      avoid_when: "Non-Go applications, custom build requirements"

    - name: Jib
      use_when: "Java applications, Maven/Gradle integration"
      avoid_when: "Non-Java applications, need custom build steps"

  registries:
    - name: Docker Hub
      use_when: "Public images, open source projects"
      considerations: "Rate limits, public by default"

    - name: Amazon ECR
      use_when: "AWS ecosystem, EKS/ECS deployments"
      considerations: "Per-region, lifecycle policies, cross-account"

    - name: Google GCR/Artifact Registry
      use_when: "GCP ecosystem, GKE deployments"
      considerations: "Artifact Registry is newer, multi-format"

    - name: Azure ACR
      use_when: "Azure ecosystem, AKS deployments"
      considerations: "Geo-replication, Tasks for building"

    - name: GitHub Container Registry
      use_when: "GitHub ecosystem, open source"
      considerations: "Package visibility tied to repo"

