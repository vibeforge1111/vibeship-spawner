id: execution-algorithms
skill: Execution Algorithms
version: "1.0"

receives_context_from:
  - skill: quantitative-research
    receives:
      - Strategy signals with timing
      - Turnover estimates
      - Capacity constraints
    provides:
      - Realized slippage data
      - Fill rate statistics
      - Market impact observations

  - skill: risk-management-trading
    receives:
      - Position sizing rules
      - Urgency parameters
      - Risk limits
    provides:
      - Execution quality metrics
      - Slippage-adjusted costs
      - Fill confirmation

  - skill: technical-analysis
    receives:
      - Entry/exit levels
      - Support/resistance zones
      - Volatility context
    provides:
      - Optimal entry timing
      - Level-aware execution
      - Slippage at levels

  - skill: sentiment-analysis-trading
    receives:
      - News flow status
      - Volatility expectations
      - Urgency signals
    provides:
      - Execution timing recommendations
      - Risk period avoidance
      - News-aware scheduling

delegation_triggers:
  - pattern: "alpha|signal|strategy|backtest"
    delegate_to: quantitative-research
    context: "Provide execution data for research"

  - pattern: "risk|position.*size|drawdown"
    delegate_to: risk-management-trading
    context: "Execution complete, apply risk management"

  - pattern: "level|support|resistance|entry"
    delegate_to: technical-analysis
    context: "Need technical levels for execution"

  - pattern: "news|sentiment|urgency"
    delegate_to: sentiment-analysis-trading
    context: "Assess market conditions for timing"

common_combinations:
  - name: Production Execution Pipeline
    skills:
      - quantitative-research
      - risk-management-trading
      - execution-algorithms
    workflow: |
      1. Generate signals (quantitative-research)
      2. Size positions (risk-management-trading)
      3. Execute optimally (execution-algorithms)

  - name: Level-Aware Execution
    skills:
      - technical-analysis
      - execution-algorithms
      - risk-management-trading
    workflow: |
      1. Identify entry levels (technical-analysis)
      2. Execute at levels (execution-algorithms)
      3. Set stops based on fills (risk-management-trading)

  - name: News-Sensitive Execution
    skills:
      - sentiment-analysis-trading
      - execution-algorithms
      - risk-management-trading
    workflow: |
      1. Monitor news flow (sentiment-analysis-trading)
      2. Adjust execution timing (execution-algorithms)
      3. Manage event risk (risk-management-trading)

cross_domain_insights:
  - domain: Queueing Theory
    insight: Arrival and service rates determine wait times
    application: Model fill probability and queue position dynamics

  - domain: Game Theory
    insight: Adversarial environment with information asymmetry
    application: Assume counterparties are trying to exploit your patterns

  - domain: Control Theory
    insight: Feedback loops and stability
    application: Adaptive execution that responds to market conditions

  - domain: Operations Research
    insight: Optimization under constraints
    application: Minimize cost subject to time and participation constraints

  - domain: Signal Processing
    insight: Noise filtering and signal detection
    application: Distinguish genuine price moves from microstructure noise

ecosystem_alternatives:
  execution_platforms:
    - name: Alpaca
      when: US equities, simple API, commission-free
      tradeoff: Limited to US markets
    - name: Interactive Brokers
      when: Multi-asset, global, professional
      tradeoff: Complex API, minimum requirements
    - name: FIX Protocol
      when: Institutional, multi-broker
      tradeoff: Complex implementation

  algo_frameworks:
    - name: Zipline
      when: Backtesting, educational
      tradeoff: Limited live trading
    - name: QuantConnect
      when: Cloud-based, multi-asset
      tradeoff: Vendor lock-in
    - name: Custom
      when: Full control, specific needs
      tradeoff: Build everything yourself

  data_sources:
    - name: Polygon
      when: US equities, reasonable cost
      tradeoff: Limited international
    - name: IEX Cloud
      when: Free tier available, simple
      tradeoff: Delayed data on free
    - name: Bloomberg
      when: Institutional, complete
      tradeoff: Very expensive

feedback_loops:
  - from: quantitative-research
    incorporates:
      - Backtest assumptions to update
      - Strategy turnover patterns
      - Expected vs realized fills
    into: Slippage model calibration

  - from: risk-management-trading
    incorporates:
      - Position sizing outcomes
      - Urgency parameters
      - Risk event timing
    into: Execution scheduling

  - from: technical-analysis
    incorporates:
      - Level reaction analysis
      - Volatility patterns
      - Support/resistance accuracy
    into: Level-aware execution timing

prerequisites:
  required_knowledge:
    - Market microstructure basics
    - Order types (market, limit, stop)
    - Exchange/venue concepts
    - Basic programming (Python preferred)

  recommended_tools:
    - Python with pandas, numpy
    - Broker API (Alpaca, IB, etc.)
    - Order management system
    - Execution analytics dashboard

  environment_setup: |
    # Python execution framework setup
    pip install pandas numpy scipy
    pip install alpaca-trade-api  # or ibapi for IB
    pip install websocket-client  # for real-time data

    # Basic execution structure
    from dataclasses import dataclass
    from typing import Optional
    import pandas as pd

    @dataclass
    class Order:
        symbol: str
        side: str
        quantity: int
        order_type: str = 'market'
        limit_price: Optional[float] = None

    @dataclass
    class Fill:
        order_id: str
        fill_price: float
        fill_quantity: int
        timestamp: pd.Timestamp

    class ExecutionTracker:
        def __init__(self):
            self.orders = []
            self.fills = []

        def submit_order(self, order: Order) -> str:
            # Submit to broker
            order_id = f"order_{len(self.orders)}"
            self.orders.append((order_id, order))
            return order_id

        def record_fill(self, fill: Fill):
            self.fills.append(fill)

        def calculate_vwap(self) -> float:
            total_value = sum(f.fill_price * f.fill_quantity for f in self.fills)
            total_qty = sum(f.fill_quantity for f in self.fills)
            return total_value / total_qty if total_qty > 0 else 0

        def calculate_slippage(self, arrival_price: float, side: str) -> float:
            vwap = self.calculate_vwap()
            if side == 'buy':
                return (vwap / arrival_price - 1) * 10000  # bps
            else:
                return (arrival_price / vwap - 1) * 10000  # bps
