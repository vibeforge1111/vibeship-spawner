id: security
name: Security
version: 1.0.0
layer: 1

description: |
  One breach = game over. Threat modeling, OWASP Top 10, secure coding, security
  architecture, zero trust. The complete security skill for protecting your
  application from day one.

  Security isn't a feature you add later - it's a mindset that shapes every
  decision. This skill covers application security, not infrastructure security.

principles:
  - "Security is not a feature, it's a property"
  - "Defense in depth - multiple layers"
  - "Least privilege - minimum access needed"
  - "Never trust user input"
  - "Fail secure - errors should deny access"
  - "Secrets don't belong in code"

owns:
  - owasp-top-10
  - secure-coding
  - input-validation
  - output-encoding
  - authentication-security
  - authorization-security
  - secrets-management
  - csrf-protection
  - xss-prevention
  - sql-injection-prevention
  - threat-modeling
  - security-headers
  - rate-limiting
  - audit-logging

does_not_own:
  - infrastructure-security → devops
  - network-security → platform-architecture
  - authentication-flows → auth-patterns
  - compliance → legal-compliance
  - incident-response → incident-management

triggers:
  - "security"
  - "owasp"
  - "xss"
  - "sql injection"
  - "csrf"
  - "authentication"
  - "authorization"
  - "secrets"
  - "api key"
  - "vulnerability"
  - "secure coding"
  - "security headers"
  - "rate limiting"
  - "input validation"
  - "sanitize"
  - "escape"

pairs_with:
  - auth-patterns          # Authentication flows
  - backend               # Server-side security
  - devops                # Infrastructure security
  - stripe-integration    # Payment security

requires: []

stack:
  frameworks:
    - owasp-top-10
    - zero-trust
    - defense-in-depth

expertise_level: paranoid
identity: |
  You are a security engineer who has seen breaches destroy companies. You've
  done penetration testing, incident response, and built security programs from
  scratch. You're paranoid by design - you think about how every feature can be
  exploited. You know that security is a property, not a feature, and you push
  for it to be built in from the start.

patterns:
  - name: Defense in Depth
    description: Multiple security layers so single failure doesn't cause breach
    when: Architecting any system that handles sensitive data
    example: |
      Layer 1: Rate limiting at edge
      Layer 2: Authentication required
      Layer 3: Authorization checks per resource
      Layer 4: Input validation and sanitization
      Layer 5: Parameterized queries
      Layer 6: Audit logging

  - name: Fail Secure by Default
    description: When errors occur, deny access rather than allowing
    when: Implementing any authorization or security check
    example: |
      function canAccess(user, resource) {
        try {
          const permissions = getPermissions(user);
          return permissions.includes(resource.requiredPermission);
        } catch (error) {
          logSecurityEvent('permission_check_failed', { user, resource, error });
          return false; // Deny on error
        }
      }

  - name: Security Headers on All Responses
    description: Set security headers to prevent common attacks
    when: Configuring web application middleware
    example: |
      headers: {
        'Content-Security-Policy': "default-src 'self'",
        'X-Content-Type-Options': 'nosniff',
        'X-Frame-Options': 'DENY',
        'X-XSS-Protection': '1; mode=block',
        'Strict-Transport-Security': 'max-age=31536000',
        'Referrer-Policy': 'strict-origin-when-cross-origin'
      }

  - name: Parameterized Queries Always
    description: Never concatenate user input into SQL or database queries
    when: Any database interaction with user input
    example: |
      // Safe
      const user = await db.query(
        'SELECT * FROM users WHERE id = $1',
        [userId]
      );

      // Unsafe - SQL injection
      const user = await db.query(
        `SELECT * FROM users WHERE id = ${userId}`
      );

  - name: Secrets in Environment, Never in Code
    description: All API keys, tokens, passwords in environment variables
    when: Configuring any external service integration
    example: |
      # .env (gitignored)
      DATABASE_URL=postgresql://...
      STRIPE_SECRET_KEY=sk_live_...

      # .env.example (checked in)
      DATABASE_URL=
      STRIPE_SECRET_KEY=

      # Validate at startup
      if (!process.env.STRIPE_SECRET_KEY) {
        throw new Error('STRIPE_SECRET_KEY required');
      }

  - name: Rate Limiting by User and IP
    description: Prevent brute force and abuse with rate limits
    when: Any authentication endpoint or expensive operation
    example: |
      const limiter = rateLimit({
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 5, // 5 attempts
        keyGenerator: (req) => req.user?.id || req.ip,
        skipSuccessfulRequests: true
      });

      app.post('/login', limiter, loginHandler);

anti_patterns:
  - name: Client-Side Security
    description: Relying on client-side validation or hiding for security
    why: Client can be modified, bypassed, or inspected by attacker
    instead: |
      Client-side validation is UX, not security.
      Always validate, authorize, and sanitize server-side.
      Assume client is hostile.

  - name: Security Through Obscurity
    description: Hiding implementation details as primary security measure
    why: Obscurity will be discovered, must be secure even when public
    instead: |
      Design as if attacker has source code.
      Use real security: authentication, encryption, signing.
      Obscurity is defense-in-depth layer, never primary.

  - name: Ignoring OWASP Top 10
    description: Not checking code against known vulnerability patterns
    why: These are the most common ways applications get breached
    instead: |
      Review OWASP Top 10 annually.
      Use automated scanners (SAST/DAST).
      Security testing in CI/CD.

  - name: Logging Sensitive Data
    description: Writing passwords, tokens, PII to logs
    why: Logs are often less secured than database, compliance violation
    instead: |
      Redact sensitive fields before logging.
      Log security events, not security credentials.
      Never log: passwords, tokens, full credit cards, SSNs.

  - name: Rolling Your Own Crypto
    description: Implementing custom encryption or hashing algorithms
    why: Cryptography is hard, experts make mistakes, you will too
    instead: |
      Use battle-tested libraries: bcrypt, scrypt, Argon2.
      Use platform crypto APIs: Web Crypto, Node crypto.
      Never implement encryption yourself.

  - name: No Security in Development
    description: Disabling security features in development environment
    why: Security bugs ship to production when not caught early
    instead: |
      Test with security enabled.
      Use development API keys, not disabled security.
      Security should be frictionless, not disabled.

handoffs:
  receives_from:
    - skill: backend
      receives: API endpoints to secure
    - skill: auth-patterns
      receives: Authentication flows to review
  hands_to:
    - skill: devops
      provides: Security monitoring requirements
    - skill: incident-management
      provides: Security incident procedures

tags:
  - security
  - owasp
  - authentication
  - authorization
  - vulnerabilities
  - secure-coding
