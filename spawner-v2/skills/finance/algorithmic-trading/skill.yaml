id: algorithmic-trading
name: Algorithmic Trading
category: finance
description: Use when building trading systems, backtesting strategies, implementing execution algorithms, or analyzing market microstructure - covers strategy development, risk management, and production deployment

patterns:
  golden_rules:
    - rule: "Never optimize on all data"
      reason: "Out-of-sample testing prevents overfitting"
    - rule: "Include realistic costs"
      reason: "Slippage and commissions kill edge"
    - rule: "Use event-driven backtests"
      reason: "Time-based sampling creates look-ahead bias"
    - rule: "Version everything"
      reason: "Data, code, models, and parameters"
    - rule: "Paper trade before live"
      reason: "Exposes slippage and execution bugs"

  framework_8_step:
    steps:
      - "HYPOTHESIS - Define market inefficiency"
      - "DATA - Collect clean, adjusted data"
      - "SIGNAL - Generate trading signals"
      - "BACKTEST - Event-driven with realistic costs"
      - "OPTIMIZE - Walk-forward optimization"
      - "VALIDATE - Out-of-sample testing"
      - "DEPLOY - Paper trade first"
      - "MONITOR - Track performance, drift"

  inefficiency_types:
    microstructure: "Order flow imbalances, bid-ask dynamics"
    behavioral: "Overreaction, anchoring, herding"
    fundamental: "Earnings surprises, value anomalies"
    technical: "Momentum, mean reversion, breakouts"
    statistical: "Pairs trading, factor arbitrage"
    event: "Corporate actions, economic releases"

  execution_algorithms:
    twap: "Time-Weighted Average Price"
    vwap: "Volume-Weighted Average Price"
    is: "Implementation Shortfall"
    pov: "Percentage of Volume"

anti_patterns:
  - pattern: "Optimizing on full dataset"
    problem: "Massive overfitting"
    solution: "Walk-forward validation"
  - pattern: "Ignoring transaction costs"
    problem: "Strategy unprofitable live"
    solution: "Include realistic cost model"
  - pattern: "Single market testing"
    problem: "Regime-dependent strategy"
    solution: "Test across multiple periods"
  - pattern: "No position limits"
    problem: "Catastrophic losses"
    solution: "Max position and drawdown limits"
  - pattern: "Hardcoded parameters"
    problem: "Fails on regime change"
    solution: "Adaptive or robust parameters"
  - pattern: "Looking at P&L first"
    problem: "Curve fitting"
    solution: "Focus on process, not results"

implementation_checklist:
  strategy_development:
    - "Define clear hypothesis based on market inefficiency"
    - "Collect clean, adjusted data (splits, dividends)"
    - "Implement signal generation with proper lookback"
    - "Build event-driven backtest with realistic costs"
    - "Perform walk-forward optimization"
  risk_management:
    - "Calculate risk-adjusted metrics (Sharpe, Sortino, Calmar)"
    - "Implement position sizing based on risk"
    - "Set maximum drawdown limits"
    - "Define position concentration limits"
  deployment:
    - "Paper trade for minimum 2 weeks"
    - "Set up monitoring and alerting"
    - "Document strategy logic and parameters"
    - "Implement kill switch for emergencies"

handoffs:
  - skill: risk-modeling
    trigger: "VaR and risk metrics for portfolio"
  - skill: portfolio-optimization
    trigger: "asset allocation decisions"
  - skill: derivatives-pricing
    trigger: "options strategies and hedging"

ecosystem:
  backtesting:
    - "backtesting.py - Fast strategy backtesting"
    - "vectorbt - Vectorized backtesting"
    - "zipline - Event-driven backtesting"
  analysis:
    - "pyfolio - Performance analysis"
    - "quantstats - Trading statistics"
  brokers:
    - "alpaca-py - Alpaca API"
    - "ib_insync - Interactive Brokers"
    - "ccxt - Crypto exchanges"

sources:
  tutorials:
    - "PyQuant 8-Step Framework"
    - "Backtesting.py Documentation"
  books:
    - "Advances in Financial Machine Learning - Lopez de Prado"
