# Graphile Worker Collaboration Model
# How this skill works with other specialists

prerequisites:
  skills: []
  knowledge:
    - "PostgreSQL fundamentals (tables, transactions)"
    - "Node.js/TypeScript basics"
    - "Understanding of job queues and async processing"
    - "SQL triggers and functions basics"

complementary_skills:
  - skill: postgres-wizard
    relationship: "Database optimization"
    brings: "Query tuning, index optimization, vacuum management"

  - skill: supabase-backend
    relationship: "Supabase integration"
    brings: "Edge functions, RLS policies, realtime subscriptions"

  - skill: backend
    relationship: "Application integration"
    brings: "API design, service architecture, error handling"

  - skill: email-systems
    relationship: "Email job processing"
    brings: "Email templates, delivery optimization, bounce handling"

  - skill: drizzle-orm
    relationship: "ORM integration"
    brings: "Type-safe queries, migrations, schema management"

  - skill: graphql-architect
    relationship: "PostGraphile integration"
    brings: "GraphQL mutations that trigger jobs"

delegation:
  - trigger: "database performance issues"
    delegate_to: postgres-wizard
    pattern: parallel
    context: "Job table query patterns and vacuum settings"
    receive: "Optimized indexes and autovacuum configuration"

  - trigger: "redis queue needed"
    delegate_to: bullmq-specialist
    pattern: sequential
    context: "Current job patterns and volumes"
    receive: "Redis-backed queue implementation"

  - trigger: "serverless deployment"
    delegate_to: upstash-qstash
    pattern: sequential
    context: "Job types and scheduling needs"
    receive: "Serverless queue without workers"

  - trigger: "workflow orchestration"
    delegate_to: temporal-craftsman
    pattern: sequential
    context: "Complex saga patterns needed"
    receive: "Durable workflow implementation"

  - trigger: "simpler postgres queue"
    delegate_to: pg-boss
    pattern: sequential
    context: "Don't need trigger integration"
    receive: "Simpler pg-boss implementation"

collaboration_patterns:
  sequential:
    - "I set up Graphile Worker, then postgres-wizard optimizes the job tables"
    - "I create job handlers, then email-systems handles delivery logic"
    - "I queue jobs from triggers, then backend processes the results"

  parallel:
    - "I process jobs while drizzle-orm manages data layer"
    - "I handle async work while supabase-backend serves realtime"

  review:
    - "Review postgres-wizard's vacuum settings for job tables"
    - "Review backend's transaction patterns for job creation"

cross_domain_insights:
  - domain: message-queues
    insight: "LISTEN/NOTIFY is PostgreSQL's pub/sub - instant job pickup"
    applies_when: "Choosing between polling and push-based job pickup"

  - domain: transactions
    insight: "Jobs queued in same transaction = atomic consistency"
    applies_when: "Ensuring data and jobs are created together"

  - domain: triggers
    insight: "Database triggers can queue jobs - react to data changes"
    applies_when: "Building event-driven job systems"

ecosystem:
  primary_tools:
    - "graphile-worker CLI"
    - "postgraphile integration"
    - "pg client library"

  alternatives:
    - name: pg-boss
      use_when: "Simpler API without trigger integration"
      avoid_when: "Need millisecond job pickup via LISTEN/NOTIFY"

    - name: BullMQ
      use_when: "Already have Redis infrastructure"
      avoid_when: "Want to keep everything in PostgreSQL"

    - name: Temporal
      use_when: "Complex multi-step workflows with compensation"
      avoid_when: "Simple job processing is sufficient"

  deprecated:
    - "Polling instead of LISTEN/NOTIFY"
    - "Large payloads in job data instead of references"
    - "Missing transaction around data + job creation"
