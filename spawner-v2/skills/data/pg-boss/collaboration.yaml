# pg-boss Collaboration Model
# How this skill works with other specialists

prerequisites:
  skills: []
  knowledge:
    - "PostgreSQL basics (connections, queries)"
    - "Node.js/TypeScript async programming"
    - "Job queue concepts (workers, retries, dead letters)"
    - "Understanding of transactions"

complementary_skills:
  - skill: postgres-wizard
    relationship: "Database optimization"
    brings: "Query tuning, connection pooling, vacuum management"

  - skill: supabase-backend
    relationship: "Supabase integration"
    brings: "Edge functions, connection pooler settings, RLS"

  - skill: backend
    relationship: "Application architecture"
    brings: "Service design, error handling, API patterns"

  - skill: nextjs-app-router
    relationship: "Next.js integration"
    brings: "API routes, server actions, background processing"

  - skill: email-systems
    relationship: "Email job processing"
    brings: "Template rendering, delivery tracking, bounce handling"

  - skill: drizzle-orm
    relationship: "ORM integration"
    brings: "Type-safe database access, migrations"

delegation:
  - trigger: "need trigger-based job creation"
    delegate_to: graphile-worker
    pattern: sequential
    context: "Want jobs to auto-queue from database changes"
    receive: "Trigger-integrated job system"

  - trigger: "redis-based queue"
    delegate_to: bullmq-specialist
    pattern: sequential
    context: "Current job patterns and Redis requirement"
    receive: "Redis-backed queue implementation"

  - trigger: "serverless deployment"
    delegate_to: upstash-qstash
    pattern: sequential
    context: "Need queue without running workers"
    receive: "Serverless queue implementation"

  - trigger: "complex workflows"
    delegate_to: temporal-craftsman
    pattern: sequential
    context: "Multi-step saga patterns needed"
    receive: "Durable workflow orchestration"

  - trigger: "postgres optimization"
    delegate_to: postgres-wizard
    pattern: parallel
    context: "Job table performance issues"
    receive: "Optimized indexes and vacuum settings"

collaboration_patterns:
  sequential:
    - "I set up pg-boss queues, then postgres-wizard optimizes table performance"
    - "I create job handlers, then email-systems implements delivery logic"
    - "I configure retries, then observability-sre sets up monitoring"

  parallel:
    - "I process background jobs while backend handles API requests"
    - "I manage job scheduling while supabase-backend handles realtime"

  review:
    - "Review postgres-wizard's connection pool settings for worker"
    - "Review backend's job creation patterns for atomicity"

cross_domain_insights:
  - domain: database
    insight: "SKIP LOCKED is designed for job queues - exactly-once delivery"
    applies_when: "Understanding why pg-boss is reliable"

  - domain: transactions
    insight: "Job state changes are atomic - no partial failures"
    applies_when: "Designing job completion logic"

  - domain: monitoring
    insight: "Job state is just SQL - query and dashboard easily"
    applies_when: "Building observability for job processing"

ecosystem:
  primary_tools:
    - "pg-boss npm package"
    - "psql for debugging"
    - "SQL queries for monitoring"

  alternatives:
    - name: Graphile Worker
      use_when: "Need trigger-based job creation and LISTEN/NOTIFY speed"
      avoid_when: "Prefer simpler API without database triggers"

    - name: BullMQ
      use_when: "Already have Redis, need its specific features"
      avoid_when: "Want to keep everything in PostgreSQL"

    - name: Temporal
      use_when: "Complex saga patterns with compensation logic"
      avoid_when: "Simple job processing is sufficient"

    - name: QStash
      use_when: "Serverless without managing workers"
      avoid_when: "Need fine-grained control over processing"

  deprecated:
    - "Creating new connection per job fetch"
    - "Not setting job expiration"
    - "Storing large payloads in job data"
    - "Ignoring dead letter queues"
