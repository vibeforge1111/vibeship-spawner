id: database-schema-design-collaboration
skill: database-schema-design
version: 1.0.0

# ============================================================================
# RECEIVES FROM (Who delegates TO this skill)
# ============================================================================
receives_from:
  - skill: backend
    context: "Backend needs data model for new feature"
    receives:
      - "Feature requirements"
      - "Data relationships"
      - "Query patterns expected"
    provides: "Schema design and migration files"

  - skill: product-management
    context: "New feature requires data storage"
    receives:
      - "Business entities and rules"
      - "Data retention requirements"
      - "Reporting needs"
    provides: "Data model aligned with business domain"

  - skill: frontend
    context: "UI needs specific data structure"
    receives:
      - "Form field requirements"
      - "Filter/sort needs"
      - "Relationship display requirements"
    provides: "Schema that maps cleanly to UI components"

  - skill: analytics
    context: "Analytics needs historical data tracking"
    receives:
      - "Metrics to track"
      - "Aggregation requirements"
      - "Time-series patterns"
    provides: "Schema with audit trails and analytics-friendly structure"

# ============================================================================
# DELEGATION TRIGGERS
# ============================================================================
delegation_triggers:
  - trigger: "query performance|slow query|optimize query"
    delegate_to: postgres-wizard
    pattern: sequential
    context: "Schema is set, need query optimization"
    handoff_data:
      - "Current schema"
      - "Problem queries"
      - "Expected access patterns"
    receive: "Query optimizations and index recommendations"

  - trigger: "api|endpoint|rest|graphql"
    delegate_to: backend
    pattern: parallel
    context: "Schema defined, build API layer"
    handoff_data:
      - "Schema structure"
      - "Relationship cardinality"
      - "Business rules"
    receive: "API implementation"

  - trigger: "auth|authentication|authorization|rls"
    delegate_to: supabase-backend
    pattern: sequential
    context: "Schema needs row-level security"
    handoff_data:
      - "User model structure"
      - "Access patterns"
      - "Multi-tenancy requirements"
    receive: "RLS policies and auth integration"

  - trigger: "deploy|migration strategy|zero downtime"
    delegate_to: devops
    pattern: sequential
    context: "Schema changes need safe deployment"
    handoff_data:
      - "Migration files"
      - "Data volume estimates"
      - "Rollback requirements"
    receive: "Deployment runbook"

  - trigger: "performance|load testing|scaling"
    delegate_to: performance-hunter
    pattern: parallel
    context: "Schema needs performance validation"
    handoff_data:
      - "Expected query patterns"
      - "Data volume projections"
      - "Concurrency requirements"
    receive: "Performance analysis and recommendations"

# ============================================================================
# FEEDBACK LOOPS
# ============================================================================
feedback_loops:
  receives_feedback_from:
    - skill: backend
      signal: "N+1 queries or slow data access"
      action: "Review indexes and eager loading strategy"

    - skill: postgres-wizard
      signal: "Query plan shows sequential scans"
      action: "Add missing indexes or restructure schema"

    - skill: devops
      signal: "Migration blocked production"
      action: "Revise migration strategy for zero-downtime"

    - skill: analytics
      signal: "Aggregation queries too slow"
      action: "Add materialized views or denormalize for reads"

  sends_feedback_to:
    - skill: backend
      signal: "Schema constraints that affect API design"
      action: "Align API with data model constraints"

    - skill: product-management
      signal: "Technical constraints on data model"
      action: "Adjust requirements to fit database capabilities"

    - skill: frontend
      signal: "Relationship changes affecting UI"
      action: "Update components for new data structure"

# ============================================================================
# CROSS-DOMAIN INSIGHTS
# ============================================================================
cross_domain_insights:
  - domain: Distributed Systems
    insight: |
      Distributed systems engineers understand:
      - CAP theorem applies to database choices
      - Eventually consistent reads need careful handling
      - Sharding requires partition-friendly primary keys (UUID v7)
      - Cross-shard transactions are expensive
      Schema design must anticipate distribution.
    applies_when: "Designing for multi-region or high-scale systems"

  - domain: Data Warehousing
    insight: |
      Data warehouse architects know:
      - Star schema for analytics, normalized for OLTP
      - Fact tables vs dimension tables
      - Slowly changing dimensions (SCD Type 1/2/3)
      - Materialized views for expensive aggregations
      OLTP schema and analytics schema serve different masters.
    applies_when: "Balancing operational and analytical needs"

  - domain: Domain-Driven Design
    insight: |
      DDD practitioners understand:
      - Aggregates define transaction boundaries
      - Entities vs Value Objects map to tables vs embedded JSON
      - Bounded contexts may need separate databases
      - Event sourcing changes everything about schema design
      Schema should reflect domain model, not the reverse.
    applies_when: "Modeling complex business domains"

  - domain: Compliance & Legal
    insight: |
      Compliance experts know:
      - GDPR right to erasure vs audit trail requirements
      - Data retention policies affect schema design
      - PII needs encryption or tokenization
      - Soft delete may not satisfy "deletion" requirements
      Legal constraints are non-negotiable schema requirements.
    applies_when: "Handling personal data or regulated industries"

# ============================================================================
# COMMON COMBINATIONS
# ============================================================================
common_combinations:
  - name: Full-Stack Feature
    skills:
      - database-schema-design
      - backend
      - frontend
    workflow: |
      1. Data model design (database-schema-design)
      2. Migration creation (database-schema-design)
      3. API layer (backend)
      4. UI components (frontend)

  - name: Data Platform
    skills:
      - database-schema-design
      - postgres-wizard
      - analytics
    workflow: |
      1. Core schema design (database-schema-design)
      2. Query optimization (postgres-wizard)
      3. Analytics views (analytics)

  - name: Multi-Tenant SaaS
    skills:
      - database-schema-design
      - supabase-backend
      - devops
    workflow: |
      1. Tenant-aware schema (database-schema-design)
      2. RLS policies (supabase-backend)
      3. Deployment strategy (devops)

  - name: Migration Project
    skills:
      - database-schema-design
      - devops
      - backend
    workflow: |
      1. Schema changes (database-schema-design)
      2. Zero-downtime migration plan (devops)
      3. Application compatibility (backend)

# ============================================================================
# ECOSYSTEM
# ============================================================================
ecosystem:
  primary_tools:
    - "Prisma - Type-safe ORM with schema-first approach"
    - "Drizzle - Lightweight TypeScript ORM with SQL-like syntax"
    - "TypeORM - Decorator-based ORM for TypeScript"
    - "pgAdmin / DBeaver - Database management GUIs"
    - "dbdiagram.io - Visual schema design"

  alternatives:
    - name: Prisma
      use_when: "Need type safety, migration management, rapid development"
      avoid_when: "Complex raw SQL queries, edge runtime, maximum performance"

    - name: Drizzle
      use_when: "Want SQL-like syntax, need edge runtime support, value performance"
      avoid_when: "Need lazy loading, want automatic migrations, new to SQL"

    - name: TypeORM
      use_when: "Coming from Java/C# ORMs, need decorator-based entities"
      avoid_when: "TypeScript-first project, want active maintenance"

    - name: Raw SQL
      use_when: "Maximum control, complex queries, performance critical"
      avoid_when: "Rapid development, type safety important, team unfamiliar with SQL"

  deprecated:
    - "Sequelize - Use Prisma or Drizzle instead"
    - "Knex as ORM - Use as query builder only, pair with Objection.js if needed"
    - "mongoose for SQL - Use proper SQL ORM"
