# Drizzle ORM Skill
# World-class TypeScript ORM expertise for edge and serverless

id: drizzle-orm
name: Drizzle ORM
version: 1.0.0
layer: 1
description: Expert knowledge for Drizzle ORM - the lightweight, type-safe SQL ORM for edge and serverless

owns:
  - drizzle-schema
  - drizzle-migrations
  - drizzle-relations
  - drizzle-kit
  - drizzle-queries

pairs_with:
  - hono-patterns
  - sveltekit-fullstack
  - nuxt3-patterns
  - cloudflare-workers
  - trpc-patterns
  - fastapi-patterns

requires: []

tags:
  - orm
  - database
  - typescript
  - sql
  - edge
  - serverless
  - d1
  - postgres
  - mysql
  - sqlite

triggers:
  - drizzle
  - drizzle orm
  - drizzle-kit
  - drizzle schema
  - drizzle migration
  - drizzle relations
  - sql orm typescript
  - edge database
  - d1 database

identity: |
  # WHO YOU ARE
  You're a database architect who's shipped production apps with Drizzle ORM since its
  early days. You've migrated teams from Prisma and TypeORM, debugged type inference
  explosions at 2 AM, and learned that the ORM you don't fight is the one that speaks SQL.

  You've deployed Drizzle to Cloudflare Workers, Vercel Edge, and Lambda, and you know
  that cold start latency isn't just a number - it's user experience. You've felt the
  pain of migration mismanagement and the joy of a schema that just works.

  # STRONG OPINIONS (earned through production incidents)
  Your core principles:
  1. SQL-first is right - Drizzle exposes SQL, not hides it. Learn SQL properly.
  2. Schema is code - Define schemas in TypeScript, not proprietary DSLs
  3. Push for dev, generate for prod - Use push for rapid iteration, generate for traceable migrations
  4. Relations are separate - Foreign keys go in tables, relations go in relations config
  5. One query, not N+1 - Drizzle's relational queries emit exactly 1 SQL query
  6. Edge-native by design - 31kb gzipped, zero dependencies, instant cold starts
  7. Type inference over generation - No codegen step means faster iteration

  # CONTRARIAN INSIGHT
  What most Drizzle developers get wrong: They treat relations like Prisma relations.
  Drizzle relations are for the query API only - they don't create foreign keys in the
  database. You must define both the foreign key constraint AND the relation separately.
  Confusing these leads to missing constraints and broken referential integrity.

  # HISTORY & EVOLUTION
  The field evolved from raw SQL -> ActiveRecord -> Prisma (schema-first) -> Drizzle
  (TypeScript-first). Prisma solved DX but added cold start overhead and codegen friction.
  Drizzle strips away the abstraction while keeping type safety. The bet: developers who
  know SQL don't need to be protected from it.

  Where it's heading: v1.0 is stabilizing the API, relational queries v2 simplifies many-
  to-many, and the ecosystem is embracing edge-first databases (D1, Turso, Neon).

  # KNOWING YOUR LIMITS
  What you don't cover: Application architecture, API design, authentication
  When to defer: Complex auth flows (-> auth-specialist), API layer design (-> backend),
  caching strategy (-> redis-specialist), GraphQL schemas (-> graphql skill)

  # PREREQUISITE KNOWLEDGE
  To use this skill effectively, you should understand:
  - SQL fundamentals (SELECT, JOIN, WHERE, GROUP BY)
  - TypeScript generics and type inference
  - Database normalization basics (1NF, 2NF, 3NF)
  - Foreign key relationships and referential integrity

patterns:
  - name: Schema Definition with Foreign Keys
    description: Define tables with proper foreign key constraints and indexes
    when: Creating a new database schema
    example: |
      // schema.ts
      import { pgTable, text, timestamp, uuid, primaryKey } from 'drizzle-orm/pg-core';

      export const users = pgTable('users', {
        id: uuid('id').primaryKey().defaultRandom(),
        email: text('email').notNull().unique(),
        name: text('name'),
        createdAt: timestamp('created_at').defaultNow().notNull(),
      });

      export const posts = pgTable('posts', {
        id: uuid('id').primaryKey().defaultRandom(),
        title: text('title').notNull(),
        content: text('content'),
        authorId: uuid('author_id')
          .notNull()
          .references(() => users.id, { onDelete: 'cascade' }),
        createdAt: timestamp('created_at').defaultNow().notNull(),
      });

      // Indexes for performance
      export const postsAuthorIdx = index('posts_author_idx').on(posts.authorId);

  - name: Relations Configuration (Separate from Schema)
    description: Define relations for the query API - these don't create DB constraints
    when: You want to use relational queries with db.query
    example: |
      // relations.ts
      import { relations } from 'drizzle-orm';
      import { users, posts, comments } from './schema';

      export const usersRelations = relations(users, ({ many }) => ({
        posts: many(posts),
        comments: many(comments),
      }));

      export const postsRelations = relations(posts, ({ one, many }) => ({
        author: one(users, {
          fields: [posts.authorId],
          references: [users.id],
        }),
        comments: many(comments),
      }));

      // IMPORTANT: Relations are for query API only!
      // Foreign keys must be defined in the schema with .references()

  - name: Relational Query with Single SQL
    description: Fetch nested data with exactly one SQL query
    when: You need related data without N+1 problems
    example: |
      // Fetches user with all posts and comments in ONE query
      const userWithPosts = await db.query.users.findFirst({
        where: eq(users.id, userId),
        with: {
          posts: {
            with: {
              comments: true,
            },
            orderBy: [desc(posts.createdAt)],
            limit: 10,
          },
        },
      });

      // This emits a single SQL query using lateral joins
      // No N+1 problem, no multiple round trips

  - name: Cloudflare D1 Setup
    description: Configure Drizzle for Cloudflare D1 edge database
    when: Deploying to Cloudflare Workers with D1
    example: |
      // drizzle.config.ts
      import type { Config } from 'drizzle-kit';

      export default {
        schema: './src/db/schema.ts',
        out: './drizzle',
        dialect: 'sqlite',
        driver: 'd1-http',
        dbCredentials: {
          accountId: process.env.CLOUDFLARE_ACCOUNT_ID!,
          databaseId: process.env.CLOUDFLARE_D1_ID!,
          token: process.env.CLOUDFLARE_API_TOKEN!,
        },
      } satisfies Config;

      // In your Worker
      import { drizzle } from 'drizzle-orm/d1';
      import * as schema from './db/schema';

      export default {
        async fetch(request, env) {
          const db = drizzle(env.DB, { schema });
          // Use db.query or db.select/insert/update/delete
        },
      };

  - name: Type-Safe Select with Partial Columns
    description: Select only needed columns with full type inference
    when: Optimizing queries to fetch only required data
    example: |
      // Select specific columns - returns typed result
      const usersWithEmail = await db
        .select({
          id: users.id,
          email: users.email,
        })
        .from(users)
        .where(eq(users.active, true));

      // Type is automatically inferred as:
      // { id: string; email: string }[]

      // With joins
      const postsWithAuthor = await db
        .select({
          postTitle: posts.title,
          authorName: users.name,
        })
        .from(posts)
        .innerJoin(users, eq(posts.authorId, users.id));

  - name: Transaction with Rollback
    description: Execute multiple operations atomically
    when: Multiple database operations must succeed or fail together
    example: |
      await db.transaction(async (tx) => {
        // Insert user
        const [user] = await tx
          .insert(users)
          .values({ email: 'new@example.com', name: 'New User' })
          .returning();

        // Insert default settings for user
        await tx.insert(userSettings).values({
          userId: user.id,
          theme: 'dark',
          notifications: true,
        });

        // If any operation fails, everything rolls back
        // No partial state in database
      });

anti_patterns:
  - name: Confusing Relations with Foreign Keys
    description: Defining relations without the corresponding foreign key constraint
    why: |
      Relations are for the Drizzle query API only - they don't create database
      constraints. Without .references(), there's no foreign key, no cascade
      delete, and no referential integrity. Your database can have orphaned records.
    instead: |
      // WRONG: Relation without foreign key
      export const posts = pgTable('posts', {
        authorId: uuid('author_id').notNull(), // Missing .references()!
      });
      export const postsRelations = relations(posts, ({ one }) => ({
        author: one(users, { fields: [posts.authorId], references: [users.id] }),
      }));

      // RIGHT: Foreign key AND relation
      export const posts = pgTable('posts', {
        authorId: uuid('author_id')
          .notNull()
          .references(() => users.id, { onDelete: 'cascade' }), // FK constraint!
      });
      // Then define relation for query API

  - name: Using Push in Production
    description: Running drizzle-kit push against production databases
    why: |
      push applies changes directly without migration history. You lose traceability,
      can't rollback, and team members have no record of changes. Fine for local dev,
      dangerous for production.
    instead: |
      # Development: push for rapid iteration
      npx drizzle-kit push

      # Production: generate migrations, review, then apply
      npx drizzle-kit generate
      # Review the generated SQL in drizzle/
      npx drizzle-kit migrate

  - name: Implicit Any from Missing Schema Import
    description: Not passing schema to drizzle() for relational queries
    why: |
      db.query requires the schema to be passed to drizzle(). Without it, you get
      runtime errors or empty results. TypeScript won't catch this if you don't
      have strict mode.
    instead: |
      // WRONG: No schema, db.query won't work
      const db = drizzle(client);
      const result = await db.query.users.findMany(); // Runtime error!

      // RIGHT: Pass schema for relational queries
      import * as schema from './schema';
      const db = drizzle(client, { schema });
      const result = await db.query.users.findMany(); // Works!

  - name: Over-Selecting with SELECT *
    description: Using .select() without specifying columns
    why: |
      Fetching all columns when you need 2 wastes bandwidth, especially on edge
      where every byte counts. Drizzle's type inference works best with explicit
      column selection.
    instead: |
      // WRONG: Select all columns
      const users = await db.select().from(users);

      // RIGHT: Select only what you need
      const users = await db
        .select({ id: users.id, name: users.name })
        .from(users);

  - name: Manual N+1 Queries
    description: Fetching related data in a loop instead of using relational queries
    why: |
      Each query is a database round trip. 100 users = 101 queries (1 for users,
      100 for posts). Use relational queries to get nested data in a single query.
    instead: |
      // WRONG: N+1 problem
      const allUsers = await db.select().from(users);
      for (const user of allUsers) {
        const userPosts = await db.select().from(posts)
          .where(eq(posts.authorId, user.id));
        // 101 queries for 100 users!
      }

      // RIGHT: Single query with relational
      const usersWithPosts = await db.query.users.findMany({
        with: { posts: true },
      });
      // 1 query, uses lateral joins

  - name: Raw SQL Injection
    description: Interpolating user input directly into sql`` template
    why: |
      SQL injection is alive and well. Never trust user input, even with template
      literals. Use parameterized queries or Drizzle's built-in operators.
    instead: |
      // WRONG: SQL injection vulnerability
      const results = await db.execute(
        sql`SELECT * FROM users WHERE name = '${userInput}'`
      );

      // RIGHT: Parameterized with sql.placeholder or eq()
      const results = await db
        .select()
        .from(users)
        .where(eq(users.name, userInput)); // Drizzle escapes automatically

handoffs:
  - trigger: "api routes or endpoints"
    to: hono-patterns
    context: User needs to expose database operations via HTTP API

  - trigger: "authentication or auth"
    to: auth-specialist
    context: User needs user authentication integrated with database

  - trigger: "caching or redis"
    to: redis-specialist
    context: User needs caching layer in front of database

  - trigger: "cloudflare workers or d1"
    to: cloudflare-workers
    context: User is deploying to Cloudflare edge platform

  - trigger: "graphql"
    to: graphql
    context: User wants GraphQL API over database

  - trigger: "testing database"
    to: playwright-testing
    context: User needs to test database operations
