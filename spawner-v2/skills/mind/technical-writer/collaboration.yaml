# Technical Writer Collaboration Patterns
# How documentation integrates with other foundational skills

collaboration:
  # Lead role - Technical Writer drives these workflows
  leads:
    - workflow: documentation-strategy
      description: Planning what documentation is needed and at what depth
      involves:
        - decision-maker: Prioritizing documentation effort
        - system-designer: Architecture documentation needs
        - code-quality: Code self-documentation standards
      handoff_points:
        - to: decision-maker
          when: Limited time requires doc prioritization
          context_to_share: Documentation gaps, audience needs, effort estimates
        - to: system-designer
          when: Architecture docs need technical accuracy review
          context_to_share: Draft docs, technical questions

    - workflow: api-documentation
      description: Creating and maintaining API documentation
      involves:
        - code-quality: Code examples and standards
        - test-strategist: Example testing
      handoff_points:
        - to: code-quality
          when: Examples need code review
          context_to_share: Code samples, style requirements
        - to: test-strategist
          when: Documentation examples need automated testing
          context_to_share: Code examples, expected outputs

    - workflow: knowledge-transfer
      description: Documenting for team onboarding and knowledge sharing
      involves:
        - system-designer: Architecture context
        - decision-maker: Decision history (ADRs)
        - tech-debt-manager: Known issues and debt context
      handoff_points:
        - to: system-designer
          when: Architecture overview needed
          context_to_share: Current understanding, gaps
        - to: decision-maker
          when: Past decisions need documentation
          context_to_share: What decisions, why context matters

  # Support role - Technical Writer assists these workflows
  supports:
    - workflow: system-design
      led_by: system-designer
      contribution: Architecture documentation, ADR writing
      when_called: Design decisions need documentation

    - workflow: code-review
      led_by: code-quality
      contribution: Documentation review, comment quality
      when_called: PR includes documentation changes

    - workflow: api-design
      led_by: system-designer
      contribution: API documentation structure and examples
      when_called: New API endpoints being designed

    - workflow: refactoring
      led_by: refactoring-guide
      contribution: Updating docs after code changes
      when_called: Refactoring affects documented behavior

    - workflow: post-incident-review
      led_by: incident-responder
      contribution: Post-mortem documentation, runbook updates
      when_called: Incident reveals documentation gaps

  # Escalation patterns
  escalations:
    - situation: Don't know what to document
      escalate_to: decision-maker
      with_context: Options, audiences, effort estimates
      reason: Need prioritization framework

    - situation: Technical accuracy uncertain
      escalate_to: system-designer OR code-quality
      with_context: Current draft, specific questions
      reason: Need technical validation

    - situation: Documentation reveals code problems
      escalate_to: code-quality OR refactoring-guide
      with_context: What's hard to document and why
      reason: If it's hard to document, it might need simplifying

    - situation: Historical decisions need reconstruction
      escalate_to: decision-maker
      with_context: What decisions, available artifacts
      reason: Need decision archaeology

  # Integration contracts
  contracts:
    with_system_designer:
      technical_writer_provides:
        - Architecture documentation drafts
        - ADR templates and structure
        - Documentation for review
        - Questions about technical accuracy
      system_designer_provides:
        - Technical validation of docs
        - Architecture context and decisions
        - System diagrams and explanations
        - Clarification of design rationale
      interface_example: |
        # Technical writer drafts architecture doc:
        """
        ARCHITECTURE DOC DRAFT:

        ## System Overview
        [Current understanding...]

        ## Components
        [What I think I understand...]

        QUESTIONS:
        1. Is the auth flow accurate?
        2. What's the relationship between X and Y?
        3. Why does data flow this way?

        NEED: Technical review and gap-filling
        """

        # System designer responds:
        """
        TECHNICAL REVIEW:

        ## Corrections
        - Auth flow: Actually goes through middleware first
        - X-Y relationship: X depends on Y, not reverse

        ## Missing Context
        - Data flows this way due to ADR-042
        - Add section on caching layer

        ## Suggested Diagram
        [ASCII or link to diagram]
        """

    with_code_quality:
      technical_writer_provides:
        - Code examples for documentation
        - Comment guidelines draft
        - Documentation of patterns
      code_quality_provides:
        - Code review of examples
        - Style consistency guidance
        - Pattern validation
        - Self-documentation standards
      interface_example: |
        # Technical writer requests code example review:
        """
        CODE EXAMPLE FOR DOCS:

        ```typescript
        // Example: Creating a payment
        const payment = await api.payments.create({
          amount: 1000,
          currency: 'usd',
          customer: 'cus_123'
        });
        ```

        QUESTIONS:
        1. Is this idiomatic for our codebase?
        2. Should I include error handling?
        3. Any common gotchas to mention?
        """

        # Code quality responds:
        """
        CODE REVIEW:

        STYLE:
        - Good: Matches our TypeScript style
        - Add: async/await wrapper for context

        RECOMMENDATIONS:
        1. Add error handling example (common support ticket)
        2. Show the response type
        3. Mention idempotency for this endpoint

        UPDATED EXAMPLE:
        ```typescript
        // Example: Creating a payment
        try {
          const payment: PaymentResponse = await api.payments.create({
            amount: 1000,  // in cents
            currency: 'usd',
            customer: 'cus_123'
          }, {
            idempotencyKey: 'unique-request-id'
          });
          console.log(payment.id); // pay_xxx
        } catch (error) {
          if (error.code === 'card_declined') {
            // Handle declined card
          }
        }
        ```
        """

    with_test_strategist:
      technical_writer_provides:
        - Documentation code examples
        - Test coverage for examples
        - Tutorial steps to verify
      test_strategist_provides:
        - Example testing strategy
        - Documentation test automation
        - Coverage of documented behavior
      interface_example: |
        # Technical writer asks about testing docs:
        """
        DOCUMENTATION TESTING REQUEST:

        README has 12 code examples.
        API docs have 45 code examples.
        Tutorial has 8 multi-step examples.

        CONCERN: How do we know these still work?

        QUESTION: How should we test documentation?
        """

        # Test strategist responds:
        """
        DOCUMENTATION TESTING STRATEGY:

        APPROACH 1: Doctest-style (simple)
        - Extract code blocks from markdown
        - Run as test suite
        - Fail CI if examples break

        APPROACH 2: Integration (comprehensive)
        - Tutorial as e2e test
        - Run fresh install → tutorial → verify

        RECOMMENDATION:
        1. README examples: Run in CI (high visibility)
        2. API examples: Auto-generate from tests
        3. Tutorial: Quarterly manual verification

        IMPLEMENTATION:
        ```bash
        npm run test:docs  # Extracts and runs README examples
        ```
        """

    with_decision_maker:
      technical_writer_provides:
        - Documentation effort estimates
        - Priority options for documentation
        - ADR drafts for decisions
      decision_maker_provides:
        - Documentation prioritization
        - Resource allocation
        - Decision context for ADRs
      interface_example: |
        # Technical writer requests prioritization:
        """
        DOCUMENTATION BACKLOG:

        1. API Reference (40 endpoints undocumented)
           Effort: 2 weeks
           Impact: Reduces support tickets

        2. Getting Started Guide
           Effort: 3 days
           Impact: Improves onboarding

        3. Architecture Overview
           Effort: 1 week
           Impact: Team knowledge sharing

        4. Troubleshooting Guide
           Effort: 1 week
           Impact: Reduces support load

        CONSTRAINT: 2 weeks available this quarter

        QUESTION: What should we prioritize?
        """

        # Decision maker responds:
        """
        DOCUMENTATION PRIORITY:

        This Quarter:
        1. Getting Started Guide (3d) - Gate for all users
        2. Top 10 API endpoints (4d) - 80% of use cases
        3. Troubleshooting Top 5 issues (3d) - Highest support tickets

        Next Quarter:
        4. Remaining API endpoints
        5. Architecture Overview

        RATIONALE:
        - Getting Started: Enables everything else
        - Partial API: Cover common cases first
        - Troubleshooting: Immediate support reduction

        NOT NOW:
        - Architecture: Team is stable, less urgent
        """

    with_refactoring_guide:
      technical_writer_provides:
        - Documentation updates post-refactoring
        - What's hard to document (complexity signal)
        - User-facing changes to document
      refactoring_guide_provides:
        - What changed and why
        - Behavioral differences
        - Migration needs
      interface_example: |
        # After refactoring, writer needs context:
        """
        DOCUMENTATION UPDATE REQUEST:

        REFACTORING: PaymentProcessor was split into:
        - PaymentValidator
        - PaymentExecutor
        - PaymentReconciler

        QUESTIONS:
        1. Does this change the public API?
        2. What should users know?
        3. Is there a migration path?
        """

        # Refactoring guide responds:
        """
        REFACTORING IMPACT:

        PUBLIC API: No change
        - PaymentProcessor still exists (facade)
        - All existing code works
        - New classes are internal

        USER-FACING: Nothing to document
        - Same interface, better internals
        - No migration needed

        INTERNAL DOCS:
        - Update architecture diagram
        - Add ADR for why we split
        - Document new class responsibilities
        """

    with_incident_responder:
      technical_writer_provides:
        - Post-mortem documentation
        - Runbook updates
        - Incident communication templates
      incident_responder_provides:
        - Incident details for documentation
        - Runbook requirements
        - Gap analysis from incidents
      interface_example: |
        # Incident reveals documentation gaps:
        """
        INCIDENT POST-MORTEM LEARNINGS:

        INCIDENT: Database connection exhaustion
        MTTR: 45 minutes (could have been 10)

        DOCUMENTATION GAPS:
        1. No runbook for DB connection issues
        2. Rollback docs outdated (wrong command)
        3. No documented escalation path for DB team

        REQUEST: Update documentation to prevent recurrence
        """

        # Technical writer responds:
        """
        DOCUMENTATION UPDATES:

        1. RUNBOOK: Database Connection Issues
           - Symptoms to look for
           - Diagnostic commands
           - Resolution steps
           - Escalation path

        2. ROLLBACK DOCS UPDATED:
           - Old: `kubectl rollout undo deploy/api`
           - New: `./scripts/rollback.sh api` (handles health checks)

        3. ESCALATION MATRIX ADDED:
           - Database issues → #db-oncall
           - After hours → PagerDuty DB team

        COMMITTED: PR #456
        """

# Prerequisites for using this skill effectively
prerequisites:
  skills: []  # Foundational skill, no prerequisites
  knowledge:
    - Basic writing skills
    - Understanding of the codebase being documented
    - Familiarity with Markdown
  tools:
    - Markdown editor
    - Version control for docs
    - Documentation hosting (optional)

# When to delegate to this skill
delegation_triggers:
  - phrase: "documentation"
    confidence: high
  - phrase: "README"
    confidence: high
  - phrase: "write docs"
    confidence: high
  - phrase: "API docs"
    confidence: high
  - phrase: "document this"
    confidence: high
  - phrase: "how to explain"
    confidence: medium
  - phrase: "code comments"
    confidence: high
  - phrase: "ADR"
    confidence: high
  - phrase: "architecture doc"
    confidence: high
  - phrase: "runbook"
    confidence: high
  - phrase: "tutorial"
    confidence: high
  - phrase: "onboarding"
    confidence: medium
  - phrase: "knowledge transfer"
    confidence: high

# Skill maturity indicators
maturity_levels:
  beginner:
    characteristics:
      - Writes some documentation
      - Follows templates
      - Updates docs when reminded
    common_mistakes:
      - Over-documenting everything
      - No audience awareness
      - Letting docs get stale

  intermediate:
    characteristics:
      - Writes for specific audiences
      - Includes examples
      - Maintains key docs proactively
    common_mistakes:
      - Still too verbose
      - Missing troubleshooting
      - Screenshots that go stale

  advanced:
    characteristics:
      - Minimal, effective documentation
      - Tests documentation examples
      - Builds documentation culture
    common_mistakes:
      - Assuming others have same judgment
      - Under-documenting for newcomers
      - Documentation perfectionism
