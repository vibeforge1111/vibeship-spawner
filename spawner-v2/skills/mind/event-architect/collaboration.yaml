# Event Architect Collaboration Model
# How this skill works with other AI memory specialists

prerequisites:
  skills: []
  knowledge:
    - "Understanding of distributed systems basics"
    - "Familiarity with message queues (NATS, Kafka, RabbitMQ)"
    - "Basic understanding of database transactions"
    - "Async/await patterns in Python"

complementary_skills:
  - skill: graph-engineer
    relationship: "Event-to-graph sync"
    brings: "Designs how events update knowledge graph entities and relationships"

  - skill: vector-specialist
    relationship: "Event-triggered embeddings"
    brings: "Defines embedding generation events and vector index updates"

  - skill: temporal-craftsman
    relationship: "Saga orchestration"
    brings: "Long-running workflows that span multiple events"

  - skill: ml-memory
    relationship: "Memory lifecycle events"
    brings: "Event design for memory creation, consolidation, forgetting"

  - skill: performance-hunter
    relationship: "Event processing optimization"
    brings: "Profiling and optimizing high-throughput event pipelines"

  - skill: privacy-guardian
    relationship: "Event data privacy"
    brings: "Ensuring events don't leak PII, encryption at rest"

  - skill: causal-scientist
    relationship: "Causal event chains"
    brings: "Modeling cause-effect relationships through event causation"

  - skill: infra-architect
    relationship: "Event infrastructure"
    brings: "Kubernetes deployment, Kafka/NATS cluster setup, GitOps"

  - skill: observability-sre
    relationship: "Event monitoring"
    brings: "Consumer lag alerts, dead letter queue monitoring, tracing"

  - skill: chaos-engineer
    relationship: "Event system resilience"
    brings: "Partition failure testing, consumer crash recovery validation"

  - skill: test-architect
    relationship: "Event testing"
    brings: "Integration testing patterns, event replay testing"

delegation:
  - trigger: "need to store and query entity relationships"
    delegate_to: graph-engineer
    pattern: sequential
    context: "Pass event schema showing entities to be connected in graph"
    receive: "Graph schema and Cypher queries for event-driven updates"

  - trigger: "need semantic search on event data"
    delegate_to: vector-specialist
    pattern: parallel
    context: "Event types that need embedding, expected query patterns"
    receive: "Embedding pipeline design and vector store schema"

  - trigger: "need multi-step process spanning events"
    delegate_to: temporal-craftsman
    pattern: sequential
    context: "Business process steps, compensation requirements, timeout needs"
    receive: "Temporal workflow definition coordinating events"

  - trigger: "need memory hierarchy or consolidation"
    delegate_to: ml-memory
    pattern: sequential
    context: "Memory event types, temporal levels, promotion criteria"
    receive: "Memory lifecycle state machine and consolidation events"

collaboration_patterns:
  sequential:
    - "I define event schema, then graph-engineer maps to knowledge graph"
    - "I design event flow, then temporal-craftsman wraps in durable workflow"

  parallel:
    - "I handle event storage while vector-specialist handles embedding pipeline"
    - "I manage event stream while performance-hunter profiles and optimizes"

  review:
    - "privacy-guardian reviews event schemas for PII exposure"
    - "causal-scientist validates causation chain design"

cross_domain_insights:
  - domain: database-theory
    insight: "ACID transactions map to event boundaries - one event = one transaction"
    applies_when: "Designing aggregate boundaries and event granularity"

  - domain: distributed-systems
    insight: "CAP theorem applies - choose availability over consistency, use eventual consistency"
    applies_when: "Designing cross-service event flows"

  - domain: journalism
    insight: "Events follow 5 Ws: Who, What, When, Where, Why (correlation ID answers Why)"
    applies_when: "Naming events and choosing fields"

  - domain: accounting
    insight: "Double-entry bookkeeping pattern - every event has a compensating inverse"
    applies_when: "Designing saga compensation and event reversibility"

ecosystem:
  primary_tools:
    - "NATS JetStream - lightweight, fast, Kubernetes-native"
    - "Apache Kafka - battle-tested, high throughput"
    - "EventStoreDB - purpose-built event store"
    - "PostgreSQL - event store with LISTEN/NOTIFY"

  alternatives:
    - name: Redis Streams
      use_when: "Simple event streaming needs, already using Redis"
      avoid_when: "Need strong durability guarantees or complex routing"

    - name: AWS EventBridge
      use_when: "AWS-native architecture, serverless event routing"
      avoid_when: "Need replay from beginning or complex stream processing"

    - name: Pulsar
      use_when: "Need tiered storage, geo-replication"
      avoid_when: "Simpler setup preferred, Kafka expertise available"

  deprecated:
    - "RabbitMQ for event sourcing (not designed for replay/persistence)"
    - "In-memory event stores (lose data on restart)"
    - "Single-partition Kafka topics (ordering bottleneck)"
