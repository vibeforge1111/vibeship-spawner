# Graph Engineer Collaboration Model
# How this skill works with other AI memory specialists

prerequisites:
  skills: []
  knowledge:
    - "Basic understanding of graph theory (nodes, edges, traversal)"
    - "Familiarity with Cypher or similar graph query language"
    - "Understanding of database indexing concepts"
    - "Basic Python async/await patterns"

complementary_skills:
  - skill: event-architect
    relationship: "Event-driven graph updates"
    brings: "Event sourcing patterns for consistent graph modifications"

  - skill: vector-specialist
    relationship: "Hybrid graph+vector retrieval"
    brings: "Vector similarity search to complement graph traversal"

  - skill: causal-scientist
    relationship: "Statistical causation validation"
    brings: "Rigorous causal inference to validate graph-based causality claims"

  - skill: ml-memory
    relationship: "Memory graph structure"
    brings: "Memory hierarchy design for graph-based memory systems"

  - skill: performance-hunter
    relationship: "Graph query optimization"
    brings: "Profiling and optimization for graph database performance"

  - skill: privacy-guardian
    relationship: "Graph data privacy"
    brings: "Privacy patterns for knowledge graphs (anonymization, access control)"

  - skill: temporal-craftsman
    relationship: "Graph maintenance workflows"
    brings: "Long-running workflows for graph cleanup and consolidation"

  - skill: postgres-wizard
    relationship: "PostgreSQL graph extensions"
    brings: "AGE extension, recursive CTEs, graph patterns in SQL"

  - skill: test-architect
    relationship: "Graph testing"
    brings: "Graph query testing, data fixtures, property-based testing"

  - skill: observability-sre
    relationship: "Graph monitoring"
    brings: "Query latency dashboards, connection pool monitoring"

delegation:
  - trigger: "need to store events driving graph changes"
    delegate_to: event-architect
    pattern: sequential
    context: "Pass graph mutation types and ordering requirements"
    receive: "Event schema and stream design for graph updates"

  - trigger: "need semantic search on graph content"
    delegate_to: vector-specialist
    pattern: parallel
    context: "Node content types that need embedding, query patterns"
    receive: "Embedding pipeline and hybrid retrieval strategy"

  - trigger: "need to validate causation claims statistically"
    delegate_to: causal-scientist
    pattern: sequential
    context: "Causal edges to validate, available observational data"
    receive: "Statistical validation of causal relationships"

  - trigger: "need memory lifecycle management"
    delegate_to: ml-memory
    pattern: sequential
    context: "Memory node types, consolidation requirements"
    receive: "Memory hierarchy and promotion/forgetting logic"

  - trigger: "graph queries are slow"
    delegate_to: performance-hunter
    pattern: review
    context: "Slow queries, current indexes, data distribution"
    receive: "Optimized queries and index recommendations"

collaboration_patterns:
  sequential:
    - "I design graph schema, then event-architect creates event flow for updates"
    - "I model causal graph structure, then causal-scientist validates with statistics"

  parallel:
    - "I handle graph storage while vector-specialist handles embeddings"
    - "I design entity model while ml-memory designs memory hierarchy"

  review:
    - "performance-hunter reviews query performance"
    - "privacy-guardian reviews for PII in graph data"

cross_domain_insights:
  - domain: social-network-analysis
    insight: "Community detection algorithms (Louvain, Label Propagation) identify memory clusters"
    applies_when: "Finding related memories or concepts for consolidation"

  - domain: biology
    insight: "Metabolic pathway graphs model cause-effect chains with feedback loops"
    applies_when: "Modeling complex causal relationships with inhibition/activation"

  - domain: linguistics
    insight: "WordNet-style hyponym/hypernym hierarchies enable concept generalization"
    applies_when: "Building concept hierarchies for memory abstraction"

  - domain: library-science
    insight: "Faceted classification enables multi-dimensional entity organization"
    applies_when: "Designing entity type hierarchies and tagging systems"

ecosystem:
  primary_tools:
    - "FalkorDB - Redis-based, fast, Kubernetes-native"
    - "Neo4j - Battle-tested, mature tooling, enterprise features"
    - "Memgraph - In-memory, streaming-first"
    - "Amazon Neptune - Managed, auto-scaling, AWS-native"

  alternatives:
    - name: ArangoDB
      use_when: "Need multi-model (document + graph) in one database"
      avoid_when: "Pure graph workload, need graph-specific optimizations"

    - name: Dgraph
      use_when: "GraphQL-native access, horizontal scaling required"
      avoid_when: "Need Cypher compatibility or mature ecosystem"

    - name: TigerGraph
      use_when: "Massive scale graph analytics, enterprise support"
      avoid_when: "Startup budget, simpler use cases"

  deprecated:
    - "OrientDB (acquired, limited development)"
    - "Titan (abandoned, use JanusGraph instead)"
    - "Storing graphs in relational DB with join tables (performance nightmare)"
