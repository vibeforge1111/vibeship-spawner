# Refactoring Guide Collaboration Patterns
# How refactoring integrates with other foundational skills

collaboration:
  # Lead role - Refactoring Guide drives these workflows
  leads:
    - workflow: code-transformation
      description: Safe structural changes to existing code
      involves:
        - test-strategist: Tests for safety net
        - code-quality: Quality targets
        - debugging-master: When things break
      handoff_points:
        - to: test-strategist
          when: Code lacks tests and needs characterization
          context_to_share: Code being refactored, behavior to capture
        - to: debugging-master
          when: Refactoring introduced bugs
          context_to_share: What was changed, symptoms observed

    - workflow: legacy-modernization
      description: Incrementally improving legacy systems
      involves:
        - system-designer: Target architecture
        - tech-debt-manager: Prioritization
        - test-strategist: Test coverage strategy
      handoff_points:
        - to: system-designer
          when: Architecture redesign needed beyond code-level refactoring
          context_to_share: Current constraints, desired improvements
        - to: tech-debt-manager
          when: Refactoring backlog needs prioritization
          context_to_share: Identified smells, effort estimates

    - workflow: code-smell-remediation
      description: Systematically addressing code smells
      involves:
        - code-quality: Identifying smells
        - test-strategist: Test coverage for changes
      handoff_points:
        - to: code-quality
          when: Need to identify what to refactor
          context_to_share: Areas of concern, recent changes

  # Support role - Refactoring Guide assists these workflows
  supports:
    - workflow: bug-fixing
      led_by: debugging-master
      contribution: Safe code improvements after bugs are fixed
      when_called: Bug fixed, code needs cleanup

    - workflow: feature-development
      led_by: code-quality
      contribution: Preparing code for new features
      when_called: Code structure blocks feature work

    - workflow: performance-optimization
      led_by: performance-thinker
      contribution: Restructuring for better performance
      when_called: Structure changes needed for performance

    - workflow: tech-debt-payment
      led_by: tech-debt-manager
      contribution: Executing refactoring from debt backlog
      when_called: Debt prioritized, ready to address

  # Escalation patterns
  escalations:
    - situation: Refactoring reveals deeper architectural issues
      escalate_to: system-designer
      with_context: Discovered constraints, cross-cutting concerns
      reason: Needs architecture-level thinking

    - situation: Refactoring scope is growing out of control
      escalate_to: tech-debt-manager + decision-maker
      with_context: Original scope vs discovered scope, risk assessment
      reason: Need to decide continue vs stop vs pivot

    - situation: Refactoring keeps breaking things
      escalate_to: debugging-master + test-strategist
      with_context: What's breaking, what tests exist
      reason: Need better safety net or debugging approach

    - situation: Team can't agree on refactoring approach
      escalate_to: decision-maker
      with_context: Options considered, trade-offs
      reason: Need decision framework and tie-breaking

  # Integration contracts
  contracts:
    with_test_strategist:
      refactoring_guide_provides:
        - Code being refactored (for test targeting)
        - Behavior that must be preserved
        - Risk areas needing test coverage
      test_strategist_provides:
        - Characterization tests for legacy code
        - Safety net for refactoring
        - Test strategy for incremental changes
      interface_example: |
        # Before refactoring, request from test strategist:
        """
        REFACTORING TARGET: OrderProcessor.processOrder()

        BEHAVIOR TO PRESERVE:
        - Calculates totals correctly
        - Applies discounts in order
        - Handles edge cases (empty orders, zero items)

        CURRENT TESTS: None

        NEED:
        - Characterization tests before refactoring
        - Coverage for all calculation paths
        """

        # Test strategist responds:
        """
        CHARACTERIZATION TEST PLAN:

        1. Capture current behavior:
           - Happy path: standard order
           - Edge: empty order
           - Edge: zero-quantity items
           - Edge: multiple discounts

        2. Golden master for complex calculations

        3. After tests pass, refactoring can proceed safely
        """

    with_code_quality:
      refactoring_guide_provides:
        - Refactoring plan for identified smells
        - Before/after code structure
        - Trade-offs of proposed changes
      code_quality_provides:
        - Code smell identification
        - Quality targets
        - Priority ranking of issues
      interface_example: |
        # Code quality identifies:
        """
        SMELLS IN OrderProcessor:

        1. Long Method: processOrder (150 lines) - HIGH
        2. Feature Envy: accessing payment.card.* everywhere - MEDIUM
        3. Data Clumps: address fields repeated - LOW

        RECOMMENDATION: Address #1 first (most impact)
        """

        # Refactoring guide plans:
        """
        REFACTORING PLAN FOR #1 (Long Method):

        Step 1: Extract validateOrder()
        Step 2: Extract calculateTotals()
        Step 3: Extract applyDiscounts()
        Step 4: Extract processPayment()
        Step 5: Extract sendConfirmation()

        Each step is independently testable and deployable.
        """

    with_debugging_master:
      refactoring_guide_provides:
        - Changes made during refactoring
        - Previous working version reference
        - Expected behavior vs observed
      debugging_master_provides:
        - Root cause when refactoring breaks things
        - Identification of missed edge cases
        - Regression analysis
      interface_example: |
        # Refactoring broke something, escalate to debugging:
        """
        REFACTORING ISSUE:

        CHANGE: Extracted calculateDiscount() from processOrder()
        SYMPTOM: Discount not applied for orders > $1000

        BEFORE (worked):
        if (order.total > 1000) discount = 0.1;

        AFTER (broken):
        function calculateDiscount(order) {
          if (total > 1000) discount = 0.1;  // Missing order. prefix!
        }

        SUSPECT: Variable scope issue in extraction
        """

    with_tech_debt_manager:
      refactoring_guide_provides:
        - Effort estimates for refactoring tasks
        - Risk assessment for changes
        - Dependency analysis
      tech_debt_manager_provides:
        - Prioritized refactoring backlog
        - Business context for priorities
        - Time allocation for refactoring
      interface_example: |
        # Tech debt manager requests estimates:
        """
        REFACTORING CANDIDATES:

        1. OrderProcessor god class
        2. Legacy payment integration
        3. Test infrastructure overhaul
        """

        # Refactoring guide provides:
        """
        EFFORT ESTIMATES:

        1. OrderProcessor (5 days)
           - Extract 5 classes
           - Low risk with tests
           - Immediate readability benefit

        2. Payment integration (15 days)
           - Strangler fig approach
           - High risk, external dependency
           - Enables new payment providers

        3. Test infrastructure (8 days)
           - Parallelization
           - New test utilities
           - Long-term velocity benefit

        RECOMMENDATION: #1 first (high impact, low risk)
        """

    with_system_designer:
      refactoring_guide_provides:
        - Current code constraints
        - Incremental migration feasibility
        - Implementation details for transitions
      system_designer_provides:
        - Target architecture
        - Component boundaries
        - Integration points to preserve
      interface_example: |
        # System designer provides target:
        """
        TARGET ARCHITECTURE:

        Current: Monolithic OrderService
        Target: Separate Order, Payment, Notification services

        BOUNDARIES:
        - Orders owns order state
        - Payment owns transactions
        - Notification owns delivery

        CONSTRAINT: Zero downtime migration
        """

        # Refactoring guide plans migration:
        """
        STRANGLER FIG PLAN:

        Phase 1: Extract interfaces within monolith
        Phase 2: Add feature flags for routing
        Phase 3: Deploy Payment as separate service (flag off)
        Phase 4: Gradual traffic shift to new Payment
        Phase 5: Remove old payment code
        Phase 6: Repeat for Notification
        Phase 7: Order remains, others extracted
        """

# Prerequisites for using this skill effectively
prerequisites:
  skills: []  # Foundational skill, no prerequisites
  knowledge:
    - Programming in any language
    - Version control basics
    - Understanding of functions and classes
  tools:
    - IDE with refactoring support
    - Version control system
    - Test framework (strongly recommended)

# When to delegate to this skill
delegation_triggers:
  - phrase: "refactor"
    confidence: high
  - phrase: "refactoring"
    confidence: high
  - phrase: "clean up"
    confidence: medium
  - phrase: "restructure"
    confidence: high
  - phrase: "legacy code"
    confidence: high
  - phrase: "code smell"
    confidence: high
  - phrase: "extract method"
    confidence: high
  - phrase: "extract class"
    confidence: high
  - phrase: "move method"
    confidence: high
  - phrase: "inline"
    confidence: medium
  - phrase: "rename"
    confidence: medium
  - phrase: "strangler"
    confidence: high
  - phrase: "rewrite"
    confidence: high

# Skill maturity indicators
maturity_levels:
  beginner:
    characteristics:
      - Uses IDE automated refactorings
      - Refactors in small steps
      - Runs tests after changes
    common_mistakes:
      - Refactoring without tests
      - Mixing refactoring with feature work
      - Big bang changes

  intermediate:
    characteristics:
      - Identifies code smells systematically
      - Applies Fowler's catalog
      - Uses characterization tests
    common_mistakes:
      - Over-refactoring
      - Missing scope creep
      - Premature abstraction

  advanced:
    characteristics:
      - Strategic refactoring decisions
      - Strangler fig for systems
      - Knows when not to refactor
    common_mistakes:
      - Assuming team sees same trade-offs
      - Under-documenting decisions
      - Moving too fast for team
