# Debugging Master Collaboration Patterns
# How debugging integrates with other foundational skills

collaboration:
  # Lead role - Debugging Master drives these workflows
  leads:
    - workflow: bug-investigation
      description: Systematic investigation of reported bugs
      involves:
        - test-strategist: Writing regression tests after fix
        - code-quality: Assessing if code structure contributed to bug
        - incident-responder: If bug is production incident
      handoff_points:
        - to: test-strategist
          when: Bug is understood and fixed
          context_to_share: Root cause, edge cases discovered, minimal reproduction
        - to: code-quality
          when: Bug reveals structural code problems
          context_to_share: How code structure enabled the bug
        - to: incident-responder
          when: Bug is causing production impact
          context_to_share: Severity assessment, affected users, mitigation options

    - workflow: root-cause-analysis
      description: Deep investigation to prevent recurrence
      involves:
        - tech-debt-manager: If root cause is accumulated debt
        - system-designer: If root cause is architectural
        - decision-maker: If process/decision changes needed
      handoff_points:
        - to: tech-debt-manager
          when: Root cause is deferred maintenance
          context_to_share: Five Whys analysis, systemic issues discovered
        - to: system-designer
          when: Root cause is design flaw
          context_to_share: Design assumptions that failed, scale/load factors

    - workflow: performance-investigation
      description: Debugging slow or resource-intensive operations
      involves:
        - performance-thinker: Optimization after cause identified
        - system-designer: If architectural changes needed
      handoff_points:
        - to: performance-thinker
          when: Root cause identified, need optimization strategy
          context_to_share: Profiling data, bottleneck location, constraints

  # Support role - Debugging Master assists these workflows
  supports:
    - workflow: code-review
      led_by: code-quality
      contribution: Identifying code that will be hard to debug
      when_called: Reviewer sees patterns that hide bugs

    - workflow: incident-response
      led_by: incident-responder
      contribution: Rapid root cause identification under pressure
      when_called: Production incident needs diagnosis

    - workflow: test-failure-analysis
      led_by: test-strategist
      contribution: Understanding why tests fail intermittently
      when_called: Flaky tests or mysterious test failures

    - workflow: legacy-code-exploration
      led_by: refactoring-guide
      contribution: Understanding how legacy code actually works
      when_called: Documentation missing, code behavior unclear

  # Escalation patterns
  escalations:
    - situation: Bug is in third-party library
      escalate_to: decision-maker
      with_context: Bug analysis, workaround options, vendor contact info
      reason: Decide whether to work around, fork, or replace dependency

    - situation: Bug requires architectural change to fix
      escalate_to: system-designer
      with_context: Root cause, failed design assumptions, scope of change
      reason: Design new solution before implementing

    - situation: Bug is causing ongoing production impact
      escalate_to: incident-responder
      with_context: Severity, affected scope, mitigation options
      reason: Need incident management process, not just debugging

    - situation: Fix would create significant tech debt
      escalate_to: tech-debt-manager
      with_context: Proper fix vs quick fix trade-offs, timeline
      reason: Decide on debt acceptance strategy

    - situation: Bug reveals need for better testing
      escalate_to: test-strategist
      with_context: What tests would have caught this, coverage gaps
      reason: Design test strategy to prevent recurrence

  # Integration contracts
  contracts:
    with_test_strategist:
      debugging_master_provides:
        - Minimal reproducible example (becomes test case)
        - Edge cases discovered during investigation
        - Root cause (what the test should verify)
      test_strategist_provides:
        - Regression test preventing recurrence
        - Test patterns for similar bugs
        - Coverage analysis for affected code
      interface_example: |
        # After debugging session, hand off to test:
        """
        ROOT CAUSE: Race condition in cache invalidation
        MINIMAL REPRO: Two concurrent writes to same key
        EDGE CASES:
          - Empty cache
          - Cache full (eviction happening)
          - Network latency > 100ms
        """

        # Test strategist creates:
        describe('cache invalidation', () => {
          it('handles concurrent writes safely', async () => {
            const [result1, result2] = await Promise.all([
              cache.set('key', 'value1'),
              cache.set('key', 'value2')
            ]);
            // Verify consistent state
          });
        });

    with_incident_responder:
      debugging_master_provides:
        - Rapid diagnosis under pressure
        - Mitigation vs fix assessment
        - Impact scope analysis
      incident_responder_provides:
        - Time/pressure boundaries
        - Communication coordination
        - Rollback decisions
      interface_example: |
        # During incident:
        """
        DEBUGGING: Root cause is null user in session
        MITIGATION: Add null check (5 min, stops bleeding)
        PROPER FIX: Fix session initialization (2 hours)
        RECOMMENDATION: Deploy mitigation, schedule fix
        """

        # Incident responder decides:
        # - Ship mitigation now
        # - Communicate status to stakeholders
        # - Schedule fix for next sprint

    with_code_quality:
      debugging_master_provides:
        - Pain points discovered during debugging
        - Code that hid the bug (poor structure)
        - Suggestions for debuggability
      code_quality_provides:
        - Patterns that prevent bugs
        - Refactoring to improve debuggability
        - Code review focus areas
      interface_example: |
        # Debugging reveals:
        """
        Bug was hard to find because:
        - Error handling scattered across 5 files
        - No logging in critical path
        - State mutation in unexpected places
        """

        # Code quality addresses:
        """
        - Centralize error handling
        - Add logging at decision points
        - Refactor to immutable state pattern
        """

    with_system_designer:
      debugging_master_provides:
        - Failure modes discovered
        - Assumptions that didn't hold
        - Interaction patterns that cause bugs
      system_designer_provides:
        - Design changes to prevent bug class
        - Trade-off analysis for fixes
        - Migration path for architectural fixes
      interface_example: |
        # Debugging reveals:
        """
        Bug caused by: eventual consistency assumption violated
        System assumes: all replicas sync within 1s
        Reality: Cross-region can take 5s under load
        """

        # System designer evaluates:
        """
        Options:
        1. Accept inconsistency (document, handle in UX)
        2. Add causal consistency (complexity + latency)
        3. Reduce replication scope (trade-off availability)
        """

# Prerequisites for using this skill effectively
prerequisites:
  skills: []  # Foundational skill, no prerequisites
  knowledge:
    - Basic programming in any language
    - Understanding of stack traces
    - Familiarity with version control (git)
  tools:
    - Print statement capability
    - Access to logs
    - Optional: Interactive debugger

# When to delegate to this skill
delegation_triggers:
  - phrase: "bug"
    confidence: high
  - phrase: "not working"
    confidence: high
  - phrase: "broken"
    confidence: high
  - phrase: "debug"
    confidence: high
  - phrase: "why is this happening"
    confidence: high
  - phrase: "investigate"
    confidence: medium
  - phrase: "figure out"
    confidence: medium
  - phrase: "unexpected"
    confidence: medium
  - phrase: "should be"
    confidence: medium
  - phrase: "doesn't work"
    confidence: high

# Skill maturity indicators
maturity_levels:
  beginner:
    characteristics:
      - Uses print statements effectively
      - Can reproduce bugs reliably
      - Understands stack traces
    common_mistakes:
      - Debugging without hypothesis
      - Giving up on hard-to-reproduce bugs
      - Fixing symptoms instead of causes

  intermediate:
    characteristics:
      - Uses scientific method consciously
      - Can isolate bugs with binary search
      - Writes regression tests after fixing
    common_mistakes:
      - Not questioning assumptions deeply enough
      - Stopping at first plausible cause
      - Over-relying on debugger

  advanced:
    characteristics:
      - Debugs by reading code (less execution)
      - Sees patterns across unrelated bugs
      - Prevents bugs by recognizing risky patterns
    common_mistakes:
      - Overconfidence in hypothesis
      - Not teaching others the skill
      - Premature optimization of debugging
