# Tech Debt Manager Sharp Edges
# Real gotchas from managing technical debt - the traps that make debt worse

sharp_edges:
  - id: false-debt-diagnosis
    title: False Debt Diagnosis - Old ≠ Bad
    severity: high
    situation: |
      Developer looks at 5-year-old code and says "this is all tech debt, we need
      to rewrite it." The code works. It's stable. It handles edge cases nobody
      remembers. But it "looks old" or uses patterns that aren't trendy anymore.
    why: |
      Age is not debt. Code that works, is tested (by time if not by tests), and
      handles edge cases is valuable. "I would write this differently today" is
      hindsight, not debt. Real debt has measurable interest - slowed development,
      bugs, confusion. Old code that just works is an asset.
    solution: |
      1. Define debt by impact, not aesthetics:
         - Does it slow development? How much?
         - Does it cause bugs? How many?
         - Does it confuse developers? How often?

      2. The stability test:
         - When was it last changed?
         - How often does it cause problems?
         - If rarely touched and rarely breaks, it's not urgent debt

      3. Ask: What's the interest?
         - If you can't quantify interest, it might not be debt
         - "I don't like it" is not interest
         - "Every feature here takes 3x as long" is interest
    symptoms:
      - "This code is so old"
      - "Nobody writes code like this anymore"
      - "We should rewrite this"
      - Code works fine but looks "wrong"
    detection_pattern: "old code|legacy|rewrite|outdated"

  - id: infinite-debt-backlog
    title: Infinite Debt Backlog - The Mountain of Guilt
    severity: medium
    situation: |
      Team created a "tech debt backlog" to track everything that should be improved.
      It now has 300 items. Nobody looks at it. Items from 2 years ago sit untouched.
      Adding new items feels pointless. The backlog creates guilt without action.
    why: |
      A backlog that never shrinks is worse than useless - it's demoralizing. It
      pretends to be management while actually being avoidance. Items rot and become
      irrelevant. The backlog becomes wallpaper, noticed but never acted upon.
    solution: |
      1. Keep the list short and ruthless:
         - Maximum 10-20 items
         - If it's been there 6 months untouched, delete it
         - Only track debt you'll actually address

      2. Use time-based triggers instead:
         - "When we work in module X, address these issues"
         - "If bug count exceeds Y, prioritize cleanup"
         - Remove from backlog, add to area-specific notes

      3. Regular pruning:
         - Monthly: Review and delete stale items
         - Quarterly: Reassess priorities
         - Yearly: Question if backlog itself is useful
    symptoms:
      - Backlog with 100+ items
      - Items older than 1 year
      - Nobody looks at the backlog
      - Adding items feels pointless
    detection_pattern: "debt backlog|technical debt list|cleanup items"

  - id: scope-creep-refactoring
    title: Scope Creep Refactoring - While I'm Here
    severity: high
    situation: |
      Task: Add validation to user form. Developer notices the user module has
      "tech debt." Three weeks later, the PR has 15,000 lines changed across 40 files.
      The validation still isn't done. Review is impossible. Risk is through the roof.
    why: |
      "While I'm here" is the enemy of shipped work. Each improvement seems small,
      but they compound into scope creep. Big changes are riskier, harder to review,
      and harder to roll back. The original task gets lost in the noise.
    solution: |
      1. Timebox opportunistic improvements:
         - "I'll spend 2 hours max on cleanup"
         - If it needs more, create separate task
         - Don't let cleanup exceed feature time

      2. Separate concerns in commits/PRs:
         - PR 1: Pure refactoring (behavior unchanged)
         - PR 2: Feature (on clean code)
         - Each PR is reviewable and reversible

      3. The "necessary vs nice" filter:
         - Necessary: Can't add feature without this cleanup
         - Nice: Could add feature, but code would be messy
         - Nice improvements go in a separate PR or backlog
    symptoms:
      - Feature PRs with massive scope
      - "I also cleaned up some things"
      - Reviews that take days
      - Features that take 3x estimated time
    detection_pattern: "while I'm here|also refactored|cleaned up|improved"

  - id: debt-without-interest
    title: Debt Without Interest - Phantom Debt
    severity: medium
    situation: |
      Team identifies "tech debt" in a module. Nobody has worked in that module
      for 2 years. Nobody plans to. But it sits on the debt backlog, making the
      team feel bad, consuming mental energy, and occasionally triggering debates
      about when to "pay it down."
    why: |
      Debt that isn't charging interest isn't really debt - it's just old code.
      If nobody touches it, nobody pays interest. Spending time on unused code
      has zero ROI. The opportunity cost is real work that could be done instead.
    solution: |
      1. Calculate actual interest:
         - Hours/week spent dealing with this code
         - Bugs/month from this code
         - Developer frustration with this code

      2. If interest is zero or minimal:
         - Remove from active debt list
         - Document for when it's eventually touched
         - Stop worrying about it

      3. Trigger-based management:
         - "When we need to change this, we'll address debt"
         - "If bug rate exceeds X, prioritize cleanup"
         - Until triggered, ignore it
    symptoms:
      - Debt in code nobody touches
      - Discussions about code nobody works in
      - Guilt about unused systems
      - "We should really fix that someday"
    detection_pattern: "we should|someday|nobody touches|old system"

  - id: all-debt-is-equal
    title: All Debt Is Equal - Undifferentiated Backlog
    severity: medium
    situation: |
      Debt backlog lists: "No tests in auth module," "Legacy date formatting,"
      "Old logging library," and "Inconsistent variable names." All are tracked
      the same way. None are prioritized. The auth testing and variable names
      seem equally important (or unimportant).
    why: |
      Not all debt is equal. Security-related debt (no tests in auth) is critical.
      Aesthetic debt (variable names) rarely matters. Treating them equally wastes
      time on low-impact items while ignoring dangerous ones.
    solution: |
      1. Categorize by risk:
         - Critical: Security, data integrity, compliance
         - High: Frequently changed code, high bug rates
         - Medium: Slows development in active areas
         - Low: Aesthetic, rarely touched

      2. Prioritize by impact × frequency:
         - Impact: How bad is the interest when it's paid?
         - Frequency: How often do we pay interest?
         - Score = Impact × Frequency

      3. Separate lists by actionability:
         - Now: Critical + blocking work
         - Opportunistic: Address when in area
         - Someday/Never: Low-priority, may delete
    symptoms:
      - Flat list with no priorities
      - Critical issues mixed with minor ones
      - Low-priority items addressed before high
      - No categorization or severity
    detection_pattern: "tech debt list|all the debt|same priority"

  - id: debt-denial-culture
    title: Debt Denial Culture - "We're Fine"
    severity: critical
    situation: |
      Development is slow. Bugs are frequent. Every feature takes longer than
      expected. But leadership says "we don't have tech debt" because they've
      never tracked it. Or "we'll deal with it later" has been the answer for
      3 years. The system is drowning in invisible interest.
    why: |
      Denial doesn't make debt disappear - it makes it invisible and unmanaged.
      Without acknowledgment, debt can't be communicated, prioritized, or
      strategically addressed. It grows until it causes a crisis.
    solution: |
      1. Make debt visible with metrics:
         - Time per feature (is it growing?)
         - Bug rate (is it increasing?)
         - New developer onboarding time
         - "Estimate miss" rate

      2. Use business language:
         - Not "we have tech debt"
         - Instead "Features cost 3x what they should because..."

      3. Propose specific actions:
         - Not "we need to fix tech debt"
         - Instead "2 weeks on X will reduce feature time by 40%"
    symptoms:
      - "We don't have tech debt"
      - Features always take longer than expected
      - High bug rates accepted as normal
      - No debt discussions in planning
    detection_pattern: "we're fine|no debt|deal with it later"

  - id: premature-debt-payment
    title: Premature Debt Payment - Paying Before Interest
    severity: medium
    situation: |
      Team decides to "pay down debt" in a module that works fine. They spend
      2 weeks refactoring code that was rarely touched. After the work, they
      never need to touch it again. The "debt" wasn't actually costing anything.
    why: |
      Debt payment is an investment. It only pays off if you avoid enough future
      interest. Paying debt in code you don't touch is like paying off a loan
      you're not using - the money could have been spent elsewhere.
    solution: |
      1. Verify interest before payment:
         - How often is this code touched?
         - What problems does it actually cause?
         - What's the expected future work here?

      2. Wait for a trigger:
         - "We need to add feature X here, so let's clean first"
         - "Bug rate is unacceptable, prioritize cleanup"
         - Not "it looks messy, let's refactor"

      3. Calculate ROI:
         - Paydown cost: 2 weeks
         - Expected interest savings: 1 day/month
         - Break-even: 10 months
         - If we won't touch it for 10 months, don't pay yet
    symptoms:
      - Refactoring code that works
      - "Cleanup" in stable areas
      - No business driver for the work
      - Measuring success by code changed, not problems solved
    detection_pattern: "clean up|refactor.*that works|make it nicer"

  - id: rewrite-as-debt-payment
    title: Rewrite as Debt Payment - The Nuclear Option
    severity: high
    situation: |
      Debt has accumulated. Team proposes: "Let's rewrite the whole thing
      from scratch." The rewrite takes 18 months. During that time, the old
      system keeps accumulating fixes that the rewrite doesn't have. The
      rewrite is finally abandoned when it's 60% done.
    why: |
      Rewrites almost always take longer than expected and often fail completely.
      The old code contains years of bug fixes, edge cases, and institutional
      knowledge. Rewrites lose all of that and must rediscover it the hard way.
    solution: |
      1. Default to incremental:
         - Strangler fig pattern: Replace piece by piece
         - Parallel running: New and old side by side
         - Gradual migration: Move features one at a time

      2. If rewrite seems necessary:
         - Why can't you do it incrementally?
         - What's the actual evidence for complete replacement?
         - Who maintains old system during rewrite?

      3. Red flags for rewrites:
         - "It'll only take 6 months" (it won't)
         - "We'll do it right this time" (you'll learn things)
         - "The old code is hopeless" (it has hidden value)
    symptoms:
      - "Let's start fresh"
      - Underestimated rewrite timeline
      - Old system kept running during rewrite
      - Previous rewrite attempts failed
    detection_pattern: "rewrite|from scratch|start fresh|version 2"
