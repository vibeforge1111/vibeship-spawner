# Test Architect Collaboration Model
# How this skill works with other AI memory specialists

prerequisites:
  skills: []
  knowledge:
    - "Basic testing concepts (unit, integration, e2e)"
    - "Assertion patterns and test structure"
    - "Understanding of mocking and test doubles"
    - "Familiarity with pytest or jest"

complementary_skills:
  - skill: api-designer
    relationship: "API contract testing"
    brings: "API contracts, endpoint specifications for testing"

  - skill: performance-hunter
    relationship: "Load and performance testing"
    brings: "Load test design, performance benchmarks"

  - skill: code-reviewer
    relationship: "Test code quality"
    brings: "Code review for test maintainability"

  - skill: observability-sre
    relationship: "Test monitoring"
    brings: "CI/CD metrics, test result dashboards"

  - skill: migration-specialist
    relationship: "Migration testing"
    brings: "Data migration verification tests"

  - skill: chaos-engineer
    relationship: "Resilience testing"
    brings: "Failure injection, chaos experiments"

delegation:
  - trigger: "need load testing"
    delegate_to: performance-hunter
    pattern: parallel
    context: "Endpoints and expected load patterns"
    receive: "Load test results and bottleneck identification"

  - trigger: "need API contracts"
    delegate_to: api-designer
    pattern: sequential
    context: "Services needing contract tests"
    receive: "OpenAPI specs and contract definitions"

  - trigger: "test code review"
    delegate_to: code-reviewer
    pattern: parallel
    context: "Test code for review"
    receive: "Maintainability feedback"

  - trigger: "CI/CD monitoring"
    delegate_to: observability-sre
    pattern: parallel
    context: "Test metrics and failure patterns"
    receive: "Dashboards and alerting"

  - trigger: "failure scenario testing"
    delegate_to: chaos-engineer
    pattern: sequential
    context: "System components and failure modes"
    receive: "Chaos experiment results"

  - trigger: "migration verification"
    delegate_to: migration-specialist
    pattern: sequential
    context: "Before/after data schemas"
    receive: "Migration test plan"

collaboration_patterns:
  sequential:
    - "I design test strategy, then code-reviewer reviews test code"
    - "I write contract tests, then api-designer validates contracts"
    - "I identify test gaps, then chaos-engineer designs failure tests"

  parallel:
    - "I write unit tests while performance-hunter writes load tests"
    - "I run integration tests while observability-sre monitors CI"

  review:
    - "Review chaos-engineer's failure scenarios for test coverage"
    - "Review migration-specialist's data tests for completeness"
    - "Review api-designer's contracts for testability"

cross_domain_insights:
  - domain: formal-verification
    insight: "Property-based testing is lightweight formal methods"
    applies_when: "Testing complex invariants"

  - domain: statistics
    insight: "Flaky tests have confidence intervals, not pass/fail"
    applies_when: "Dealing with probabilistic behavior"

  - domain: economics
    insight: "Test ROI: cost of bug in prod vs cost of writing test"
    applies_when: "Prioritizing what to test"

  - domain: systems-thinking
    insight: "Integration points are where bugs hide"
    applies_when: "Deciding unit vs integration tests"

  - domain: psychology
    insight: "Developers ignore red tests they don't trust"
    applies_when: "Fixing flaky tests urgently"

ecosystem:
  primary_tools:
    - "pytest - Python testing framework"
    - "jest - JavaScript testing framework"
    - "hypothesis - Property-based testing"
    - "pytest-asyncio - Async test support"
    - "coverage.py - Code coverage"

  alternatives:
    - name: unittest
      use_when: "Need standard library only"
      avoid_when: "pytest's fixtures and plugins help"

    - name: vitest
      use_when: "Vite-based project, want speed"
      avoid_when: "Jest ecosystem needed"

    - name: Playwright
      use_when: "E2E browser testing"
      avoid_when: "API-only tests (use direct HTTP)"

    - name: TestContainers
      use_when: "Need real Docker dependencies in tests"
      avoid_when: "Unit tests that should be fast"

    - name: Pact
      use_when: "Contract testing between services"
      avoid_when: "Monolith without service boundaries"

  deprecated:
    - "Manual testing as primary strategy"
    - "Ignoring flaky tests"
    - "100% coverage as goal"
    - "Mocking everything"
    - "Tests without assertions"
