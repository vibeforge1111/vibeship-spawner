# System Designer Collaboration Patterns
# How system design integrates with other foundational skills

collaboration:
  # Lead role - System Designer drives these workflows
  leads:
    - workflow: greenfield-architecture
      description: Designing architecture for new systems or major features
      involves:
        - decision-maker: Making technology and pattern choices
        - tech-debt-manager: Understanding future maintenance implications
        - performance-thinker: Validating performance requirements can be met
      handoff_points:
        - to: decision-maker
          when: Multiple viable architectural approaches exist
          context_to_share: Options with trade-offs, constraints, team capabilities
        - to: code-quality
          when: Architecture defined, need implementation patterns
          context_to_share: Component boundaries, interfaces, contracts

    - workflow: architecture-review
      description: Reviewing existing architecture for improvements
      involves:
        - tech-debt-manager: Identifying accumulated debt
        - performance-thinker: Identifying performance bottlenecks
        - code-quality: Assessing implementation patterns
      handoff_points:
        - to: tech-debt-manager
          when: Review reveals significant debt accumulation
          context_to_share: Debt locations, impact assessment, remediation options
        - to: refactoring-guide
          when: Architecture needs evolution, not replacement
          context_to_share: Target state, migration path, risk areas

    - workflow: scaling-design
      description: Designing systems to handle increased load
      involves:
        - performance-thinker: Identifying bottlenecks and optimization targets
        - decision-maker: Choosing between scaling approaches
      handoff_points:
        - to: performance-thinker
          when: Need to optimize specific components
          context_to_share: Bottleneck analysis, target metrics, constraints
        - to: decision-maker
          when: Choosing between scale-up vs scale-out approaches
          context_to_share: Options with cost/complexity trade-offs

    - workflow: integration-design
      description: Designing how systems communicate with each other
      involves:
        - decision-maker: API style choices (REST, GraphQL, gRPC)
        - code-quality: API design patterns
      handoff_points:
        - to: code-quality
          when: API contract defined, need implementation guidance
          context_to_share: API spec, error handling requirements, versioning strategy

  # Support role - System Designer assists these workflows
  supports:
    - workflow: incident-analysis
      led_by: incident-responder
      contribution: Analyzing architectural factors that contributed to incident
      when_called: Post-incident review reveals architectural issues

    - workflow: tech-debt-prioritization
      led_by: tech-debt-manager
      contribution: Assessing architectural impact of debt items
      when_called: Evaluating which debt affects system architecture

    - workflow: performance-optimization
      led_by: performance-thinker
      contribution: Suggesting architectural changes for performance
      when_called: Optimization requires structural changes, not just tuning

    - workflow: major-refactoring
      led_by: refactoring-guide
      contribution: Defining target architecture for refactoring
      when_called: Refactoring involves component boundaries or integration patterns

  # Escalation patterns
  escalations:
    - situation: Architecture decision has significant cost implications
      escalate_to: decision-maker + external stakeholder
      with_context: Options with cost analysis, recommendation
      reason: Cost decisions require business input

    - situation: Architecture change affects team structure
      escalate_to: external (engineering leadership)
      with_context: Technical rationale, org impact analysis
      reason: Conway's Law - team structure must support architecture

    - situation: Architecture decision requires security expertise
      escalate_to: security specialist (if available)
      with_context: Security requirements, proposed approach, concerns
      reason: Security architecture needs specialized review

    - situation: Performance requirements unclear
      escalate_to: performance-thinker
      with_context: System context, known constraints
      reason: Need performance requirements before architectural decisions

  # Integration contracts
  contracts:
    with_decision_maker:
      system_designer_provides:
        - Architectural options with trade-offs
        - Feasibility assessment for each option
        - Implementation complexity estimates
        - Long-term maintenance implications
      decision_maker_provides:
        - Decision framework application
        - Stakeholder alignment
        - Documented decision with rationale
      interface_example: |
        # System designer presents options:
        """
        CONTEXT: Order service needs to handle 10x current load

        OPTION A: Vertical scaling
        - Upgrade to larger instances
        - Minimal code changes
        - Ceiling: ~5x before diminishing returns
        - Cost: +200% infrastructure

        OPTION B: Horizontal scaling
        - Add read replicas + cache layer
        - Moderate code changes (cache invalidation)
        - Ceiling: Effectively unlimited
        - Cost: +100% infrastructure, +2 weeks dev

        OPTION C: Event-driven redesign
        - Decouple order write from order processing
        - Significant code changes
        - Ceiling: Unlimited, enables real-time features
        - Cost: +50% infrastructure, +6 weeks dev

        RECOMMENDATION: Option B for now, plan Option C for next quarter
        """

        # Decision maker applies framework and documents

    with_performance_thinker:
      system_designer_provides:
        - Architecture context and constraints
        - Component interaction patterns
        - Known bottleneck locations
        - Acceptable latency/throughput targets
      performance_thinker_provides:
        - Performance analysis and profiling
        - Specific optimization recommendations
        - Capacity planning data
        - Performance validation
      interface_example: |
        # System designer provides context:
        """
        SYSTEM: E-commerce checkout flow

        COMPONENTS:
        User → API Gateway → Order Service → Payment Service → Notification

        CURRENT METRICS:
        - P50: 500ms, P99: 2500ms
        - Target: P50 < 200ms, P99 < 1000ms

        CONSTRAINTS:
        - Payment service is external (Stripe)
        - Can't change Order Service DB (shared with reporting)

        SUSPECTED BOTTLENECK: Order Service DB queries
        """

        # Performance thinker profiles and recommends

    with_tech_debt_manager:
      system_designer_provides:
        - Architectural debt assessment
        - Impact of debt on future changes
        - Remediation complexity estimates
      tech_debt_manager_provides:
        - Debt prioritization
        - Paydown timeline recommendations
        - Tracking and visibility
      interface_example: |
        # System designer identifies architectural debt:
        """
        DEBT: Shared database between Order and Inventory services

        IMPACT:
        - Can't scale services independently
        - Schema changes require coordination
        - Lock contention during peak load

        REMEDIATION:
        - Split database (4 weeks, high risk)
        - Add API layer (2 weeks, medium risk)
        - Accept and document (0 weeks, ongoing cost)
        """

        # Tech debt manager adds to registry and prioritizes

    with_code_quality:
      system_designer_provides:
        - Component boundaries and responsibilities
        - Interface contracts between components
        - Error handling expectations
      code_quality_provides:
        - Implementation pattern recommendations
        - Code organization guidance
        - Review criteria for architectural compliance
      interface_example: |
        # System designer defines boundary:
        """
        COMPONENT: PaymentGateway

        RESPONSIBILITY: Abstract payment provider details

        INTERFACE:
        - charge(amount, paymentMethod): PaymentResult
        - refund(transactionId, amount): RefundResult
        - getTransaction(transactionId): Transaction

        ERROR HANDLING:
        - Transient errors: Wrap in RetryableError
        - Permanent errors: Wrap in PaymentError with code
        - Provider down: Throw CircuitBreakerOpen

        INVARIANTS:
        - All amounts in cents (integer)
        - All operations are idempotent with idempotency key
        """

        # Code quality guides implementation

# Prerequisites for using this skill effectively
prerequisites:
  skills: []  # Foundational skill, no prerequisites
  knowledge:
    - Basic understanding of web applications
    - Familiarity with databases (SQL basics)
    - Awareness of client-server architecture
    - Basic networking concepts
  tools:
    - Diagramming tool (Miro, Lucidchart, or even paper)
    - Optional: C4 tooling (Structurizr)

# When to delegate to this skill
delegation_triggers:
  - phrase: "system design"
    confidence: high
  - phrase: "architecture"
    confidence: high
  - phrase: "scalability"
    confidence: high
  - phrase: "how should we structure"
    confidence: high
  - phrase: "microservices"
    confidence: high
  - phrase: "monolith"
    confidence: high
  - phrase: "distributed"
    confidence: high
  - phrase: "high availability"
    confidence: high
  - phrase: "component diagram"
    confidence: medium
  - phrase: "data model"
    confidence: medium
  - phrase: "API design"
    confidence: medium
  - phrase: "integration"
    confidence: medium

# Skill maturity indicators
maturity_levels:
  beginner:
    characteristics:
      - Understands basic client-server architecture
      - Can draw simple system diagrams
      - Knows common patterns (MVC, REST)
    common_mistakes:
      - Over-engineering simple systems
      - Starting with microservices
      - Ignoring data model until late

  intermediate:
    characteristics:
      - Applies four pillars assessment
      - Uses C4 model for documentation
      - Designs for failure modes
    common_mistakes:
      - Designing for scale before proving need
      - Underestimating distributed system complexity
      - Not considering operational requirements

  advanced:
    characteristics:
      - Balances purity with pragmatism
      - Designs for evolution, not perfection
      - Considers organizational factors (Conway's Law)
    common_mistakes:
      - Over-applying patterns from previous contexts
      - Assuming team can handle complexity
      - Not validating assumptions with prototypes

# Key frameworks
frameworks:
  c4_model:
    description: Four levels of architectural diagrams
    levels:
      - context: System in its environment (who uses it?)
      - container: Major deployable units (apps, dbs, caches)
      - component: Major components within a container
      - code: Class/code level (usually skip)
    best_practice: Most systems need only Context and Container

  four_pillars:
    description: Assessment framework for any system
    pillars:
      - scalability: Can it handle growth?
      - availability: Is it operational when needed?
      - reliability: Does it do what it's supposed to?
      - performance: Is it fast enough?

  cap_theorem:
    description: Trade-offs in distributed data stores
    choices:
      - consistency: Every read gets most recent write
      - availability: Every request gets a response
      - partition_tolerance: System works despite network partitions
    reality: You must tolerate partitions, so choose C vs A

