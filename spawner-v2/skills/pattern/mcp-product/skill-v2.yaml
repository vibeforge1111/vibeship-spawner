# MCP Product Design Skill (V2 Format)
# Machine-parsable structure that renders to V1-quality prose

# ============================================================================
# METADATA
# ============================================================================
id: mcp-product
name: MCP Product Design
version: 2.0.0
layer: 3

# ============================================================================
# CLASSIFICATION
# ============================================================================
owns:
  - MCP tool naming and design
  - User experience for AI-assisted tools
  - Error messages and feedback
  - Onboarding and first-run experience
  - Progressive complexity patterns
  - Tool output formatting

does_not_own:
  - MCP protocol implementation → mcp-cloudflare
  - Specific tech stack patterns → relevant stack skills
  - Database design → supabase-backend
  - Authentication flows → nextjs-supabase-auth

tags:
  - mcp
  - product
  - ux
  - dx
  - vibe-coding
  - onboarding
  - developer-experience
  - tool-design

triggers:
  - Designing new MCP tools
  - Improving tool UX or DX
  - Writing error messages
  - Planning tool naming
  - Discussing user onboarding
  - Making tools sticky
  - Vibe coder experience

# ============================================================================
# RELATIONSHIPS
# ============================================================================
pairs_with:
  - mcp-cloudflare
  - typescript-strict

requires: []

handoffs:
  - trigger: cloudflare worker implementation
    to: mcp-cloudflare
    context: User is ready to implement the MCP protocol layer

# ============================================================================
# IDENTITY (Structured)
# ============================================================================
identity:
  role: MCP Product Design specialist who builds tools vibe coders love and experts respect

  core_principles:
    - If Claude needs docs to use your tool, your tool is wrong
    - Quick wins create sticky users
    - Error messages are UX, not debugging
    - Complexity should be opt-in, simplicity is default
    - Explain what you're doing as you do it

  iron_law: >-
    FIRST-CALL VALUE: Every tool must return value on the first call
    without requiring IDs or configuration the user doesn't have yet

# ============================================================================
# PATTERNS (Structured good/bad)
# ============================================================================
patterns:
  - id: magic-first-moment
    name: Magic First Moment
    when: Designing any new MCP tool or improving existing ones
    good:
      description: Users get value in under 60 seconds with no configuration
      code: |
        // schema
        inputSchema: {
          required: [],  // Nothing required!
          properties: {
            idea: { description: "What you want to build" },
            template: { description: "Optional starting point" }
          }
        }

        // handler
        const idea = args.idea || "help me get started";
        const sessionId = args.session_id || generateTempSession();

        return {
          success: true,
          session_id: sessionId,
          what_happened: "I understand you want to build something with...",
          next_steps: ["Tell me more about your idea", "Or pick a template"]
        };
    bad:
      description: Requiring IDs or config before any value is delivered
      code: |
        // schema
        inputSchema: {
          required: ["project_id", "user_id", "action"],
          properties: { ... }
        }

        // handler - never reached for new users
    why:
      - Vibe coders are exploring - they don't have IDs yet
      - First call failure = user assumes tool is broken
      - Generate IDs automatically, persist later if needed

  - id: progressive-disclosure
    name: Progressive Disclosure
    when: Tool has many possible options or configurations
    good:
      description: Simple by default, powerful when needed
      code: |
        // Level 1: Just works
        spawner_validate({ code: "..." })

        // Level 2: When they need more
        spawner_validate({ code: "...", check_types: ["security"] })

        // Level 3: Expert mode
        spawner_validate({ code: "...", check_types: ["security"], strict: true })
    bad:
      description: Exposing all 20 parameters in the schema upfront
      code: |
        inputSchema: {
          required: ["code", "file_path", "project_id", "check_types",
                     "severity_threshold", "auto_fix", "strict", "verbose",
                     "include_suggestions", "format", ...],
          properties: { ... }
        }
    why:
      - 20 parameters overwhelms everyone
      - Users don't know what matters
      - Claude doesn't know what to fill in
      - Advanced options can be documented but not prominent

  - id: explain-as-you-go
    name: Explain As You Go
    when: Any tool that produces results users need to act on
    good:
      description: Every response teaches with context and next steps
      code: |
        return {
          success: true,
          project_id: "abc123",
          what_happened: "Created your SaaS project with Next.js, Supabase, and Stripe",
          what_this_means: "You have a starter with auth, database, and payments ready",
          next_steps: [
            "Run: cd my-saas && npm install",
            "Copy .env.example to .env.local and add your Supabase keys",
            "Run: npm run dev to start at localhost:3000"
          ],
          why_this_stack: "SaaS apps need auth (Supabase), payments (Stripe), fast iteration (Next.js)"
        };
    bad:
      description: Minimal confirmation with no context
      code: |
        return { created: true, id: "abc123" };
    why:
      - Vibe coders learn through usage
      - "It said success but nothing happened" = dead end
      - Every success is a teaching moment

  - id: human-error-messages
    name: Human Error Messages
    when: Any error handling in tools
    good:
      description: Errors tell users what to do, not what failed
      code: |
        return {
          error: "I need to know what code you want me to check",
          what_to_do: "Pass the code content and tell me where it lives",
          example: 'spawner_validate({ code: "your code", file_path: "src/app.tsx" })'
        };
    bad:
      description: Technical errors without human explanation
      code: |
        throw new Error("Zod validation failed: expected string at path 'code', received undefined");
    why:
      - User copy-pastes error to Claude asking "what does this mean?"
      - Accurate isn't helpful - confused users can't fix anything
      - Always include what went wrong, why, and what to try next

  - id: goal-based-naming
    name: Goal-Based Naming
    when: Naming any new MCP tool
    good:
      description: Name tools by what users want to accomplish
      code: |
        spawner_plan      // User wants to plan a project
        spawner_unstick   // User is stuck and needs help
        spawner_remember  // User wants to save a decision
        spawner_context   // User wants to load their project
    bad:
      description: CRUD naming based on database operations
      code: |
        spawner_create_project  // Database thinking
        spawner_get_skills      // Database thinking
        spawner_update_memory   // Database thinking
        spawner_fetch_edges     // Database thinking
    why:
      - Users think in goals, not database operations
      - "I want to plan my project" not "I want to create a project record"
      - Verbs like get/set/fetch/create signal developer tools, not user tools

# ============================================================================
# ANTI-PATTERNS
# ============================================================================
anti_patterns:
  - id: id-before-value
    name: ID Before Value
    description: Requiring IDs or configuration before users get any value
    why:
      - Vibe coders don't have project IDs yet
      - They're exploring, not managing existing data
      - First block = they leave forever
    instead: Make IDs optional, generate them if needed, persist later

  - id: jargon-wall
    name: Jargon Wall
    description: Using technical terms without explanation
    why:
      - "RLS policies" means nothing to someone who started last week
      - "Hydration errors" is gibberish to non-React developers
      - You'll lose them immediately
    instead: Plain language first, technical terms in parentheses

  - id: silent-success
    name: Silent Success
    description: Returning minimal confirmation without context
    why:
      - "{ ok: true }" tells users nothing
      - Did it work? What happened? What next?
      - They're left guessing
    instead: Confirm what happened, show the result, suggest next steps

  - id: all-options-upfront
    name: All Options Upfront
    description: Exposing every parameter in the tool definition
    why:
      - 20 parameters is overwhelming
      - Users don't know what matters
      - Claude doesn't know what to fill in
    instead: Minimal required params, smart defaults for everything else

  - id: crud-naming
    name: CRUD Naming
    description: Naming tools like database operations
    why:
      - "spawner_create_project" is database thinking
      - Users don't think in CRUD
      - They think in goals and workflows
    instead: Name by what users accomplish (plan, remember, unstick)

  - id: raw-error-codes
    name: Raw Error Codes
    description: Returning error codes or stack traces without human explanation
    why:
      - "-32602 Invalid params" helps no one
      - Vibe coders don't know what params are
      - Developers need WHICH param and WHY
    instead: What went wrong, why it might have happened, what to try next

# ============================================================================
# RED FLAGS
# ============================================================================
red_flags:
  - pattern: 'required:.*\[.*".*_id"'
    meaning: Requiring an ID parameter - blocks first-call value
    severity: critical

  - pattern: 'create_|get_|update_|delete_|fetch_|set_'
    meaning: CRUD naming detected - use goal-based names instead
    severity: warning

  - pattern: '{ ok: true }|{ success: true }$'
    meaning: Silent success - add context and next steps
    severity: error

  - pattern: 'Zod validation failed|Invalid params|-32\d{3}'
    meaning: Raw technical error - wrap with human explanation
    severity: error

  - pattern: 'required:.*\[.*,.*,.*,.*\]'
    meaning: Too many required params - most should have defaults
    severity: warning

# ============================================================================
# VERIFICATION
# ============================================================================
verification:
  - check: Can a user with ZERO context get value on first call?
    fail_action: Make IDs optional and generate defaults

  - check: Are all required parameters truly required?
    fail_action: Add sensible defaults for optional params

  - check: Does every error message tell users what to do next?
    fail_action: Add what_to_do and example fields to errors

  - check: Does every success response explain what happened?
    fail_action: Add what_happened and next_steps fields

  - check: Is the tool named for what users accomplish?
    fail_action: Rename from CRUD verbs to goal-based verbs

  - check: Would a non-technical person understand the tool description?
    fail_action: Simplify jargon, use plain language

  - check: Have you tested the "I just installed this" experience?
    fail_action: Run through first-call flow with no prior state

# ============================================================================
# OUTPUT FORMAT
# ============================================================================
output:
  type: narrative
  audience: engineers
  # This skill produces audit reports in V1-style prose
  # Use the renderer template to generate from structured findings
