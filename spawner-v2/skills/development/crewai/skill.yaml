# CrewAI Skill
# Role-based multi-agent orchestration framework

id: crewai
name: CrewAI
version: 1.0.0
layer: 2  # Integration layer

description: |
  Expert in CrewAI - the leading role-based multi-agent framework used by 60% of Fortune 500
  companies. Covers agent design with roles and goals, task definition, crew orchestration,
  process types (sequential, hierarchical, parallel), memory systems, and flows for complex
  workflows. Essential for building collaborative AI agent teams.

owns:
  - Agent definitions (role, goal, backstory)
  - Task design and dependencies
  - Crew orchestration
  - Process types (sequential, hierarchical)
  - Memory configuration
  - Tool integration
  - Flows for complex workflows

pairs_with:
  - langgraph
  - autonomous-agents
  - langfuse
  - structured-output

requires:
  - Python 3.10+
  - crewai package
  - LLM API access

ecosystem:
  primary:
    - CrewAI framework
    - CrewAI Tools
  common_integrations:
    - OpenAI / Anthropic / Ollama
    - SerperDev (search)
    - FileReadTool, DirectoryReadTool
    - Custom tools
  platforms:
    - Python applications
    - FastAPI backends
    - Enterprise deployments

prerequisites:
  - Python proficiency
  - Multi-agent concepts
  - Understanding of delegation

limits:
  - Python-only
  - Best for structured workflows
  - Can be verbose for simple cases
  - Flows are newer feature

tags:
  - crewai
  - multi-agent
  - agents
  - orchestration
  - roles
  - collaborative-ai

triggers:
  - "crewai"
  - "multi-agent team"
  - "agent roles"
  - "crew of agents"
  - "role-based agents"
  - "collaborative agents"

history:
  - version: "1.0.0"
    date: "2025-01"
    changes: "Initial skill covering CrewAI patterns"

contrarian_insights:
  - claim: "More agents means better results"
    counter: "Focused agents with clear roles outperform large unfocused crews"
    evidence: "3-5 well-defined agents beat 10+ generic agents consistently"
  - claim: "Let agents figure out their own approach"
    counter: "Planning before execution produces more consistent results"
    evidence: "CrewAI's planning feature shows 40% improvement in output quality"
  - claim: "CrewAI is just for demos"
    counter: "With Flows, CrewAI handles enterprise-grade workflows"
    evidence: "60% of Fortune 500 companies using CrewAI in production"

identity:
  role: CrewAI Multi-Agent Architect
  personality: |
    You are an expert in designing collaborative AI agent teams with CrewAI. You think
    in terms of roles, responsibilities, and delegation. You design clear agent personas
    with specific expertise, create well-defined tasks with expected outputs, and
    orchestrate crews for optimal collaboration. You know when to use sequential vs
    hierarchical processes.
  expertise:
    - Agent persona design
    - Task decomposition
    - Crew orchestration
    - Process selection
    - Memory configuration
    - Flow design

patterns:
  - name: Basic Crew with YAML Config
    description: Define agents and tasks in YAML (recommended)
    when_to_use: Any CrewAI project
    implementation: |
      # config/agents.yaml
      researcher:
        role: "Senior Research Analyst"
        goal: "Find comprehensive, accurate information on {topic}"
        backstory: |
          You are an expert researcher with years of experience
          in gathering and analyzing information. You're known
          for your thorough and accurate research.
        tools:
          - SerperDevTool
          - WebsiteSearchTool
        verbose: true

      writer:
        role: "Content Writer"
        goal: "Create engaging, well-structured content"
        backstory: |
          You are a skilled writer who transforms research
          into compelling narratives. You focus on clarity
          and engagement.
        verbose: true

      # config/tasks.yaml
      research_task:
        description: |
          Research the topic: {topic}

          Focus on:
          1. Key facts and statistics
          2. Recent developments
          3. Expert opinions
          4. Contrarian viewpoints

          Be thorough and cite sources.
        agent: researcher
        expected_output: |
          A comprehensive research report with:
          - Executive summary
          - Key findings (bulleted)
          - Sources cited

      writing_task:
        description: |
          Using the research provided, write an article about {topic}.

          Requirements:
          - 800-1000 words
          - Engaging introduction
          - Clear structure with headers
          - Actionable conclusion
        agent: writer
        expected_output: "A polished article ready for publication"
        context:
          - research_task  # Uses output from research

      # crew.py
      from crewai import Agent, Task, Crew, Process
      from crewai.project import CrewBase, agent, task, crew

      @CrewBase
      class ContentCrew:
          agents_config = 'config/agents.yaml'
          tasks_config = 'config/tasks.yaml'

          @agent
          def researcher(self) -> Agent:
              return Agent(config=self.agents_config['researcher'])

          @agent
          def writer(self) -> Agent:
              return Agent(config=self.agents_config['writer'])

          @task
          def research_task(self) -> Task:
              return Task(config=self.tasks_config['research_task'])

          @task
          def writing_task(self) -> Task:
              return Task(config=self.tasks_config['writing_task'])

          @crew
          def crew(self) -> Crew:
              return Crew(
                  agents=self.agents,
                  tasks=self.tasks,
                  process=Process.sequential,
                  verbose=True
              )

      # main.py
      crew = ContentCrew()
      result = crew.crew().kickoff(inputs={"topic": "AI Agents in 2025"})

  - name: Hierarchical Process
    description: Manager agent delegates to workers
    when_to_use: Complex tasks needing coordination
    implementation: |
      from crewai import Crew, Process

      # Define specialized agents
      researcher = Agent(
          role="Research Specialist",
          goal="Find accurate information",
          backstory="Expert researcher..."
      )

      analyst = Agent(
          role="Data Analyst",
          goal="Analyze and interpret data",
          backstory="Expert analyst..."
      )

      writer = Agent(
          role="Content Writer",
          goal="Create engaging content",
          backstory="Expert writer..."
      )

      # Hierarchical crew - manager coordinates
      crew = Crew(
          agents=[researcher, analyst, writer],
          tasks=[research_task, analysis_task, writing_task],
          process=Process.hierarchical,
          manager_llm=ChatOpenAI(model="gpt-4o"),  # Manager model
          verbose=True
      )

      # Manager decides:
      # - Which agent handles which task
      # - When to delegate
      # - How to combine results

      result = crew.kickoff()

  - name: Planning Feature
    description: Generate execution plan before running
    when_to_use: Complex workflows needing structure
    implementation: |
      from crewai import Crew, Process

      # Enable planning
      crew = Crew(
          agents=[researcher, writer, reviewer],
          tasks=[research, write, review],
          process=Process.sequential,
          planning=True,  # Enable planning
          planning_llm=ChatOpenAI(model="gpt-4o")  # Planner model
      )

      # With planning enabled:
      # 1. CrewAI generates step-by-step plan
      # 2. Plan is injected into each task
      # 3. Agents see overall structure
      # 4. More consistent results

      result = crew.kickoff()

      # Access the plan
      print(crew.plan)

  - name: Memory Configuration
    description: Enable agent memory for context
    when_to_use: Multi-turn or complex workflows
    implementation: |
      from crewai import Crew

      # Memory types:
      # - Short-term: Within task execution
      # - Long-term: Across executions
      # - Entity: About specific entities

      crew = Crew(
          agents=[...],
          tasks=[...],
          memory=True,  # Enable all memory types
          verbose=True
      )

      # Custom memory config
      from crewai.memory import LongTermMemory, ShortTermMemory

      crew = Crew(
          agents=[...],
          tasks=[...],
          memory=True,
          long_term_memory=LongTermMemory(
              storage=CustomStorage()  # Custom backend
          ),
          short_term_memory=ShortTermMemory(
              storage=CustomStorage()
          ),
          embedder={
              "provider": "openai",
              "config": {"model": "text-embedding-3-small"}
          }
      )

      # Memory helps agents:
      # - Remember previous interactions
      # - Build on past work
      # - Maintain consistency

  - name: Flows for Complex Workflows
    description: Event-driven orchestration with state
    when_to_use: Complex, multi-stage workflows
    implementation: |
      from crewai.flow.flow import Flow, listen, start, and_, or_, router

      class ContentFlow(Flow):
          # State persists across steps
          model_config = {"extra": "allow"}

          @start()
          def gather_requirements(self):
              """First step - gather inputs."""
              self.topic = self.inputs.get("topic", "AI")
              self.style = self.inputs.get("style", "professional")
              return {"topic": self.topic}

          @listen(gather_requirements)
          def research(self, requirements):
              """Research after requirements gathered."""
              research_crew = ResearchCrew()
              result = research_crew.crew().kickoff(
                  inputs={"topic": requirements["topic"]}
              )
              self.research = result.raw
              return result

          @listen(research)
          def write_content(self, research_result):
              """Write after research complete."""
              writing_crew = WritingCrew()
              result = writing_crew.crew().kickoff(
                  inputs={
                      "research": self.research,
                      "style": self.style
                  }
              )
              return result

          @router(write_content)
          def quality_check(self, content):
              """Route based on quality."""
              if self.needs_revision(content):
                  return "revise"
              return "publish"

          @listen("revise")
          def revise_content(self):
              """Revision flow."""
              # Re-run writing with feedback
              pass

          @listen("publish")
          def publish_content(self):
              """Final publishing."""
              return {"status": "published", "content": self.content}

      # Run flow
      flow = ContentFlow()
      result = flow.kickoff(inputs={"topic": "AI Agents"})

  - name: Custom Tools
    description: Create tools for agents
    when_to_use: Agents need external capabilities
    implementation: |
      from crewai.tools import BaseTool
      from pydantic import BaseModel, Field

      # Method 1: Class-based tool
      class SearchInput(BaseModel):
          query: str = Field(..., description="Search query")

      class WebSearchTool(BaseTool):
          name: str = "web_search"
          description: str = "Search the web for information"
          args_schema: type[BaseModel] = SearchInput

          def _run(self, query: str) -> str:
              # Implementation
              results = search_api.search(query)
              return format_results(results)

      # Method 2: Function decorator
      from crewai import tool

      @tool("Database Query")
      def query_database(sql: str) -> str:
          """Execute SQL query and return results."""
          return db.execute(sql)

      # Assign tools to agents
      researcher = Agent(
          role="Researcher",
          goal="Find information",
          backstory="...",
          tools=[WebSearchTool(), query_database]
      )

anti_patterns:
  - name: Vague Agent Roles
    description: Generic roles without clear expertise
    why_bad: |
      Agent doesn't know its specialty.
      Overlapping responsibilities.
      Poor task delegation.
    what_to_do_instead: |
      Be specific:
      - "Senior React Developer" not "Developer"
      - "Financial Analyst specializing in crypto" not "Analyst"
      Include specific skills in backstory.

  - name: Missing Expected Outputs
    description: Tasks without clear expected_output
    why_bad: |
      Agent doesn't know done criteria.
      Inconsistent outputs.
      Hard to chain tasks.
    what_to_do_instead: |
      Always specify expected_output:
      expected_output: |
        A JSON object with:
        - summary: string (100 words max)
        - key_points: list of strings
        - confidence: float 0-1

  - name: Too Many Agents
    description: Creating agent for every small task
    why_bad: |
      Coordination overhead.
      Inconsistent communication.
      Slower execution.
    what_to_do_instead: |
      3-5 agents with clear roles.
      One agent can handle multiple related tasks.
      Use tools instead of agents for simple actions.

  - name: No Task Context
    description: Tasks don't reference previous outputs
    why_bad: |
      Agents work in isolation.
      Lost information between tasks.
      Redundant work.
    what_to_do_instead: |
      Use context in task config:
      writing_task:
        context:
          - research_task
          - analysis_task

handoffs:
  - trigger: "langgraph|state machine|graph"
    to: langgraph
    context: "Need graph-based agent with explicit state"

  - trigger: "observability|tracing"
    to: langfuse
    context: "Need LLM observability"

  - trigger: "structured output|json"
    to: structured-output
    context: "Need structured responses"
