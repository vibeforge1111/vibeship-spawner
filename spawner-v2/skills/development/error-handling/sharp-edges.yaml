# Sharp Edges - Error Handling
version: 1.0.0
skill_id: error-handling

sharp_edges:
  - id: swallowing-errors
    summary: Catching errors and doing nothing
    severity: critical
    situation: |
      Payment fails silently. User thinks payment went through. No
      error logged. Days later, angry user calls.
    why: |
      Empty catch blocks hide failures. You cannot fix what you
      cannot see.
    solution: |
      // WRONG
      try {
        await processPayment(order);
      } catch (e) {
        // Silent failure
      }

      // RIGHT
      try {
        await processPayment(order);
      } catch (error) {
        logger.error({ error, orderId: order.id }, "Payment failed");
        Sentry.captureException(error);
        throw error;
      }
    symptoms:
      - Users report issues not in logs
      - Silent failures
    detection_pattern: null

  - id: exposing-internal-errors
    summary: Showing internal errors to users
    severity: high
    situation: |
      Database connection fails. Error shows to user with internal
      details like IP addresses or table names.
    why: |
      Internal error messages contain sensitive information.
    solution: |
      app.use((err, req, res, next) => {
        logger.error({ error: err.message, stack: err.stack });
        
        if (err instanceof AppError) {
          return res.status(err.statusCode).json({
            error: err.userMessage,
          });
        }
        
        res.status(500).json({
          error: "Something went wrong. Please try again.",
        });
      });
    symptoms:
      - Stack traces in API responses
      - Database errors visible to users
    detection_pattern: null

  - id: async-error-lost
    summary: Unhandled promise rejection
    severity: high
    situation: |
      Async function throws. No await or catch. Promise rejects
      silently or crashes Node.js process.
    why: |
      Async errors need explicit handling. Without await, errors
      are not caught by surrounding try/catch.
    solution: |
      // WRONG
      processOrder(order); // Error lost!

      // RIGHT
      await processOrder(order);

      // Or explicit catch
      processOrder(order).catch(handleError);
    symptoms:
      - UnhandledPromiseRejection warnings
      - App in inconsistent state
    detection_pattern: null

  - id: error-boundary-missing
    summary: React app crashes completely on error
    severity: medium
    situation: |
      User clicks button. Component throws error. Entire app goes
      white - complete crash.
    why: |
      React unmounts the entire tree when a component throws without
      an error boundary.
    solution: |
      <ErrorBoundary fallback={<FallbackUI />}>
        <UserProfile userId={id} />
      </ErrorBoundary>

      // Next.js App Router - error.tsx
      export default function Error({ error, reset }) {
        return (
          <div>
            <h2>Something went wrong</h2>
            <button onClick={reset}>Retry</button>
          </div>
        );
      }
    symptoms:
      - White screen of death
      - Entire app crashes on one error
    detection_pattern: null
