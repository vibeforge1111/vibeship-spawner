# Collaboration - Git Workflow
# How this skill works with other skills

version: 1.0.0
skill_id: git-workflow

prerequisites:
  required: []

  recommended:
    - skill: devops
      reason: "CI/CD integration with git workflows"
      what_to_know:
        - "Branch-based deployments"
        - "Status checks and automated tests"
        - "Release automation"

    - skill: code-review
      reason: "PR-based development workflow"
      what_to_know:
        - "PR best practices"
        - "Review comments and suggestions"
        - "Approval workflows"

  knowledge:
    - "Basic command line proficiency"
    - "Understanding of version control concepts"
    - "Collaboration in team environments"

delegation_triggers:
  - trigger: "user needs CI/CD pipeline setup"
    delegate_to: devops
    context: "Automated testing and deployment on branches"

  - trigger: "user needs code review process"
    delegate_to: code-review
    context: "PR review workflow and standards"

  - trigger: "user needs monorepo management"
    delegate_to: monorepo-management
    context: "Git strategies for monorepos"

  - trigger: "user needs security scanning"
    delegate_to: security-specialist
    context: "Pre-commit security hooks, secret scanning"

receives_context_from:
  - skill: devops
    receives:
      - "Branch naming for environments"
      - "CI/CD integration requirements"
      - "Deployment triggers"

  - skill: code-review
    receives:
      - "PR requirements"
      - "Review approval rules"
      - "Merge policies"

provides_context_to:
  - skill: devops
    provides:
      - "Branch strategy for pipelines"
      - "Tag conventions for releases"
      - "Merge triggers for deployment"

  - skill: code-review
    provides:
      - "PR creation workflow"
      - "Commit history for review"
      - "Branch comparison"

escalation_paths:
  - situation: "Complex merge conflict across many files"
    escalate_to: code-review
    context: "May need pair programming or team discussion"

  - situation: "Need to rewrite git history"
    escalate_to: devops
    context: "Coordinate with team, backup repository"

  - situation: "Sensitive data committed"
    escalate_to: security-specialist
    context: "Secret rotation, history rewriting, incident response"

workflow_integration:
  typical_sequence:
    1:
      step: "Create feature branch"
      skills: [git-workflow]
      output: "feature/TICKET-123-description branch"

    2:
      step: "Develop with atomic commits"
      skills: [git-workflow]
      output: "Series of focused commits"

    3:
      step: "Rebase onto main before PR"
      skills: [git-workflow]
      output: "Clean linear history"

    4:
      step: "Open pull request"
      skills: [git-workflow, code-review]
      output: "PR ready for review"

    5:
      step: "Address review feedback"
      skills: [git-workflow, code-review]
      output: "Updated commits"

    6:
      step: "Merge and deploy"
      skills: [git-workflow, devops]
      output: "Code on main, deployment triggered"

  decision_points:
    - question: "Merge or rebase?"
      guidance: |
        Rebase when:
        - Local work before first push
        - Updating feature branch with main
        - Want linear history

        Merge when:
        - Integrating feature into main
        - Branch is shared with others
        - Need to preserve full history

        Squash merge when:
        - Many small commits in PR
        - Want single commit per feature
        - Using GitHub/GitLab squash option

    - question: "Which branching strategy?"
      guidance: |
        Trunk-Based (recommended for most):
        - Single main branch
        - Short-lived feature branches (< 2 days)
        - Feature flags for incomplete work
        - Best for: CI/CD, frequent deploys

        GitHub Flow:
        - Main branch always deployable
        - Feature branches merged via PR
        - Deploy after merge
        - Best for: Simpler projects, small teams

        GitFlow:
        - main, develop, feature/, release/, hotfix/
        - Parallel development of features
        - Best for: Release-based products, multiple versions

    - question: "Handle large file/binary?"
      guidance: |
        Git LFS (Large File Storage):
        - For files > 100MB
        - Binary assets (images, models)

        Setup:
        git lfs install
        git lfs track "*.psd"
        git add .gitattributes
        git add file.psd
        git commit -m "Add design file"

        Alternative: Don't commit binaries
        - Use asset pipeline
        - Store in S3/GCS
        - Reference by URL/hash

collaboration_patterns:
  with_ci_cd:
    when: "Setting up automated pipelines"
    approach: |
      Branch-based CI/CD:

      # .github/workflows/ci.yml
      on:
        push:
          branches: [main]
        pull_request:
          branches: [main]

      # Protect main branch
      - Require status checks to pass
      - Require PR reviews

      # Deploy on merge to main
      on:
        push:
          branches: [main]
      jobs:
        deploy:
          # ...

  with_code_review:
    when: "PR-based development"
    approach: |
      Clean PR workflow:

      1. Create branch from latest main
         git checkout main
         git pull
         git checkout -b feature/my-feature

      2. Make atomic commits
         git commit -m "feat: add user model"
         git commit -m "test: add user model tests"

      3. Rebase before PR
         git fetch origin
         git rebase origin/main

      4. Push and create PR
         git push -u origin feature/my-feature

      5. Address review feedback
         git commit -m "review: address feedback"
         # Or amend if single change needed
         git commit --amend --no-edit
         git push --force-with-lease

      6. Squash merge (recommended)
         # Via GitHub/GitLab UI

  with_releases:
    when: "Managing releases and versions"
    approach: |
      Tag-based releases:

      # Create annotated tag
      git tag -a v1.2.0 -m "Release version 1.2.0"
      git push origin v1.2.0

      # List tags
      git tag -l "v1.*"

      # Delete tag (if mistake)
      git tag -d v1.2.0
      git push origin :refs/tags/v1.2.0

      # Semantic versioning
      v1.0.0  # MAJOR.MINOR.PATCH
      v1.0.0-beta.1  # Pre-release
      v1.0.0+build.123  # Build metadata

platform_integration:
  github:
    setup: |
      # Clone with SSH (recommended)
      git clone git@github.com:org/repo.git

      # Configure GPG signing (optional)
      git config --global commit.gpgsign true

      # GitHub CLI for PRs
      gh pr create --title "Feature" --body "Description"
      gh pr checkout 123
      gh pr merge --squash
    considerations:
      - "Use branch protection rules"
      - "Enable required reviews"
      - "Set up CODEOWNERS file"
      - "Use GitHub Actions for CI"

  gitlab:
    setup: |
      # Clone
      git clone git@gitlab.com:org/repo.git

      # GitLab CI
      # .gitlab-ci.yml in repo root

      # Merge request via CLI
      glab mr create
      glab mr merge
    considerations:
      - "Configure protected branches"
      - "Use merge request approvals"
      - "Set up CI/CD pipelines"

  pre_commit:
    setup: |
      # Install husky
      npm install husky --save-dev
      npx husky init

      # Pre-commit hook
      # .husky/pre-commit
      #!/bin/sh
      npm run lint
      npm run test

      # Commit message validation
      # .husky/commit-msg
      #!/bin/sh
      npx commitlint --edit $1

      # commitlint.config.js
      module.exports = {
        extends: ['@commitlint/config-conventional']
      };
    considerations:
      - "Keep hooks fast (< 5 seconds)"
      - "Can bypass with --no-verify (emergency only)"
      - "Lint only staged files with lint-staged"

ecosystem:
  primary_tools:
    - "git (command line)"
    - "GitHub/GitLab/Bitbucket (hosting)"
    - "VS Code/JetBrains Git integration"
    - "GitKraken/Sourcetree (GUI)"

  alternatives:
    - name: Mercurial (hg)
      use_when: "Already using hg, simpler model preferred"
      avoid_when: "Need GitHub/GitLab ecosystem"

    - name: SVN
      use_when: "Legacy systems, large binary files"
      avoid_when: "New projects, distributed teams"

  deprecated:
    - "git checkout (use git switch/restore)"
    - "git stash save (use git stash push)"
    - "git reset HEAD (use git restore --staged)"
