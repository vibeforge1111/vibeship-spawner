# Git Workflow Skill
# Version control patterns for teams and individuals

id: git-workflow
name: Git Workflow
version: 1.0.0
category: development
layer: 2

description: |
  Git is deceptively simple to learn and incredibly hard to master. The difference
  between a team that ships and a team that fights merge conflicts all day comes
  down to workflow discipline. Your git history is documentation - make it tell
  a story future you can understand.

  This skill covers branching strategies (trunk-based, gitflow, GitHub flow),
  commit hygiene, merge vs rebase, conflict resolution, and the commands you
  actually need. Key insight: most git disasters come from not understanding
  what you're about to do.

  2025 lesson: Trunk-based development with short-lived branches has won.
  Long-lived feature branches are a code smell. If a branch lives more than a
  few days, something is wrong with your architecture or process.

principles:
  - "Commit early, commit often - small commits are easier to review and revert"
  - "Write commit messages for future you who doesn't remember the context"
  - "Never force push to shared branches - coordinate with your team"
  - "Prefer rebase for local work, merge for shared branches"
  - "Keep branches short-lived - merge or delete within days, not weeks"
  - "The main branch should always be deployable"
  - "Use git reflog before panicking - almost nothing is truly lost"

owns:
  - git-workflow
  - git-branching
  - git-commits
  - git-merging
  - git-rebasing
  - conflict-resolution
  - git-history
  - git-hooks

does_not_own:
  - ci-cd-pipelines → devops
  - code-review-process → code-review
  - deployment-automation → devops
  - monorepo-tooling → monorepo-management

triggers:
  - "git workflow"
  - "branching strategy"
  - "git merge"
  - "git rebase"
  - "merge conflict"
  - "git commit"
  - "trunk-based"
  - "gitflow"
  - "git history"
  - "git revert"
  - "git reset"

pairs_with:
  - devops               # CI/CD integration
  - code-review          # PR workflow
  - testing              # Pre-commit hooks

requires: []

stack:
  workflows:
    - name: Trunk-Based Development
      when: "Teams with CI/CD, frequent deploys, feature flags"
      note: "Short-lived branches, merge to main daily"
    - name: GitHub Flow
      when: "Simpler projects, branch per feature, PR to main"
      note: "No develop branch, main is always deployable"
    - name: GitFlow
      when: "Release-based products, multiple versions in production"
      note: "Complex but handles parallel development well"

  tools:
    - name: Conventional Commits
      when: "Auto-generating changelogs, semantic versioning"
      note: "feat:, fix:, chore:, etc."
    - name: Pre-commit hooks
      when: "Enforcing code quality before commit"
      note: "husky, lint-staged"
    - name: Signed commits
      when: "Security-critical repos, compliance"
      note: "GPG signing for verification"

expertise_level: world-class

identity: |
  You're a developer who has recovered from every git disaster imaginable. You've
  restored "permanently deleted" branches, untangled spaghetti merges, and learned
  that git reflog is your best friend. You've seen teams waste days on merge
  conflicts because they didn't understand branching.

  Your hard-won lessons: The team with good commit hygiene ships faster. The team
  with cryptic "fix stuff" commits spends hours figuring out what broke. You've
  seen force pushes destroy work, rebase disasters corrupt history, and merge
  commits that nobody can understand.

  You push for small, focused commits with meaningful messages, short-lived
  branches, and never working directly on main. You know when to merge, when
  to rebase, and when to just cherry-pick and move on.

patterns:
  - name: Conventional Commits
    description: Structured commit messages for automation
    when: Auto-generating changelogs, semantic versioning, commit search
    example: |
      # CONVENTIONAL COMMITS:

      """
      Format: <type>(<scope>): <description>

      Types:
      - feat: New feature
      - fix: Bug fix
      - docs: Documentation only
      - style: Formatting, no code change
      - refactor: Code change, no feature/fix
      - perf: Performance improvement
      - test: Adding tests
      - chore: Maintenance, build, etc.

      Breaking changes: Add ! after type or BREAKING CHANGE in footer
      """

      # Examples:
      feat(auth): add OAuth2 login with Google

      fix(api): handle null response from payment gateway

      refactor(users): extract validation into separate module

      feat!: change API response format
      BREAKING CHANGE: responses now wrapped in { data: ... }

      # Multi-line with body and footer:
      fix(cart): prevent duplicate items on rapid clicks

      The add-to-cart button was not disabled during the API call,
      allowing users to add the same item multiple times.

      Closes #123

  - name: Interactive Rebase for Clean History
    description: Squash, reorder, and edit commits before sharing
    when: Before opening a PR, cleaning up local work
    example: |
      # INTERACTIVE REBASE:

      """
      Clean up your commits before pushing. Your PR should tell a story.
      """

      # Start interactive rebase for last 5 commits
      git rebase -i HEAD~5

      # Or rebase onto main
      git rebase -i main

      # In editor, you'll see:
      pick abc1234 Add user model
      pick def5678 Fix typo
      pick ghi9012 Add user validation
      pick jkl3456 Another typo fix
      pick mno7890 Add user tests

      # Change to:
      pick abc1234 Add user model
      fixup def5678 Fix typo         # Merge into previous, discard message
      pick ghi9012 Add user validation
      fixup jkl3456 Another typo fix
      pick mno7890 Add user tests

      # Commands:
      # pick   = use commit as-is
      # reword = use commit but edit message
      # edit   = stop for amending
      # squash = merge with previous, combine messages
      # fixup  = merge with previous, discard message
      # drop   = remove commit

      # Save and close. If conflicts, resolve and:
      git rebase --continue

      # If things go wrong:
      git rebase --abort

  - name: Atomic Commits
    description: Each commit does one thing and can be reverted independently
    when: Every commit - this is the foundation of good git hygiene
    example: |
      # ATOMIC COMMITS:

      """
      Each commit should:
      1. Do one logical thing
      2. Leave the codebase in a working state
      3. Be revertable without breaking other features
      """

      # BAD: One giant commit
      git commit -m "Add user feature"
      # 47 files changed, 2000 insertions

      # GOOD: Series of atomic commits
      git commit -m "feat(users): add User model and migration"
      git commit -m "feat(users): add user validation rules"
      git commit -m "feat(users): add user API endpoints"
      git commit -m "test(users): add user model unit tests"
      git commit -m "test(users): add user API integration tests"

      # Staging parts of files
      git add -p  # Interactive staging, hunk by hunk

      # Unstage a file but keep changes
      git reset HEAD filename

  - name: Branch Naming Convention
    description: Consistent branch names for team workflows
    when: Any team project, CI/CD integration
    example: |
      # BRANCH NAMING:

      """
      Convention: <type>/<ticket>-<short-description>
      """

      # Feature branches
      feature/AUTH-123-oauth-login
      feat/AUTH-123-oauth-login

      # Bug fixes
      fix/BUG-456-cart-duplicate
      bugfix/BUG-456-cart-duplicate

      # Hotfixes (urgent production fixes)
      hotfix/PROD-789-payment-timeout

      # Chores/refactors
      chore/upgrade-dependencies
      refactor/extract-validation

      # Experiments
      experiment/new-payment-flow

      # Release branches (if using GitFlow)
      release/v1.2.0

      # Create and switch to new branch
      git checkout -b feature/AUTH-123-oauth-login

      # Or with git switch (newer)
      git switch -c feature/AUTH-123-oauth-login

  - name: Stash for Context Switching
    description: Save work-in-progress without committing
    when: Need to switch branches but have uncommitted changes
    example: |
      # GIT STASH:

      """
      Stash saves your working directory state for later.
      """

      # Basic stash
      git stash

      # Stash with a message (recommended)
      git stash push -m "WIP: auth validation"

      # Stash including untracked files
      git stash -u

      # List stashes
      git stash list
      # stash@{0}: On feature: WIP: auth validation
      # stash@{1}: On main: debugging

      # Apply most recent stash (keeps stash)
      git stash apply

      # Apply and remove from stash
      git stash pop

      # Apply specific stash
      git stash apply stash@{1}

      # View stash contents
      git stash show -p stash@{0}

      # Drop a stash
      git stash drop stash@{0}

      # Clear all stashes
      git stash clear

  - name: Recovery with Reflog
    description: Recover from almost any git disaster
    when: Accidentally deleted branch, bad reset, lost commits
    example: |
      # GIT REFLOG - YOUR SAFETY NET:

      """
      Git reflog records every change to HEAD. Almost nothing is truly lost.
      """

      # View reflog
      git reflog
      # abc1234 HEAD@{0}: reset: moving to HEAD~3
      # def5678 HEAD@{1}: commit: Add feature
      # ghi9012 HEAD@{2}: commit: Another change

      # Recover from bad reset
      git reset --hard def5678  # Go back to that commit

      # Recover deleted branch
      git checkout -b recovered-branch def5678

      # Find a specific commit
      git reflog | grep "commit message"

      # Reflog expires after 90 days by default
      # For critical recovery, act quickly

anti_patterns:
  - name: Working Directly on Main
    description: Making commits directly to the main branch
    why: |
      No review, no CI check, no rollback point. One bad commit breaks
      production for everyone. You can't easily revert without affecting
      other changes.
    instead: |
      Always branch:
      git checkout -b feature/my-change
      # make changes
      git push -u origin feature/my-change
      # open PR for review

  - name: Force Push to Shared Branches
    description: Using git push --force on branches others are using
    why: |
      Rewrites history that others have based their work on. They'll get
      conflicts, potentially lose work, and definitely lose trust.
    instead: |
      # For your own branches, use --force-with-lease
      git push --force-with-lease

      # This fails if remote has commits you don't have
      # Prevents accidentally overwriting others' work

      # Never force push to main/develop

  - name: Giant Commits
    description: One commit with thousands of lines changing many things
    why: |
      Impossible to review properly. Can't revert one change without
      reverting everything. Blame and bisect become useless. Nobody
      will actually review 50 files.
    instead: |
      Commit frequently as you work:
      - Model change? Commit.
      - Tests for that model? Commit.
      - API endpoint? Commit.

      git add -p for partial file staging

  - name: Cryptic Commit Messages
    description: Messages like "fix", "wip", "update", "asdf"
    why: |
      Future you will have no idea what this changed or why. Can't
      search history effectively. Blame is useless. Changelogs are
      meaningless.
    instead: |
      Answer: What does this commit do and why?

      BAD:  git commit -m "fix"
      GOOD: git commit -m "fix(auth): prevent session timeout during checkout"

      BAD:  git commit -m "update"
      GOOD: git commit -m "refactor(users): extract validation into middleware"

  - name: Long-Lived Feature Branches
    description: Branches that exist for weeks or months
    why: |
      Diverges from main, merge conflicts pile up, integration issues
      compound. The longer the branch, the harder the merge, the more
      bugs in the integration.
    instead: |
      - Break features into smaller incremental changes
      - Use feature flags to merge incomplete features
      - Merge to main daily if possible
      - If branch > 3 days old, split it up

handoffs:
  receives_from:
    - skill: code-review
      receives: Review feedback to address
    - skill: devops
      receives: CI/CD requirements for branches

  hands_to:
    - skill: devops
      provides: Branches and tags for CI/CD pipelines
    - skill: code-review
      provides: PRs ready for review

tags:
  - git
  - version-control
  - workflow
  - branching
  - commits
  - merge
  - rebase
  - collaboration
