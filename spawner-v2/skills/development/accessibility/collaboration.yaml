# Collaboration - Accessibility
# How this skill works with other skills

version: 1.0.0
skill_id: accessibility

prerequisites:
  required: []

  recommended:
    - skill: frontend
      reason: "HTML and component architecture knowledge"
      what_to_know:
        - "HTML semantic elements"
        - "DOM structure and manipulation"
        - "Event handling"

    - skill: tailwind-ui
      reason: "Styling for accessible design"
      what_to_know:
        - "Focus state styling"
        - "Color contrast utilities"
        - "Responsive design"

  knowledge:
    - "Basic understanding of disability types"
    - "How screen readers work"
    - "Keyboard navigation principles"

delegation_triggers:
  - trigger: "user needs component implementation"
    delegate_to: frontend
    context: "Accessible component patterns"

  - trigger: "user needs styling system"
    delegate_to: tailwind-ui
    context: "Accessible color and focus styles"

  - trigger: "user needs automated testing setup"
    delegate_to: testing
    context: "axe-core integration"

  - trigger: "user needs legal compliance"
    delegate_to: legal
    context: "WCAG compliance requirements"

receives_from:
  - skill: frontend
    receives:
      - "Component implementations to audit"
      - "Interactive patterns to make accessible"

  - skill: tailwind-ui
    receives:
      - "Design system to evaluate"
      - "Color palette for contrast checking"

provides_context_to:
  - skill: frontend
    provides:
      - "Accessible component patterns"
      - "ARIA requirements"
      - "Keyboard interaction specs"

  - skill: testing
    provides:
      - "Accessibility test requirements"
      - "Manual testing checklist"
      - "axe-core rule configuration"

escalation_paths:
  - situation: "Complex custom widget"
    escalate_to: frontend
    context: "May need architectural changes for accessibility"

  - situation: "Legal compliance questions"
    escalate_to: legal
    context: "WCAG compliance levels and requirements"

  - situation: "Design changes needed for accessibility"
    escalate_to: tailwind-ui
    context: "Color contrast and visual design adjustments"

workflow_integration:
  typical_sequence:
    1:
      step: "Review component design"
      skills: [accessibility]
      output: "Accessibility requirements for component"

    2:
      step: "Choose semantic HTML"
      skills: [accessibility, frontend]
      output: "HTML structure with proper semantics"

    3:
      step: "Add ARIA if needed"
      skills: [accessibility]
      output: "ARIA attributes for custom interactions"

    4:
      step: "Style with focus states"
      skills: [tailwind-ui, accessibility]
      output: "Visible focus indicators, sufficient contrast"

    5:
      step: "Implement keyboard handling"
      skills: [frontend, accessibility]
      output: "Keyboard navigation and interactions"

    6:
      step: "Test with assistive technology"
      skills: [accessibility, testing]
      output: "Verified with screen reader and keyboard"

  decision_points:
    - question: "ARIA or semantic HTML?"
      guidance: |
        Semantic HTML first:
        - Use <button> not <div role="button">
        - Use <nav> not <div role="navigation">
        - Use <dialog> not <div role="dialog">

        ARIA when:
        - HTML doesn't have an equivalent
        - Complex custom widgets
        - Dynamic content announcements

    - question: "Which WCAG level?"
      guidance: |
        Level A: Minimum, baseline
        - ~30 success criteria
        - Basic accessibility

        Level AA: Standard target
        - Includes all of A
        - ~20 additional criteria
        - Most common requirement

        Level AAA: Enhanced
        - Includes all of A and AA
        - ~28 additional criteria
        - Often not required, but good goal

    - question: "How to test accessibility?"
      guidance: |
        1. Automated tools (30% of issues):
           - axe-core, Lighthouse
           - Run on every PR

        2. Keyboard testing (manual):
           - Can you Tab to everything?
           - Is focus visible?
           - Can you activate with Enter/Space?

        3. Screen reader testing (manual):
           - NVDA (Windows, free)
           - VoiceOver (Mac, built-in)
           - Test critical user flows

        4. Zoom testing:
           - 200% zoom
           - Reflow at 400% zoom
           - Text spacing adjustments

collaboration_patterns:
  with_design:
    when: "Creating accessible visual design"
    approach: |
      Accessibility in design:

      1. Color contrast:
         - Text: 4.5:1 ratio (AA)
         - Large text: 3:1 ratio
         - UI components: 3:1 ratio

      2. Don't rely on color alone:
         - Add icons, patterns, text labels
         - Works in grayscale

      3. Focus indicators:
         - Visible focus state for all interactive elements
         - High contrast (3:1 against background)

      4. Touch targets:
         - Minimum 44x44 CSS pixels
         - Spacing between targets

      5. Motion:
         - Respect prefers-reduced-motion
         - Provide pause controls

  with_frontend:
    when: "Building accessible components"
    approach: |
      Component accessibility checklist:

      1. Semantic HTML:
         - Use correct element (button, link, input)
         - Heading hierarchy

      2. Keyboard support:
         - All interactions keyboard accessible
         - Logical tab order
         - Focus management for modals

      3. ARIA when needed:
         - Labels (aria-label, aria-labelledby)
         - States (aria-expanded, aria-pressed)
         - Live regions (aria-live)

      4. Screen reader testing:
         - Proper announcements
         - No redundant information
         - Logical reading order

  with_testing:
    when: "Setting up accessibility testing"
    approach: |
      Testing integration:

      # Vitest/Jest with axe-core
      import { axe, toHaveNoViolations } from 'jest-axe';
      expect.extend(toHaveNoViolations);

      test('has no accessibility violations', async () => {
        const { container } = render(<MyComponent />);
        const results = await axe(container);
        expect(results).toHaveNoViolations();
      });

      # Playwright accessibility testing
      import { test, expect } from '@playwright/test';
      import AxeBuilder from '@axe-core/playwright';

      test('home page accessibility', async ({ page }) => {
        await page.goto('/');
        const results = await new AxeBuilder({ page }).analyze();
        expect(results.violations).toEqual([]);
      });

      # Cypress accessibility testing
      import 'cypress-axe';

      it('has no a11y violations', () => {
        cy.visit('/');
        cy.injectAxe();
        cy.checkA11y();
      });

platform_integration:
  react:
    setup: |
      # Accessible React patterns

      // Fragment for skip link at app root
      function App() {
        return (
          <>
            <a href="#main" className="skip-link">
              Skip to main content
            </a>
            <Header />
            <main id="main" tabIndex={-1}>
              <Routes />
            </main>
            <Footer />
          </>
        );
      }

      // Focus management with useRef
      function Modal({ isOpen, onClose, children }) {
        const closeRef = useRef<HTMLButtonElement>(null);

        useEffect(() => {
          if (isOpen) {
            closeRef.current?.focus();
          }
        }, [isOpen]);

        return (
          <dialog open={isOpen} aria-modal="true">
            <button ref={closeRef} onClick={onClose}>
              Close
            </button>
            {children}
          </dialog>
        );
      }
    considerations:
      - "Use semantic HTML over div soup"
      - "Manage focus in SPAs on route change"
      - "Announce route changes to screen readers"

  vue:
    setup: |
      # Accessible Vue patterns

      <!-- Focus directive -->
      <template>
        <dialog v-if="isOpen" aria-modal="true">
          <button ref="closeBtn" @click="close">Close</button>
          <slot />
        </dialog>
      </template>

      <script setup>
      const closeBtn = ref<HTMLButtonElement>()

      watch(() => props.isOpen, (open) => {
        if (open) {
          nextTick(() => closeBtn.value?.focus())
        }
      })
      </script>

      <!-- Announce route changes -->
      <template>
        <div aria-live="polite" class="sr-only" ref="announcer">
          {{ currentRoute }}
        </div>
      </template>
    considerations:
      - "Handle focus in transitions"
      - "Announce dynamic content changes"
      - "Use :focus-visible for focus styles"

ecosystem:
  primary_tools:
    - "axe-core (automated testing)"
    - "Lighthouse (Chrome DevTools)"
    - "NVDA (Windows screen reader)"
    - "VoiceOver (Mac screen reader)"
    - "Wave (browser extension)"

  alternatives:
    - name: Pa11y
      use_when: "CI/CD integration, command line testing"
      avoid_when: "Need detailed component-level testing"

    - name: Accessibility Insights
      use_when: "Windows, detailed manual testing"
      avoid_when: "Mac-only development"

  deprecated:
    - "JAWS-only testing (test with multiple screen readers)"
    - "Relying solely on automated tools"
