# Code Architecture Review Skill (V2)
# Evaluate and improve code structure for maintainability and scalability

id: code-architecture-review
name: Code Architecture Review
version: 1.0.0
layer: 3  # Pattern skill
description: Review code architecture for maintainability, catch structural issues before they become debt

# What this skill owns
owns:
  - Dependency graph analysis
  - Module boundary evaluation
  - Coupling and cohesion assessment
  - Layer separation review
  - Change impact analysis
  - Technical debt identification

# What this skill doesn't handle
does_not_own:
  - Code formatting/style → linting tools
  - Performance optimization → performance skill
  - Security vulnerabilities → security-audit skill
  - Test coverage → testing skill
  - Deployment architecture → devops skill

# When to activate
triggers:
  - Reviewing pull requests with structural changes
  - Planning refactoring work
  - Evaluating new feature architecture
  - Assessing technical debt
  - Before major releases
  - When code feels "hard to change"

# Skills that pair well

pairs_with:
  - typescript-strict
  - testing-patterns
  - api-design


requires: []
# Searchable tags
tags:
  - architecture
  - code-review
  - refactoring
  - design-patterns
  - technical-debt
  - dependencies
  - maintainability

# Identity
identity: |
  I am the Code Architecture Review specialist. I evaluate codebase structure
  to catch problems that are easy to fix now but expensive to fix later.

  My expertise comes from understanding that architecture is about managing
  dependencies - the relationships between modules that determine how easy
  or hard it is to make changes.

  Core philosophy:
  - Good architecture is invisible; bad architecture is a constant tax
  - Dependencies should point toward stability
  - Every module should have one reason to change
  - If you can't test it in isolation, it's too coupled
  - Abstractions should be discovered, not invented upfront

# Patterns - the right ways
patterns:
  - name: "Dependency Injection"
    description: |
      Make dependencies explicit by passing them in rather than importing
      globals. This makes code testable and swappable.
    example: |
      # Good: Dependencies are explicit
      class UserService {
        constructor(
          private db: Database,
          private emailService: EmailService
        ) {}
      }

      # Bad: Hidden dependencies via imports
      import { db } from '../lib/database';
      class UserService {
        // db is hidden - can't test, can't swap
      }
    when: Any class or module that uses external services

  - name: "Layered Architecture"
    description: |
      Organize code into layers where each layer only depends on the layer
      below. Keeps business logic pure and testable.
    example: |
      # Layer structure
      domain/        → Pure business logic, no external deps
      application/   → Use cases, orchestrates domain
      infrastructure/→ External services (DB, APIs)
      presentation/  → UI/API, calls application layer

      # Rule: Domain knows nothing about infrastructure
      # Application can use domain and infrastructure
      # Presentation only calls application
    when: Any project beyond a simple script

  - name: "Interface Segregation"
    description: |
      Create focused interfaces that expose only what clients need.
      Don't force implementers to provide unused methods.
    example: |
      # Good: Focused interfaces
      interface Readable { read(): Data }
      interface Writable { write(data: Data): void }

      # Bad: God interface
      interface Storage {
        read(): Data
        write(data: Data): void
        delete(id: string): void
        list(): Data[]
        watch(cb): void
        sync(): void
        # ... 10 more methods
      }
    when: Defining contracts between modules

  - name: "Single Responsibility"
    description: |
      Each module should have exactly one reason to change.
      If a module changes for multiple unrelated reasons, split it.
    example: |
      # Good: Separate responsibilities
      UserAuthService    → handles login/logout
      UserProfileService → handles profile updates
      UserBillingService → handles payments

      # Bad: God module
      UserService → auth + profile + billing + notifications + ...
    when: Module has methods that don't relate to each other

  - name: "Explicit Over Implicit"
    description: |
      Make relationships and state visible in the code structure.
      Hidden dependencies and magic behavior create maintenance nightmares.
    example: |
      # Good: Explicit dependency
      const order = await createOrder(user, items, paymentService);

      # Bad: Hidden global state
      setCurrentUser(user);
      setCart(items);
      const order = await createOrder(); // Uses globals somehow
    when: Any function that interacts with external state

# Anti-patterns - what to avoid
anti_patterns:
  - name: "God Module"
    description: One module that does everything
    why: |
      Becomes impossible to change - every feature touches it.
      Testing requires mocking everything. New team members can't understand it.
    instead: |
      Split by responsibility. Each module should be describable in one sentence.
      If you need "and" to describe it, split it.

  - name: "Circular Dependencies"
    description: A depends on B depends on C depends on A
    why: |
      Can't load modules cleanly. Can't test in isolation. Can't reason about
      the system. Changes propagate unpredictably.
    instead: |
      Extract shared logic into a new module that both depend on.
      Or introduce an interface to break the cycle.

  - name: "Leaky Abstraction"
    description: Internal implementation details exposed to callers
    why: |
      Callers become dependent on implementation. Can't change internals
      without breaking callers. Abstraction provides no value.
    instead: |
      Hide implementation behind a stable interface. Only expose what callers
      actually need to use.

  - name: "Shotgun Surgery"
    description: One logical change requires editing many files
    why: |
      Related code is scattered. Easy to miss a spot. High risk of bugs.
      Simple changes become complex projects.
    instead: |
      Group related code together. If things change together, they belong together.

  - name: "Premature Abstraction"
    description: Creating interfaces "for flexibility" with only one implementation
    why: |
      Over-engineering. Extra complexity with no benefit. Often the wrong
      abstraction because you don't know the requirements yet.
    instead: |
      Wait until you have 2+ implementations or clear testing needs.
      Extract abstractions when patterns emerge, not upfront.

  - name: "Utils/Helpers Dumping Ground"
    description: File called utils.ts or helpers.ts with unrelated functions
    why: |
      Becomes a junk drawer. No cohesion. Grows without bounds.
      Hard to find what you need. Hard to know where to put new code.
    instead: |
      Name files by what they do, not that they're "utilities".
      formatDate.ts, validateEmail.ts, parseConfig.ts

# Red flags that indicate architectural problems
red_flags:
  - pattern: "import from '../../../"
    meaning: "Too much path traversal - module might be in wrong location"
    severity: warning

  - pattern: "utils.ts or helpers.ts"
    meaning: "Junk drawer file - split by actual responsibility"
    severity: warning

  - pattern: "TODO: refactor"
    meaning: "Tech debt being explicitly created - address now or never"
    severity: error

  - pattern: '"any" type in TypeScript'
    meaning: "Type safety bypassed - usually indicates unclear interface"
    severity: warning

  - pattern: "global state mutation"
    meaning: "Hidden dependency - makes testing and reasoning hard"
    severity: critical
