# Security Sharp Edges
# The vulnerabilities that destroy companies - and how to prevent them

sharp_edges:
  - id: sql-injection-string-concat
    summary: Building SQL queries with string concatenation
    severity: critical
    situation: |
      "SELECT * FROM users WHERE id = " + userId. Attacker sends
      "1; DROP TABLE users; --". Database gone. Company gone.
    why: |
      String concatenation treats user input as SQL code. Attackers can inject
      arbitrary SQL commands. This is the #1 way databases get compromised.
      Parameterized queries exist specifically to prevent this.
    solution: |
      # Never concatenate:
      ```typescript
      // BAD - SQL injection
      const query = `SELECT * FROM users WHERE id = ${userId}`;

      // GOOD - Parameterized query
      const { data } = await supabase
        .from('users')
        .select('*')
        .eq('id', userId);

      // GOOD - Parameterized with raw SQL
      const result = await db.query(
        'SELECT * FROM users WHERE id = $1',
        [userId]
      );
      ```

      # ORMs are safer:
      Supabase, Prisma, Drizzle all parameterize by default
      Only danger is raw SQL queries

      # Test yourself:
      Try inputting: ' OR '1'='1
      If it works, you're vulnerable
    symptoms:
      - String concatenation in SQL
      - Template literals with user input in queries
      - Raw SQL queries with variables
    detection_pattern: "SELECT.*\\$\\{|INSERT.*\\$\\{|UPDATE.*\\$\\{|DELETE.*\\$\\{"

  - id: xss-unescaped-output
    summary: Rendering user input without escaping
    severity: critical
    situation: |
      User submits comment with <script>alert('xss')</script>. Other users view
      the comment. Script executes in their browsers. Attacker steals sessions.
    why: |
      User input in HTML can include JavaScript. If you render it unescaped,
      the browser executes it. XSS allows session hijacking, defacement, and
      worse. React escapes by default, but dangerouslySetInnerHTML bypasses it.
    solution: |
      # React escapes by default:
      ```typescript
      // SAFE - React escapes this
      return <div>{userInput}</div>;

      // DANGEROUS - Bypasses escaping
      return <div dangerouslySetInnerHTML={{ __html: userInput }} />;
      ```

      # If you must render HTML:
      ```typescript
      import DOMPurify from 'dompurify';
      const clean = DOMPurify.sanitize(userInput);
      return <div dangerouslySetInnerHTML={{ __html: clean }} />;
      ```

      # URLs also need checking:
      ```typescript
      // BAD - javascript: URLs execute code
      <a href={userUrl}>Link</a>

      // GOOD - Validate URL protocol
      const safeUrl = userUrl.startsWith('https://') ? userUrl : '#';
      ```
    symptoms:
      - dangerouslySetInnerHTML with user input
      - innerHTML assignment
      - User input in href without validation
    detection_pattern: "dangerouslySetInnerHTML.*\\{.*__html.*[^sanitize]"

  - id: secrets-in-code
    summary: Hardcoding API keys, passwords, or secrets in source code
    severity: critical
    situation: |
      API key in JavaScript file. Pushed to GitHub. Bot scrapes it in seconds.
      AWS bill: $50,000. Or database password exposed. Full breach.
    why: |
      Code is not secret. It goes to version control, build systems, browsers.
      Hardcoded secrets become public secrets. Bots constantly scan for them.
    solution: |
      # Never in code:
      ```typescript
      // BAD
      const API_KEY = 'sk_live_abc123';

      // GOOD
      const API_KEY = process.env.API_KEY;
      ```

      # For client-side:
      Only use publishable/public keys
      NEXT_PUBLIC_ prefix = exposed to client

      # Environment structure:
      - .env.local for development (gitignored)
      - Environment variables in hosting (Vercel, etc.)
      - Never commit .env files with secrets

      # If you already committed a secret:
      - Revoke it immediately
      - Rotate to new secret
      - It's already compromised
    symptoms:
      - API keys in JavaScript/TypeScript files
      - Passwords in config files
      - .env files in git
    detection_pattern: "sk_live_|sk_test_|password.*=.*['\"][^'\"]{8,}['\"]|api_key.*=.*['\"][^'\"]{16,}['\"]"

  - id: csrf-missing-protection
    summary: State-changing operations without CSRF protection
    severity: high
    situation: |
      User logged in to your app. Visits malicious site. Site submits form to
      your API. Browser sends auth cookie. Action executes as user.
    why: |
      Browsers send cookies automatically. Malicious sites can trigger requests
      to your origin. Without CSRF protection, any logged-in user can be tricked
      into taking actions.
    solution: |
      # For same-origin APIs:
      SameSite=Strict cookies prevent CSRF
      ```typescript
      res.setHeader('Set-Cookie', 'session=xxx; HttpOnly; Secure; SameSite=Strict');
      ```

      # For cross-origin APIs:
      Use tokens in headers (not cookies)
      ```typescript
      // Client sends Authorization header
      fetch('/api/action', {
        headers: { Authorization: `Bearer ${token}` }
      });
      ```

      # Check Origin header:
      ```typescript
      if (req.headers.origin !== 'https://yoursite.com') {
        return res.status(403).json({ error: 'Invalid origin' });
      }
      ```

      # Mutating operations:
      Use POST/PUT/DELETE, not GET
      GET requests are easier to trigger
    symptoms:
      - State-changing GET requests
      - Cookies without SameSite
      - No origin checking
    detection_pattern: null

  - id: insecure-direct-object-reference
    summary: Not verifying user owns the resource they're accessing
    severity: high
    situation: |
      GET /api/invoice/123. Returns invoice. User changes to /api/invoice/124.
      Returns someone else's invoice. Full data breach.
    why: |
      Numeric IDs are guessable. Users will try changing them. If you only check
      authentication (who they are) but not authorization (what they can access),
      they can access anything.
    solution: |
      # Always check ownership:
      ```typescript
      // BAD - Only checks authentication
      const invoice = await getInvoice(invoiceId);
      return invoice;

      // GOOD - Checks authorization
      const invoice = await getInvoice(invoiceId);
      if (invoice.userId !== currentUser.id) {
        throw new Error('Unauthorized');
      }
      return invoice;
      ```

      # Even better - filter in query:
      ```typescript
      const invoice = await db.invoices
        .where({ id: invoiceId, userId: currentUser.id })
        .first();
      if (!invoice) throw new Error('Not found');
      ```

      # Use UUIDs instead of sequential IDs:
      Harder to guess, though still need auth checks
    symptoms:
      - Fetching by ID without ownership check
      - Sequential IDs in URLs
      - If I change the ID, I see other users' data
    detection_pattern: null

  - id: missing-rate-limiting
    summary: No rate limiting on sensitive endpoints
    severity: high
    situation: |
      Login endpoint. Attacker sends 10,000 password attempts per second.
      Eventually guesses password. Account compromised.
    why: |
      Without rate limiting, attackers can brute force passwords, scrape data,
      or DoS your service. Rate limiting is essential for login, registration,
      password reset, and any expensive operation.
    solution: |
      # Critical endpoints to rate limit:
      - Login: 5 attempts per minute
      - Registration: 3 per hour per IP
      - Password reset: 3 per hour
      - Any expensive operation

      # Implementation with Upstash:
      ```typescript
      import { Ratelimit } from '@upstash/ratelimit';

      const ratelimit = new Ratelimit({
        limiter: Ratelimit.slidingWindow(5, '1m'),
      });

      const { success } = await ratelimit.limit(ip);
      if (!success) {
        return res.status(429).json({ error: 'Too many requests' });
      }
      ```

      # Consider:
      - Per-IP limiting
      - Per-user limiting
      - Progressive delays
      - CAPTCHA after failures
    symptoms:
      - Login with no rate limiting
      - Password reset with no limiting
      - Expensive APIs without protection
    detection_pattern: null

  - id: missing-security-headers
    summary: Not setting security headers
    severity: medium
    situation: |
      No Content-Security-Policy. XSS vulnerability is exploited. No X-Frame-Options.
      Site is clickjacked. Missing headers make attacks easier.
    why: |
      Security headers tell browsers how to behave. They prevent many attacks
      by default. Missing headers means the browser allows risky behavior.
    solution: |
      # Essential headers:
      ```typescript
      // next.config.js
      const securityHeaders = [
        {
          key: 'X-Content-Type-Options',
          value: 'nosniff',
        },
        {
          key: 'X-Frame-Options',
          value: 'DENY',
        },
        {
          key: 'X-XSS-Protection',
          value: '1; mode=block',
        },
        {
          key: 'Strict-Transport-Security',
          value: 'max-age=31536000; includeSubDomains',
        },
        {
          key: 'Content-Security-Policy',
          value: "default-src 'self'; script-src 'self'",
        },
      ];
      ```

      # Test your headers:
      https://securityheaders.com
    symptoms:
      - No security headers set
      - Site can be iframed
      - No HSTS
    detection_pattern: null

  - id: jwt-none-algorithm
    summary: Not validating JWT algorithm
    severity: critical
    situation: |
      JWT signed with RS256. Attacker changes algorithm to "none" in header.
      Server accepts unsigned token. Attacker forges any identity.
    why: |
      JWT "none" algorithm vulnerability is well-known. Libraries sometimes
      accept "none" by default. Attackers can change the alg header and
      forge tokens.
    solution: |
      # Always specify algorithm:
      ```typescript
      import jwt from 'jsonwebtoken';

      // BAD - Accepts any algorithm
      jwt.verify(token, secret);

      // GOOD - Explicitly specify algorithm
      jwt.verify(token, secret, { algorithms: ['HS256'] });
      ```

      # For RS256:
      ```typescript
      jwt.verify(token, publicKey, { algorithms: ['RS256'] });
      ```

      # Never accept:
      - "none" algorithm
      - Algorithm from token header
      - Algorithm negotiation
    symptoms:
      - jwt.verify without algorithms option
      - Token algorithm not validated
      - '"none" algorithm accepted'
    detection_pattern: "jwt\\.verify.*(?!algorithms)"

  - id: path-traversal
    summary: User input in file paths without sanitization
    severity: critical
    situation: |
      Download endpoint: /download?file=report.pdf. Attacker sends
      file=../../../etc/passwd. Server returns system file.
    why: |
      "../" in paths traverses up directories. Without sanitization, attackers
      can read any file on the system. This includes configuration files,
      source code, and sensitive data.
    solution: |
      # Never use user input directly in paths:
      ```typescript
      // BAD
      const filePath = `./uploads/${req.query.file}`;

      // GOOD - Validate against whitelist
      const allowedFiles = ['report.pdf', 'invoice.pdf'];
      if (!allowedFiles.includes(req.query.file)) {
        throw new Error('Invalid file');
      }

      // GOOD - Use path.basename
      import path from 'path';
      const fileName = path.basename(req.query.file);
      const filePath = path.join('./uploads', fileName);
      ```

      # path.basename removes directories:
      ../../../etc/passwd → passwd

      # Best: Use IDs, not filenames:
      /download?id=123 → lookup in database
    symptoms:
      - User input in file paths
      - No path sanitization
      - File downloads by filename
    detection_pattern: "path\\.join.*req\\.|path\\.resolve.*req\\."

  - id: mass-assignment
    summary: Accepting all fields from user input into database
    severity: high
    situation: |
      Update profile endpoint. User sends { name: 'John', isAdmin: true }.
      Server spreads into database update. User is now admin.
    why: |
      Spreading request body directly into database updates lets users set
      any field, including ones you didn't intend (isAdmin, balance, role).
      This is called mass assignment.
    solution: |
      # Whitelist fields:
      ```typescript
      // BAD - Mass assignment vulnerability
      await db.users.update({
        where: { id: userId },
        data: req.body,  // User controls all fields!
      });

      // GOOD - Explicitly pick fields
      const { name, email, bio } = req.body;
      await db.users.update({
        where: { id: userId },
        data: { name, email, bio },  // Only allowed fields
      });
      ```

      # With Zod:
      ```typescript
      const UpdateSchema = z.object({
        name: z.string().optional(),
        email: z.string().email().optional(),
        bio: z.string().optional(),
      });
      const data = UpdateSchema.parse(req.body);
      await db.users.update({ where: { id }, data });
      ```
    symptoms:
      - Spreading request body into updates
      - No field whitelisting
      - Any field can be updated
    detection_pattern: "update.*data:.*req\\.body|create.*data:.*req\\.body"

  - id: http-only-cookie-missing
    summary: Session cookies accessible to JavaScript
    severity: high
    situation: |
      Session cookie without HttpOnly. XSS vulnerability found. Attacker steals
      session cookies via JavaScript. Full session hijacking.
    why: |
      Without HttpOnly, JavaScript can read cookies. XSS becomes session hijacking.
      HttpOnly cookies can only be read by the server, limiting XSS damage.
    solution: |
      # Always use HttpOnly for sessions:
      ```typescript
      res.setHeader('Set-Cookie', [
        'session=xxx; HttpOnly; Secure; SameSite=Strict',
      ]);

      // With next-auth or similar:
      // HttpOnly is typically default
      ```

      # Cookie flags:
      - HttpOnly: Not accessible to JavaScript
      - Secure: Only sent over HTTPS
      - SameSite=Strict: Not sent cross-origin
      - Path=/: Scope limitation

      # For authentication tokens:
      Store in HttpOnly cookies, not localStorage
      localStorage is always accessible to JS
    symptoms:
      - Session cookie without HttpOnly
      - Token in localStorage
      - document.cookie contains session
    detection_pattern: "Set-Cookie.*(?!.*HttpOnly)"

# Symptom Index - Map error messages and symptoms to solutions
symptom_index:
  # SQL Injection symptoms
  - symptom: "syntax error at or near"
    matches: sql-injection-string-concat
    context: Often indicates SQL injection vulnerability when user input causes syntax errors

  - symptom: "unterminated quoted string"
    matches: sql-injection-string-concat
    context: User input containing quotes breaking SQL syntax

  - symptom: "ERROR 1064 (42000)"
    matches: sql-injection-string-concat
    context: MySQL syntax error, often from unescaped user input

  - symptom: "pg_query(): Query failed"
    matches: sql-injection-string-concat
    context: PostgreSQL query failure, check for string concatenation

  # XSS symptoms
  - symptom: "script execution blocked"
    matches: xss-unescaped-output
    context: CSP blocking inline scripts, but underlying XSS vulnerability exists

  - symptom: "Refused to execute inline script"
    matches: xss-unescaped-output
    context: Browser CSP working, but code has XSS vulnerability

  - symptom: "unsafe-inline"
    matches: xss-unescaped-output
    context: CSP requires unsafe-inline, indicating potential XSS risk

  # Secrets exposure symptoms
  - symptom: "Invalid API key"
    matches: secrets-in-code
    context: API key may be hardcoded and rotated/invalidated

  - symptom: "API key expired"
    matches: secrets-in-code
    context: Hardcoded key was rotated, now broken

  - symptom: "Detected secrets in commit"
    matches: secrets-in-code
    context: Git hooks or CI caught hardcoded secrets

  - symptom: "GitGuardian alert"
    matches: secrets-in-code
    context: Secret scanning detected exposed credentials

  # JWT symptoms
  - symptom: "jwt malformed"
    matches: jwt-none-algorithm
    context: Check if accepting invalid algorithms

  - symptom: "invalid algorithm"
    matches: jwt-none-algorithm
    context: Algorithm validation may be misconfigured

  - symptom: "invalid signature"
    matches: jwt-none-algorithm
    context: Token signature validation - ensure algorithm is pinned

  # CSRF symptoms
  - symptom: "CSRF token mismatch"
    matches: csrf-missing-protection
    context: Good - CSRF protection is working, token handling issue

  - symptom: "Request blocked by CORS"
    matches: csrf-missing-protection
    context: Cross-origin issue, check CSRF protection

  # Rate limiting symptoms
  - symptom: "Too many requests"
    matches: missing-rate-limiting
    context: Rate limiting working but may be too aggressive

  - symptom: "429 Too Many Requests"
    matches: missing-rate-limiting
    context: Rate limiting active, adjust thresholds if needed

  - symptom: "Account locked"
    matches: missing-rate-limiting
    context: Brute force protection triggered

  # IDOR symptoms
  - symptom: "You don't have permission"
    matches: insecure-direct-object-reference
    context: Good - authorization check working

  - symptom: "unauthorized access attempt"
    matches: insecure-direct-object-reference
    context: Authorization logging working, review access patterns

  # Path traversal symptoms
  - symptom: "ENOENT: no such file or directory"
    matches: path-traversal
    context: File path manipulation, check for path traversal

  - symptom: "Path contains invalid characters"
    matches: path-traversal
    context: Good - path validation catching malicious input

  # Cookie symptoms
  - symptom: "Cookie not sent"
    matches: http-only-cookie-missing
    context: Check SameSite and Secure flags

  - symptom: "third-party cookie blocked"
    matches: http-only-cookie-missing
    context: SameSite policy preventing cookie, review cookie settings

# Red Flags - Critical patterns that indicate immediate security risk
red_flags:
  - id: eval-user-input
    pattern: "eval\\(.*req\\.|eval\\(.*user|eval\\(.*input"
    severity: critical
    message: "CRITICAL: eval() with user input enables Remote Code Execution"
    action: "Remove eval() immediately. Use JSON.parse() for data, Function constructor with strict sandboxing if code execution required"

  - id: exec-user-input
    pattern: "exec\\(.*req\\.|child_process.*req\\.|spawn\\(.*req\\."
    severity: critical
    message: "CRITICAL: Command injection vulnerability - user input in shell command"
    action: "Never pass user input to shell. Use parameterized commands or safe APIs"

  - id: sql-concat-login
    pattern: "SELECT.*FROM.*users.*WHERE.*(password|email).*\\$\\{"
    severity: critical
    message: "CRITICAL: SQL injection in authentication - account takeover possible"
    action: "Use parameterized queries immediately. Review all auth queries"

  - id: hardcoded-production-secrets
    pattern: "sk_live_|pk_live_|prod.*secret.*=.*['\"][a-zA-Z0-9]"
    severity: critical
    message: "CRITICAL: Production secrets in code - likely already compromised"
    action: "Revoke and rotate immediately. Move to environment variables. Assume breach"

  - id: disabled-ssl-verification
    pattern: "rejectUnauthorized.*false|NODE_TLS_REJECT_UNAUTHORIZED.*0"
    severity: critical
    message: "CRITICAL: SSL verification disabled - man-in-the-middle attacks possible"
    action: "Never disable SSL verification. Fix certificate issues properly"

  - id: password-in-url
    pattern: "https?://[^:]+:[^@]+@"
    severity: high
    message: "HIGH: Credentials in URL - logged in server logs, browser history, referrer"
    action: "Move credentials to headers or request body. Rotate exposed credentials"

  - id: admin-bypass-comment
    pattern: "TODO.*auth|FIXME.*security|skip.*auth.*for.*now"
    severity: high
    message: "HIGH: Security bypass in code comments - likely vulnerable"
    action: "Implement proper authentication. Remove bypass code"

  - id: wildcard-cors
    pattern: "Access-Control-Allow-Origin.*\\*|cors.*origin.*true"
    severity: high
    message: "HIGH: Wildcard CORS allows any origin - CSRF and data theft possible"
    action: "Specify allowed origins explicitly. Never use * with credentials"

  - id: jwt-secret-weak
    pattern: "jwt.*secret.*=.*(secret|password|123|test|dev)"
    severity: high
    message: "HIGH: Weak JWT secret - tokens can be forged"
    action: "Use cryptographically random secret (32+ bytes). Store in environment"

  - id: debug-mode-production
    pattern: "DEBUG.*=.*true|NODE_ENV.*development.*production"
    severity: medium
    message: "MEDIUM: Debug mode may be enabled in production - information disclosure"
    action: "Ensure DEBUG is false and NODE_ENV is 'production' in production"

  - id: console-log-sensitive
    pattern: "console\\.log.*(password|token|secret|key|credential)"
    severity: medium
    message: "MEDIUM: Sensitive data in console.log - may appear in logs"
    action: "Remove sensitive data logging. Use structured logging with redaction"

  - id: unsafe-regex
    pattern: "(\\+|\\*)\\+|\\{\\d+,\\d*\\}\\+|\\(\\?=.*\\+\\)"
    severity: medium
    message: "MEDIUM: Potentially unsafe regex - ReDoS vulnerability"
    action: "Review regex for catastrophic backtracking. Use regex timeout or safe-regex library"
