id: websocket-realtime-collaboration
skill: websocket-realtime
version: 1.0.0

# ============================================================================
# RECEIVES FROM (Who delegates TO this skill)
# ============================================================================
receives_from:
  - skill: backend
    context: "Backend needs real-time features"
    receives:
      - "Feature requirements (chat, notifications, live updates)"
      - "User authentication system"
      - "Scale expectations"
    provides: "WebSocket server implementation with proper patterns"

  - skill: frontend
    context: "Frontend needs live updates"
    receives:
      - "UI update requirements"
      - "User experience needs"
      - "Offline handling requirements"
    provides: "Client-side WebSocket integration with reconnection"

  - skill: state-management
    context: "Real-time state synchronization needed"
    receives:
      - "State structure"
      - "Update patterns"
      - "Conflict resolution needs"
    provides: "Real-time sync patterns with optimistic updates"

  - skill: infrastructure-as-code
    context: "Need to deploy WebSocket servers"
    receives:
      - "Deployment requirements"
      - "Load balancer config needs"
      - "Scaling requirements"
    provides: "Infrastructure requirements for WebSocket deployment"

# ============================================================================
# DELEGATION TRIGGERS
# ============================================================================
delegation_triggers:
  - trigger: "authentication|auth|security"
    delegate_to: authentication-oauth
    pattern: parallel
    context: "WebSocket needs secure authentication"
    handoff_data:
      - "Connection auth requirements"
      - "Token types supported"
      - "Session handling needs"
    receive: "Authentication strategy for WebSocket"

  - trigger: "scale|horizontal|multiple servers"
    delegate_to: infrastructure-as-code
    pattern: sequential
    context: "Need to scale WebSocket horizontally"
    handoff_data:
      - "Connection count estimates"
      - "Message throughput requirements"
      - "Sticky session requirements"
    receive: "Load balancer and Redis pub/sub configuration"

  - trigger: "queue|background|async processing"
    delegate_to: queue-workers
    pattern: parallel
    context: "Messages need async processing"
    handoff_data:
      - "Message types"
      - "Processing requirements"
      - "Delivery guarantees"
    receive: "Message queue integration"

  - trigger: "rate limit|throttle|abuse"
    delegate_to: rate-limiting
    pattern: parallel
    context: "Need to rate limit WebSocket messages"
    handoff_data:
      - "Message types"
      - "Expected message rates"
      - "Per-user vs per-connection limits"
    receive: "Rate limiting strategy"

  - trigger: "database|persist|store messages"
    delegate_to: database-schema-design
    pattern: parallel
    context: "Need to persist real-time messages"
    handoff_data:
      - "Message schema"
      - "Retention requirements"
      - "Query patterns"
    receive: "Database schema for messages"

# ============================================================================
# FEEDBACK LOOPS
# ============================================================================
feedback_loops:
  receives_feedback_from:
    - skill: infrastructure-as-code
      signal: "Load balancer dropping connections"
      action: "Reduce heartbeat interval, check idle timeout settings"

    - skill: performance-optimization
      signal: "WebSocket causing high memory usage"
      action: "Check for connection/listener leaks, implement backpressure"

    - skill: observability-sre
      signal: "Connection errors spiking"
      action: "Review reconnection logic, check server health"

    - skill: security-hardening
      signal: "Unauthorized connections detected"
      action: "Strengthen authentication, add connection rate limiting"

  sends_feedback_to:
    - skill: backend
      signal: "Message format needs restructuring"
      action: "Define clear message schema with versioning"

    - skill: frontend
      signal: "Client reconnection too aggressive"
      action: "Increase backoff, add jitter to prevent thundering herd"

    - skill: infrastructure-as-code
      signal: "Need sticky sessions for WebSocket"
      action: "Configure load balancer for WebSocket affinity"

    - skill: state-management
      signal: "State sync conflicts occurring"
      action: "Implement conflict resolution or CRDT"

# ============================================================================
# CROSS-DOMAIN INSIGHTS
# ============================================================================
cross_domain_insights:
  - domain: Distributed Systems
    insight: |
      Distributed systems engineers know WebSocket scaling is hard:
      - Each server instance only sees its connections
      - Cross-instance broadcast needs pub/sub (Redis)
      - Presence is a distributed state problem
      - Connection affinity complicates load balancing

      Horizontal scaling WebSocket is fundamentally different from HTTP.
    applies_when: "Scaling beyond single server"

  - domain: Site Reliability Engineering
    insight: |
      SREs understand real-time systems have unique failure modes:
      - Connection drops are silent until heartbeat timeout
      - Thundering herd on restart can cascade
      - Memory leaks accumulate over long connections
      - Stale connections consume resources

      Real-time systems need different monitoring than request/response.
    applies_when: "Operating WebSocket in production"

  - domain: Security Engineering
    insight: |
      Security engineers see WebSocket as attack surface:
      - WebSocket bypasses many HTTP security controls
      - CSRF protection doesn't apply
      - Rate limiting needs custom implementation
      - Connection-based auth vs request-based

      Every WebSocket endpoint needs explicit security consideration.
    applies_when: "Securing real-time endpoints"

  - domain: Mobile Development
    insight: |
      Mobile developers know network is unreliable:
      - Connections drop on network switch
      - Background apps lose connections
      - Battery optimization kills connections
      - Reconnection must be graceful

      Mobile-first means reconnection-first.
    applies_when: "Building mobile real-time features"

# ============================================================================
# COMMON COMBINATIONS
# ============================================================================
common_combinations:
  - name: Chat Application
    skills:
      - websocket-realtime
      - authentication-oauth
      - database-schema-design
      - state-management
    workflow: |
      1. Design message schema (database-schema-design)
      2. Set up WebSocket server with rooms (websocket-realtime)
      3. Implement authentication (authentication-oauth)
      4. Handle client state (state-management)
      5. Add presence indicators (websocket-realtime)
      6. Persist messages (database-schema-design)

  - name: Live Dashboard
    skills:
      - websocket-realtime
      - backend
      - frontend
      - caching-patterns
    workflow: |
      1. Define update requirements (backend)
      2. Choose SSE vs WebSocket (websocket-realtime)
      3. Implement server push (websocket-realtime)
      4. Handle client reconnection (websocket-realtime)
      5. Cache data for new connections (caching-patterns)
      6. Render updates in UI (frontend)

  - name: Collaborative Editor
    skills:
      - websocket-realtime
      - state-management
      - database-schema-design
      - performance-optimization
    workflow: |
      1. Design operational transform or CRDT (state-management)
      2. Set up real-time sync (websocket-realtime)
      3. Handle conflicts (state-management)
      4. Persist document state (database-schema-design)
      5. Optimize for large documents (performance-optimization)

  - name: Real-time Notifications
    skills:
      - websocket-realtime
      - queue-workers
      - backend
    workflow: |
      1. Define notification types (backend)
      2. Set up notification queue (queue-workers)
      3. Implement WebSocket/SSE delivery (websocket-realtime)
      4. Handle offline users (queue-workers)
      5. Implement read receipts (backend)

# ============================================================================
# ECOSYSTEM
# ============================================================================
ecosystem:
  primary_tools:
    - "Socket.IO - Feature-rich real-time framework"
    - "ws - Lightweight WebSocket library for Node.js"
    - "Pusher - Managed real-time service"
    - "Ably - Managed pub/sub platform"
    - "Supabase Realtime - PostgreSQL-based realtime"

  websocket_libraries:
    - name: ws (Node.js)
      use_when: "Need lightweight, low-level control"
      bundle_size: "~50KB (server only)"
      features: "Pure WebSocket, no fallback"

    - name: Socket.IO
      use_when: "Need rooms, namespaces, auto-fallback"
      bundle_size: "~40KB client"
      features: "Rooms, reconnection, binary, acknowledgments"

    - name: uWebSockets.js
      use_when: "Need extreme performance"
      bundle_size: "Native binary"
      features: "C++ performance, HTTP/WebSocket"

    - name: Primus
      use_when: "Need transport abstraction"
      features: "Multiple transport backends"

  managed_services:
    - name: Pusher
      use_when: "Don't want to manage infrastructure"
      pricing: "Per message and connection"
      features: "Channels, presence, webhooks"

    - name: Ably
      use_when: "Need global distribution, strong guarantees"
      pricing: "Per message"
      features: "Pub/sub, presence, history, global edge"

    - name: Supabase Realtime
      use_when: "Already using Supabase, PostgreSQL-driven updates"
      pricing: "Included in Supabase plan"
      features: "Database triggers, broadcast, presence"

    - name: Firebase Realtime Database
      use_when: "Firebase ecosystem, simple sync needs"
      pricing: "Per GB stored and transferred"

    - name: AWS AppSync
      use_when: "AWS ecosystem, GraphQL subscriptions"
      pricing: "Per operation and connection"

  scaling_tools:
    - name: Redis Pub/Sub
      purpose: "Cross-instance message broadcast"
      use_when: "Multiple WebSocket server instances"

    - name: Redis Adapter (Socket.IO)
      purpose: "Socket.IO horizontal scaling"
      use_when: "Scaling Socket.IO across servers"

    - name: NATS
      purpose: "High-performance pub/sub"
      use_when: "Need extreme throughput"

    - name: Kafka
      purpose: "Durable message streaming"
      use_when: "Need message persistence and replay"

  client_libraries:
    - name: socket.io-client
      platform: "Browser, Node.js, React Native"

    - name: ReconnectingWebSocket
      purpose: "Drop-in reconnecting WebSocket"
      platform: "Browser"

    - name: RxJS WebSocket
      purpose: "Observable-based WebSocket"
      platform: "Browser, Node.js"

