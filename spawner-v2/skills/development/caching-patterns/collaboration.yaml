id: caching-patterns-collaboration
skill: caching-patterns
version: 1.0.0

# ============================================================================
# RECEIVES FROM (Who delegates TO this skill)
# ============================================================================
receives_from:
  - skill: backend
    context: "Backend needs caching for performance"
    receives:
      - "Hot endpoints to cache"
      - "Data access patterns"
      - "Consistency requirements"
    provides: "Caching strategy and implementation patterns"

  - skill: database-schema-design
    context: "Database queries need caching layer"
    receives:
      - "Expensive queries"
      - "Read/write ratios"
      - "Data update frequency"
    provides: "Query result caching with proper invalidation"

  - skill: performance-optimization
    context: "Performance issues need caching solution"
    receives:
      - "Slow endpoints identified"
      - "Traffic patterns"
      - "Latency requirements"
    provides: "Multi-layer caching architecture"

  - skill: frontend
    context: "Frontend needs API response caching"
    receives:
      - "API response requirements"
      - "Stale data tolerance"
      - "User experience needs"
    provides: "HTTP caching headers and CDN configuration"

  - skill: infrastructure-as-code
    context: "Infrastructure needs cache service"
    receives:
      - "Caching requirements"
      - "Capacity estimates"
      - "Availability needs"
    provides: "Redis/Memcached infrastructure specs"

# ============================================================================
# DELEGATION TRIGGERS
# ============================================================================
delegation_triggers:
  - trigger: "redis|memcached|infrastructure"
    delegate_to: infrastructure-as-code
    pattern: sequential
    context: "Need cache infrastructure provisioned"
    handoff_data:
      - "Memory requirements"
      - "Replication needs"
      - "Cluster configuration"
    receive: "Cache infrastructure configuration"

  - trigger: "performance|latency|throughput"
    delegate_to: performance-optimization
    pattern: parallel
    context: "Need performance analysis for caching decisions"
    handoff_data:
      - "Current performance metrics"
      - "Caching candidates"
      - "Expected improvements"
    receive: "Performance baseline and targets"

  - trigger: "database|query|optimization"
    delegate_to: database-schema-design
    pattern: parallel
    context: "Database optimization may reduce caching needs"
    handoff_data:
      - "Slow queries"
      - "Access patterns"
      - "Index recommendations"
    receive: "Optimized queries and indexing"

  - trigger: "cdn|edge|cloudflare|fastly"
    delegate_to: infrastructure-as-code
    pattern: parallel
    context: "Need CDN configuration for edge caching"
    handoff_data:
      - "Cache rules"
      - "Invalidation requirements"
      - "Geographic distribution"
    receive: "CDN infrastructure setup"

  - trigger: "api|endpoint|backend"
    delegate_to: backend
    pattern: sequential
    context: "Need backend implementation for caching"
    handoff_data:
      - "Caching patterns"
      - "Invalidation strategy"
      - "Key design"
    receive: "Backend code with caching integration"

# ============================================================================
# FEEDBACK LOOPS
# ============================================================================
feedback_loops:
  receives_feedback_from:
    - skill: performance-optimization
      signal: "Cache hit rates low"
      action: "Analyze access patterns, adjust TTL, review key design"

    - skill: observability-sre
      signal: "Stale data incidents"
      action: "Review invalidation logic, add monitoring"

    - skill: backend
      signal: "Cache stampede detected"
      action: "Implement stampede prevention, add locks"

    - skill: infrastructure-as-code
      signal: "Redis memory pressure"
      action: "Review eviction policy, reduce TTL, add capacity"

  sends_feedback_to:
    - skill: backend
      signal: "Caching difficult due to data model"
      action: "Restructure data for better cachability"

    - skill: database-schema-design
      signal: "Cache invalidation complex"
      action: "Simplify data relationships, add update triggers"

    - skill: infrastructure-as-code
      signal: "Need more cache capacity"
      action: "Scale Redis cluster, add read replicas"

    - skill: performance-optimization
      signal: "Caching fully optimized"
      action: "Look for other optimization opportunities"

# ============================================================================
# CROSS-DOMAIN INSIGHTS
# ============================================================================
cross_domain_insights:
  - domain: Site Reliability Engineering
    insight: |
      SREs know caching is a double-edged sword:
      - Cache failure = database overload
      - Cache stampede = cascading failure
      - Stale data = user trust erosion
      - Cache hit rate is key reliability metric
      Caching improves performance but adds failure modes.
    applies_when: "Designing resilient caching systems"

  - domain: Database Engineering
    insight: |
      Database engineers understand read/write patterns:
      - Cache works best for read-heavy workloads
      - Write-heavy workloads need write-through or invalidation
      - Query result sets are natural cache units
      - Index optimizations may reduce caching need
      Sometimes query optimization beats caching.
    applies_when: "Deciding what to cache"

  - domain: Distributed Systems
    insight: |
      Distributed systems engineers see cache consistency:
      - Distributed cache = distributed consistency problem
      - Cache invalidation across regions is hard
      - Eventual consistency is usually acceptable for cache
      - Multi-layer caches need coordinated invalidation
      Caching trades consistency for performance.
    applies_when: "Designing distributed caching"

  - domain: Cost Optimization
    insight: |
      FinOps practitioners calculate cache ROI:
      - Redis memory costs vs database CPU costs
      - CDN costs vs origin bandwidth costs
      - Higher hit rate = better ROI
      - Over-caching wastes memory
      Right-size cache for actual access patterns.
    applies_when: "Optimizing cache costs"

# ============================================================================
# COMMON COMBINATIONS
# ============================================================================
common_combinations:
  - name: High-Performance API
    skills:
      - caching-patterns
      - backend
      - performance-optimization
    workflow: |
      1. Identify slow endpoints (performance-optimization)
      2. Design caching strategy (caching-patterns)
      3. Implement with cache-aside (backend)
      4. Add HTTP caching headers
      5. Measure and tune

  - name: Scalable Read Layer
    skills:
      - caching-patterns
      - database-schema-design
      - infrastructure-as-code
    workflow: |
      1. Analyze query patterns (database-schema-design)
      2. Design cache architecture (caching-patterns)
      3. Provision Redis cluster (infrastructure-as-code)
      4. Implement caching layer
      5. Add monitoring

  - name: CDN Edge Caching
    skills:
      - caching-patterns
      - frontend
      - infrastructure-as-code
    workflow: |
      1. Identify static/semi-static content (frontend)
      2. Design cache strategy (caching-patterns)
      3. Configure CDN (infrastructure-as-code)
      4. Set up cache invalidation
      5. Monitor hit rates

  - name: Session and Auth Caching
    skills:
      - caching-patterns
      - security-hardening
      - backend
    workflow: |
      1. Design session storage (caching-patterns)
      2. Secure session handling (security-hardening)
      3. Implement session cache (backend)
      4. Configure TTL and invalidation
      5. Test session scenarios

# ============================================================================
# ECOSYSTEM
# ============================================================================
ecosystem:
  primary_tools:
    - "Redis - In-memory data store, most popular"
    - "Memcached - Simple, distributed caching"
    - "CloudFlare - CDN with edge caching"
    - "Fastly - CDN with instant purge"
    - "Varnish - HTTP accelerator"

  alternatives:
    - name: Redis
      use_when: "Need data structures, persistence, pub/sub"
      avoid_when: "Simple key-value only, extreme simplicity needed"

    - name: Memcached
      use_when: "Simple caching, multi-threaded, horizontal scaling"
      avoid_when: "Need persistence, data structures, pub/sub"

    - name: Redis Cluster
      use_when: "Need horizontal scaling, high availability"
      avoid_when: "Small scale, single instance sufficient"

    - name: ElastiCache
      use_when: "AWS-native, managed service, auto-scaling"
      avoid_when: "Multi-cloud, cost-sensitive"

    - name: Upstash
      use_when: "Serverless, pay-per-request, edge deployment"
      avoid_when: "High volume, consistent load"

  caching_libraries:
    - name: ioredis
      use_when: "Node.js, full Redis feature set"
      features: "Cluster support, Lua scripting, streams"

    - name: node-cache
      use_when: "Simple in-memory caching, Node.js"
      features: "TTL, events, statistics"

    - name: lru-cache
      use_when: "LRU eviction, memory-bounded cache"
      features: "Max size, TTL, dispose callback"

    - name: keyv
      use_when: "Multiple backends, simple API"
      features: "Redis, SQLite, MongoDB, memory"

  cdn_providers:
    - name: CloudFlare
      use_when: "Full-featured, global network, free tier"
      features: "Workers, edge compute, DDoS protection"

    - name: Fastly
      use_when: "Instant purge, VCL customization"
      features: "Real-time logging, edge compute"

    - name: AWS CloudFront
      use_when: "AWS-native, Lambda@Edge"
      features: "Origin shield, field-level encryption"

    - name: Vercel Edge
      use_when: "Next.js apps, serverless edge"
      features: "Automatic caching, ISR"

