# Collaboration - Performance Optimization
# How this skill works with other skills

version: 1.0.0
skill_id: performance-optimization

prerequisites:
  required: []

  recommended:
    - skill: react-patterns
      reason: "React-specific optimizations"
      what_to_know:
        - "Component lifecycle"
        - "Re-render causes"
        - "State management"

    - skill: postgres-wizard
      reason: "Database optimization"
      what_to_know:
        - "Query execution plans"
        - "Index types"
        - "Query patterns"

  knowledge:
    - "Browser DevTools"
    - "HTTP caching"
    - "Database fundamentals"

delegation_triggers:
  - trigger: "user needs database schema changes"
    delegate_to: postgres-wizard
    context: "Index creation, query restructuring"

  - trigger: "user needs caching infrastructure"
    delegate_to: redis-specialist
    context: "Redis setup, cache patterns"

  - trigger: "user needs scaling"
    delegate_to: kubernetes
    context: "Horizontal scaling, load balancing"

  - trigger: "user needs CDN setup"
    delegate_to: devops
    context: "CDN configuration, edge caching"

  - trigger: "user needs React optimization"
    delegate_to: react-patterns
    context: "Component optimization, rendering"

receives_context_from:
  - skill: react-patterns
    receives:
      - "Components to optimize"
      - "Re-render patterns"
      - "State structure"

  - skill: backend
    receives:
      - "API endpoints to optimize"
      - "Current response times"
      - "Database queries"

  - skill: nextjs-app-router
    receives:
      - "Page structure"
      - "Data fetching patterns"
      - "Bundle size concerns"

provides_context_to:
  - skill: postgres-wizard
    provides:
      - "Slow query analysis"
      - "Index recommendations"
      - "Query patterns to optimize"

  - skill: redis-specialist
    provides:
      - "Cache requirements"
      - "TTL recommendations"
      - "Invalidation needs"

  - skill: devops
    provides:
      - "Performance requirements"
      - "Scaling triggers"
      - "CDN configuration needs"

escalation_paths:
  - situation: "Database performance issues"
    escalate_to: postgres-wizard
    context: "Query optimization, indexing"

  - situation: "Infrastructure scaling"
    escalate_to: kubernetes
    context: "Horizontal scaling, resources"

  - situation: "Caching architecture"
    escalate_to: redis-specialist
    context: "Distributed caching"

workflow_integration:
  typical_sequence:
    1:
      step: "Measure current performance"
      skills: [performance-optimization]
      output: "Baseline metrics, bottleneck identification"

    2:
      step: "Analyze frontend performance"
      skills: [performance-optimization]
      output: "Core Web Vitals, bundle analysis"

    3:
      step: "Analyze backend performance"
      skills: [performance-optimization, backend]
      output: "Slow endpoints, query analysis"

    4:
      step: "Optimize database"
      skills: [postgres-wizard]
      output: "Indexes, query improvements"

    5:
      step: "Implement caching"
      skills: [redis-specialist]
      output: "Cache layer configuration"

    6:
      step: "Optimize frontend"
      skills: [performance-optimization, react-patterns]
      output: "Bundle splitting, rendering fixes"

    7:
      step: "Verify improvements"
      skills: [performance-optimization]
      output: "Before/after comparison"

  decision_points:
    - question: "Cache at which layer?"
      guidance: |
        CDN (edge) when:
        - Static assets
        - Public pages
        - Geographic distribution needed

        Redis (application) when:
        - Dynamic user data
        - Session state
        - Computed results

        In-memory when:
        - Single server
        - Small dataset
        - No persistence needed

    - question: "Optimize server or client?"
      guidance: |
        Server first when:
        - Slow TTFB
        - Database bottleneck
        - High P95 latency

        Client first when:
        - Large bundle size
        - Slow interactions (INP)
        - Layout shifts (CLS)

    - question: "Horizontal or vertical scaling?"
      guidance: |
        Vertical (bigger server) when:
        - Quick fix needed
        - Single bottleneck
        - Memory-bound

        Horizontal (more servers) when:
        - Need high availability
        - Traffic varies greatly
        - CPU-bound

collaboration_patterns:
  with_react:
    when: "Optimizing React applications"
    approach: |
      React Performance Optimization:

      ## Measure first

      // React DevTools Profiler
      // Record session, find expensive renders


      ## Common fixes

      1. Memoize expensive components
      const List = memo(function List({ items }) {
        return items.map(item => <Item key={item.id} item={item} />);
      });

      2. Virtualize long lists
      import { useVirtualizer } from '@tanstack/react-virtual';

      3. Code split routes
      const Page = lazy(() => import('./Page'));

      4. Avoid anonymous callbacks to memoized children
      const handleClick = useCallback(() => {
        // handler
      }, [deps]);

  with_nextjs:
    when: "Optimizing Next.js applications"
    approach: |
      Next.js Performance:

      ## Use built-in optimizations

      // next/image for automatic image optimization
      import Image from 'next/image';

      // next/font for font optimization
      import { Inter } from 'next/font/google';

      // next/dynamic for code splitting
      import dynamic from 'next/dynamic';


      ## Caching strategies

      // ISR for semi-static content
      export async function generateStaticParams() {}
      export const revalidate = 3600;

      // Route handlers with cache
      export async function GET() {
        return Response.json(data, {
          headers: { 'Cache-Control': 'max-age=60' }
        });
      }


      ## Bundle analysis

      ANALYZE=true npm run build

  with_database:
    when: "Database is the bottleneck"
    approach: |
      Database Optimization Workflow:

      ## 1. Find slow queries

      SELECT query, mean_time, calls
      FROM pg_stat_statements
      ORDER BY total_time DESC
      LIMIT 20;


      ## 2. Analyze execution plan

      EXPLAIN ANALYZE
      SELECT * FROM orders
      WHERE user_id = 123
      ORDER BY created_at DESC;


      ## 3. Add appropriate indexes

      -- For WHERE clauses
      CREATE INDEX idx_orders_user ON orders(user_id);

      -- For ORDER BY
      CREATE INDEX idx_orders_user_date ON orders(user_id, created_at DESC);

      -- Partial for filtered queries
      CREATE INDEX idx_active_users ON users(email) WHERE active = true;


      ## 4. Fix N+1 queries

      // Use eager loading
      const users = await prisma.user.findMany({
        include: { posts: true }
      });

platform_integration:
  lighthouse:
    setup: |
      # Lighthouse CI Setup

      npm install -g @lhci/cli

      # lighthouserc.js
      module.exports = {
        ci: {
          collect: {
            url: ['http://localhost:3000'],
            numberOfRuns: 3,
          },
          assert: {
            assertions: {
              'categories:performance': ['error', { minScore: 0.9 }],
              'first-contentful-paint': ['warn', { maxNumericValue: 2000 }],
              'largest-contentful-paint': ['error', { maxNumericValue: 2500 }],
              'cumulative-layout-shift': ['error', { maxNumericValue: 0.1 }],
            },
          },
          upload: {
            target: 'temporary-public-storage',
          },
        },
      };

      # Run in CI
      lhci autorun
    considerations:
      - "Run against production build"
      - "Use consistent test environment"
      - "Set appropriate thresholds"

  web_vitals:
    setup: |
      # Web Vitals Monitoring

      npm install web-vitals

      // app/components/WebVitals.tsx
      'use client';

      import { useReportWebVitals } from 'next/web-vitals';

      export function WebVitals() {
        useReportWebVitals((metric) => {
          console.log(metric);

          // Send to analytics
          fetch('/api/vitals', {
            method: 'POST',
            body: JSON.stringify(metric),
          });
        });

        return null;
      }
    considerations:
      - "Track P75 values, not averages"
      - "Segment by device type"
      - "Compare to field data"

ecosystem:
  primary_tools:
    - "Lighthouse"
    - "Chrome DevTools"
    - "web-vitals"
    - "Bundle Analyzer"

  profiling:
    - name: "React DevTools Profiler"
      use_when: "React component performance"
    - name: "Chrome Performance tab"
      use_when: "General frontend profiling"
    - name: "node --prof"
      use_when: "Node.js backend profiling"
    - name: "pg_stat_statements"
      use_when: "PostgreSQL query analysis"

  monitoring:
    - name: "Vercel Analytics"
      use_when: "Next.js on Vercel"
    - name: "Datadog RUM"
      use_when: "Enterprise monitoring"
    - name: "Google Analytics 4"
      use_when: "Free Web Vitals tracking"

  load_testing:
    - name: autocannon
      use_when: "Quick Node.js load tests"
    - name: k6
      use_when: "Scriptable load testing"
    - name: locust
      use_when: "Python-based load testing"

  alternatives:
    - name: "WebPageTest"
      use_when: "Detailed waterfall analysis"
      avoid_when: "Need real-time monitoring"

    - name: "SpeedCurve"
      use_when: "Competitive benchmarking"
      avoid_when: "Budget constrained"
