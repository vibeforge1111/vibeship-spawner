# Collaboration - Python Backend
# How this skill works with other skills

version: 1.0.0
skill_id: python-backend

prerequisites:
  required: []

  recommended:
    - skill: postgres-wizard
      reason: "Database design and optimization"
      what_to_know:
        - "SQL basics"
        - "ORM patterns"
        - "Query optimization"

    - skill: docker
      reason: "Containerization for deployment"
      what_to_know:
        - "Dockerfile basics"
        - "Docker Compose"

  knowledge:
    - "Python 3.10+ syntax"
    - "HTTP and REST concepts"
    - "Virtual environments"
    - "pip/poetry package management"

delegation_triggers:
  - trigger: "user needs database design"
    delegate_to: postgres-wizard
    context: "Schema design, query optimization"

  - trigger: "user needs containerization"
    delegate_to: docker
    context: "Python Dockerfile, multi-stage builds"

  - trigger: "user needs CI/CD"
    delegate_to: cicd-pipelines
    context: "pytest in CI, deployment"

  - trigger: "user needs caching"
    delegate_to: redis-specialist
    context: "Redis caching, Celery broker"

  - trigger: "user needs testing strategy"
    delegate_to: testing
    context: "pytest patterns, fixtures"

receives_context_from:
  - skill: frontend
    receives:
      - "API requirements"
      - "Data format expectations"
      - "Authentication needs"

  - skill: devops
    receives:
      - "Deployment requirements"
      - "Scaling needs"
      - "Environment configuration"

  - skill: postgres-wizard
    receives:
      - "Database schema"
      - "Query patterns"
      - "Performance requirements"

provides_context_to:
  - skill: docker
    provides:
      - "requirements.txt or pyproject.toml"
      - "Application entry point"
      - "Environment variable requirements"

  - skill: testing
    provides:
      - "Code to test"
      - "Fixtures needed"
      - "Mock requirements"

  - skill: cicd-pipelines
    provides:
      - "Test commands"
      - "Lint commands"
      - "Build artifacts"

escalation_paths:
  - situation: "Complex database queries"
    escalate_to: postgres-wizard
    context: "Query optimization, indexing"

  - situation: "Performance issues"
    escalate_to: performance-profiling
    context: "Profiling, bottleneck analysis"

  - situation: "Distributed systems patterns"
    escalate_to: microservices-patterns
    context: "Service communication, saga pattern"

workflow_integration:
  typical_sequence:
    1:
      step: "Design API schema"
      skills: [python-backend]
      output: "OpenAPI spec or Pydantic models"

    2:
      step: "Design database"
      skills: [postgres-wizard]
      output: "SQLAlchemy models, migrations"

    3:
      step: "Implement endpoints"
      skills: [python-backend]
      output: "FastAPI/Django routes"

    4:
      step: "Add tests"
      skills: [python-backend, testing]
      output: "pytest suite"

    5:
      step: "Containerize"
      skills: [docker]
      output: "Dockerfile, docker-compose"

    6:
      step: "Set up CI/CD"
      skills: [cicd-pipelines]
      output: "GitHub Actions workflow"

  decision_points:
    - question: "Django or FastAPI?"
      guidance: |
        Django when:
        - Full-featured web app with templates
        - Need admin panel
        - Traditional ORM is fine
        - Team knows Django

        FastAPI when:
        - API-first (no HTML)
        - Need async performance
        - Want automatic OpenAPI docs
        - Type hints everywhere

        Both when:
        - Django for admin, FastAPI for public API

    - question: "SQLAlchemy or Django ORM?"
      guidance: |
        Django ORM:
        - Only with Django
        - Simpler, less flexible
        - Migrations built in

        SQLAlchemy:
        - With FastAPI/Flask
        - More powerful, complex queries
        - Async support (2.0+)
        - Better type hints

    - question: "Sync or async?"
      guidance: |
        Async when:
        - High I/O concurrency (API calls, DB)
        - WebSocket connections
        - Streaming responses
        - Using FastAPI

        Sync when:
        - CPU-bound work
        - Simple CRUD with Django
        - All libraries are sync-only

collaboration_patterns:
  with_postgres:
    when: "Database operations"
    approach: |
      SQLAlchemy + PostgreSQL:

      # Async connection
      from sqlalchemy.ext.asyncio import create_async_engine

      engine = create_async_engine(
          "postgresql+asyncpg://user:pass@localhost/db",
          pool_size=5,
          max_overflow=10,
      )

      # Indexes for common queries
      class User(Base):
          __tablename__ = "users"

          id: Mapped[int] = mapped_column(primary_key=True)
          email: Mapped[str] = mapped_column(
              String(255), unique=True, index=True
          )
          created_at: Mapped[datetime] = mapped_column(
              DateTime, index=True  # For date range queries
          )

  with_redis:
    when: "Caching and background jobs"
    approach: |
      Redis for caching:

      import redis.asyncio as redis

      redis_client = redis.from_url(settings.redis_url)

      async def get_cached(key: str):
          cached = await redis_client.get(key)
          if cached:
              return json.loads(cached)
          return None

      async def set_cached(key: str, value: any, ttl: int = 3600):
          await redis_client.setex(key, ttl, json.dumps(value))


      Celery for background jobs:

      from celery import Celery

      celery_app = Celery(
          "tasks",
          broker=settings.redis_url,
          backend=settings.redis_url,
      )

      @celery_app.task
      def send_email(to: str, subject: str, body: str):
          # Send email in background
          pass

  with_docker:
    when: "Containerizing Python apps"
    approach: |
      Python Dockerfile:

      # Multi-stage build
      FROM python:3.12-slim as builder

      WORKDIR /app

      # Install poetry
      RUN pip install poetry

      # Copy dependency files
      COPY pyproject.toml poetry.lock ./

      # Install dependencies
      RUN poetry config virtualenvs.create false \
          && poetry install --no-dev --no-interaction

      # Production stage
      FROM python:3.12-slim

      WORKDIR /app

      # Non-root user
      RUN useradd -m -s /bin/bash app

      # Copy installed packages
      COPY --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages

      # Copy application
      COPY --chown=app:app . .

      USER app

      EXPOSE 8000

      CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

platform_integration:
  fastapi:
    setup: |
      # FastAPI Project Setup

      # Create with poetry
      poetry init
      poetry add fastapi uvicorn[standard] pydantic-settings sqlalchemy[asyncio] asyncpg

      # Development dependencies
      poetry add -D pytest pytest-asyncio httpx ruff mypy

      # Run development server
      uvicorn app.main:app --reload

      # Production server
      gunicorn app.main:app -w 4 -k uvicorn.workers.UvicornWorker
    considerations:
      - "Use pydantic-settings for config"
      - "Structure with routers, schemas, services"
      - "Add middleware for CORS, logging"

  django:
    setup: |
      # Django Project Setup

      # Create with poetry
      poetry init
      poetry add django djangorestframework psycopg2-binary

      # Development
      poetry add -D pytest-django ruff mypy django-stubs

      # Create project
      django-admin startproject config .
      python manage.py startapp users

      # Run server
      python manage.py runserver

      # Production
      gunicorn config.wsgi:application -w 4
    considerations:
      - "Use apps/ directory for Django apps"
      - "Split settings for local/production"
      - "Use Django REST Framework for APIs"

ecosystem:
  primary_tools:
    - "FastAPI / Django"
    - "SQLAlchemy / Django ORM"
    - "Pydantic"
    - "pytest"
    - "Celery"

  package_management:
    - name: Poetry
      use_when: "Dependency management, publishing"
    - name: uv
      use_when: "Fast package installation"
    - name: pip-tools
      use_when: "Simpler requirements.txt workflow"

  code_quality:
    - name: Ruff
      use_when: "Linting + formatting (replaces black, isort, flake8)"
    - name: mypy
      use_when: "Type checking"
    - name: pre-commit
      use_when: "Git hooks for quality checks"

  alternatives:
    - name: Flask
      use_when: "Minimal, flexible framework"
      avoid_when: "Need async or auto-docs"

    - name: Starlette
      use_when: "Even lower level than FastAPI"
      avoid_when: "Want Pydantic integration"

    - name: Litestar
      use_when: "Alternative to FastAPI with more features"
      avoid_when: "Smaller community"

  deprecated:
    - "Python 3.8 (EOL Dec 2024)"
    - "aiohttp for new projects (use httpx)"
    - "requests in async code (use httpx)"
    - "Pydantic v1 syntax"
