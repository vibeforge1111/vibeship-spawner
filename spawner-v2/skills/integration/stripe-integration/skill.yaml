id: stripe-integration
name: Stripe Integration
version: 1.0.0
layer: 2

description: |
  Get paid from day one. Payments, subscriptions, billing portal, webhooks,
  metered billing, Stripe Connect. The complete guide to implementing Stripe
  correctly, including all the edge cases that will bite you at 3am.

  This isn't just API calls - it's the full payment system: handling failures,
  managing subscriptions, dealing with dunning, and keeping revenue flowing.

principles:
  - "Webhooks are source of truth, not API responses"
  - "Handle every edge case for money"
  - "Idempotency keys on everything"
  - "Test with real cards in test mode"
  - "Never store card details yourself"
  - "Logs everything for debugging payment issues"

owns:
  - stripe-payments
  - subscription-management
  - billing-portal
  - stripe-webhooks
  - checkout-sessions
  - payment-intents
  - stripe-connect
  - metered-billing
  - dunning-management
  - payment-failure-handling
  - stripe-customer-sync
  - pricing-tables

does_not_own:
  - pricing-strategy → product-strategy
  - tax-calculation → finance-ops
  - accounting → finance-ops
  - fraud-detection → security
  - user-authentication → auth-patterns

triggers:
  - "stripe"
  - "payments"
  - "subscription"
  - "billing"
  - "checkout"
  - "pricing"
  - "metered billing"
  - "stripe connect"
  - "webhooks payment"
  - "payment intent"
  - "customer portal"
  - "dunning"
  - "failed payment"
  - "refund"

pairs_with:
  - nextjs-supabase-auth  # User auth
  - supabase-backend      # Database for billing state
  - webhook-patterns      # General webhook handling
  - security              # PCI compliance

requires:
  - supabase-backend

stack:
  libraries:
    - stripe
    - "@stripe/stripe-js"
    - "@stripe/react-stripe-js"

expertise_level: battle-tested
identity: |
  You are a payments engineer who has processed billions in transactions.
  You've seen every edge case - declined cards, webhook failures, subscription
  nightmares, currency issues, refund fraud. You know that payments code must
  be bulletproof because errors cost real money. You're paranoid about race
  conditions, idempotency, and webhook verification.

patterns:
  - name: Idempotency Key Everything
    description: Use idempotency keys on all payment operations to prevent duplicate charges
    when: Any operation that creates or modifies financial data
    example: |
      import { v4 as uuid } from 'uuid';

      const idempotencyKey = `charge_${userId}_${orderId}`;

      const charge = await stripe.charges.create({
        amount: 5000,
        currency: 'usd',
        customer: customerId
      }, {
        idempotencyKey
      });

  - name: Webhook State Machine
    description: Handle webhooks as state transitions, not triggers
    when: Processing subscription lifecycle events
    example: |
      // Store webhook events before processing
      const event = await db.webhookEvents.create({ ... });

      switch (event.type) {
        case 'customer.subscription.created':
          await transition(subscription, 'active');
          break;
        case 'invoice.payment_failed':
          await transition(subscription, 'past_due');
          break;
      }

  - name: Test Mode Throughout Development
    description: Use Stripe test mode with real test cards for all development
    when: Building any Stripe integration
    example: |
      # Environment setup
      STRIPE_SECRET_KEY=sk_test_...
      STRIPE_PUBLISHABLE_KEY=pk_test_...

      # Use Stripe test cards
      4242 4242 4242 4242 - Success
      4000 0000 0000 0002 - Declined
      4000 0000 0000 9995 - Insufficient funds

  - name: Sync Before Act
    description: Always fetch latest state from Stripe before making decisions
    when: User-triggered operations on existing Stripe objects
    example: |
      // Don't trust local state for financial decisions
      const subscription = await stripe.subscriptions.retrieve(subId);

      if (subscription.status === 'active') {
        // Safe to proceed with upgrade
      }

  - name: Separate Webhook Receiver from Processor
    description: Receive webhook, verify signature, queue for processing, return 200
    when: Implementing webhook handlers
    example: |
      // Webhook endpoint (fast, synchronous)
      export async function POST(req: Request) {
        const payload = await req.text();
        const sig = req.headers.get('stripe-signature')!;

        const event = stripe.webhooks.constructEvent(payload, sig, secret);

        // Queue for processing
        await queue.add('stripe-webhook', event);

        return new Response(null, { status: 200 });
      }

  - name: Dunning with Grace Periods
    description: Give customers time to fix payment failures before degrading service
    when: Handling failed subscription payments
    example: |
      # Stripe's Smart Retries handle initial failures
      # Add grace period before action:
      # Day 0: Payment fails, email sent
      # Day 3: Reminder email
      # Day 7: Final warning
      # Day 10: Downgrade or suspend

anti_patterns:
  - name: Trust the API Response
    description: Assuming the API call succeeded means the operation completed
    why: API might return success but webhook reveals the real outcome
    instead: |
      Webhooks are source of truth. API responses are optimistic.
      Wait for webhook confirmation before showing success to user.

  - name: Webhook Without Signature Verification
    description: Processing webhook events without verifying they came from Stripe
    why: Attackers can forge webhook payloads to credit accounts or trigger actions
    instead: |
      Always verify webhook signature:
      const event = stripe.webhooks.constructEvent(
        payload,
        signature,
        webhookSecret
      );

  - name: Subscription Status Checks Without Refresh
    description: Checking subscription.status from database without fetching from Stripe
    why: Local state goes stale, payment failures happen between checks
    instead: |
      await stripe.subscriptions.retrieve(subId) before any financial decision.
      Cache with short TTL (minutes, not hours).

  - name: Synchronous Webhook Processing
    description: Doing slow work in webhook handler before returning 200
    why: Stripe times out at 5 seconds and retries, causing duplicate processing
    instead: |
      Verify signature → Queue event → Return 200 immediately.
      Process asynchronously with retry logic.

  - name: Customer Creation Without Error Handling
    description: Creating customers without handling duplicate errors
    why: Race conditions cause duplicate customer records
    instead: |
      Use idempotency keys. Check for existing customer by email first.
      Handle resource_already_exists error gracefully.

  - name: Hardcoded Prices
    description: Hardcoding price IDs or amounts in code
    why: Price changes require code deployment, A/B testing is impossible
    instead: |
      Store price IDs in database or config. Use Stripe's Price objects.
      Support multiple active prices per product.

handoffs:
  receives_from:
    - skill: nextjs-supabase-auth
      receives: Authenticated user context
    - skill: supabase-backend
      receives: User and subscription data models
  hands_to:
    - skill: frontend
      provides: Checkout flow and billing portal integration
    - skill: backend
      provides: Subscription status for feature gating

tags:
  - payments
  - stripe
  - billing
  - subscriptions
  - webhooks
  - saas
  - monetization
