id: blockchain-privacy
skill: Blockchain Privacy
version: "1.0"

sharp_edges:
  - id: trusted-setup-compromise
    severity: CRITICAL
    title: Trusted Setup Ceremony Can Be Compromised
    description: If ANY participant in a ZK-SNARK trusted setup keeps their "toxic waste", they can forge proofs and steal all funds
    symptoms:
      - Setup ceremony with few participants (<100)
      - Team-only ceremony without external participants
      - Missing ceremony transcripts or verification
      - No audit of ceremony process
    detection_pattern: "groth16|Groth16|trusted.*setup|ceremony"
    solution: |
      // Risk assessment for trusted setups:

      // 1. Check ceremony participation
      const MINIMUM_SAFE_PARTICIPANTS = 100;
      // If ceremony had fewer, consider the system potentially compromised

      // 2. Verify ceremony transcripts exist and are verifiable
      // Good: Zcash ceremony has verifiable transcripts
      // Bad: "Trust us, we did a ceremony"

      // 3. Prefer transparent alternatives
      // STARKs - No trusted setup, larger proofs
      // Halo2 - Recursive proofs, no trusted setup
      // Bulletproofs - For range proofs, no setup

      // 4. If using Groth16, use established ceremonies:
      // - Hermez/Polygon: 1000+ participants
      // - Tornado Cash: 1100+ participants
      // - Semaphore: Well-audited

      // 5. For new circuits, run massive public ceremony
      import { Phase2 } from "snarkjs";
      // Require 1000+ independent participants
      // Publish all transcripts
      // Allow independent verification
    references:
      - https://medium.com/qed-it/how-toxic-is-the-trusted-setup-eb71a4e7aa01
      - https://z.cash/technology/paramgen/

  - id: timing-attack-deanonymization
    severity: CRITICAL
    title: Timing Analysis Breaks Privacy
    description: Deposits and withdrawals that occur close in time can be linked through temporal analysis
    symptoms:
      - Deposit followed by withdrawal within minutes
      - Consistent time patterns (e.g., always withdraw at same time of day)
      - Transaction timing correlated with user timezone
      - Low latency between mixer interactions
    detection_pattern: "deposit.*withdraw|withdraw.*deposit|block\\.timestamp"
    solution: |
      // Problem: Deposit at 10:00, withdraw at 10:05 = trivially linkable

      contract PrivacyPool {
          uint256 public constant MIN_DELAY = 24 hours;
          uint256 public constant RECOMMENDED_DELAY = 7 days;

          mapping(bytes32 => uint256) public depositTime;

          function deposit(bytes32 commitment) external payable {
              depositTime[commitment] = block.timestamp;
              // ... normal deposit logic
          }

          function withdraw(
              bytes calldata proof,
              bytes32 commitment,
              // ... other params
          ) external {
              // Enforce minimum delay
              require(
                  block.timestamp >= depositTime[commitment] + MIN_DELAY,
                  "Wait at least 24 hours"
              );

              // Warn if below recommended (UI should enforce)
              // In UI: "Waiting 7+ days significantly improves privacy"
          }
      }

      // Client-side recommendations:
      // 1. Random delay: 1-14 days (uniform distribution)
      // 2. Withdraw at random time of day
      // 3. Use multiple smaller withdrawals over weeks
      // 4. Don't withdraw right before you need funds
    references:
      - https://arxiv.org/abs/2201.02315

  - id: metadata-leakage
    severity: CRITICAL
    title: Metadata Leaks Identity Even With ZK Proofs
    description: Transaction metadata (gas price, nonce patterns, RPC logs, relayer choice) can deanonymize users
    symptoms:
      - Unique gas prices or limits
      - Consistent relayer usage
      - RPC endpoint logging
      - Predictable nonce sequences
    detection_pattern: "gasPrice|gasLimit|tx\\.gasprice|provider|rpc"
    solution: |
      // Metadata that leaks identity:
      // 1. Gas price - unique values fingerprint users
      // 2. Gas limit - custom limits are distinctive
      // 3. RPC provider - they log your IP + addresses
      // 4. Relayer - using same relayer links transactions

      // Mitigations:

      // 1. Normalize gas parameters
      async function getStandardGas() {
          const baseFee = await provider.getGasPrice();
          // Use rounded values everyone uses
          return {
              maxFeePerGas: roundToGwei(baseFee * 1.2),
              maxPriorityFeePerGas: ethers.parseGwei("1"), // Standard tip
              gasLimit: 300000 // Standard limit for privacy txs
          };
      }

      // 2. Use privacy-preserving RPC
      const PRIVATE_RPCS = [
          "https://rpc.mevblocker.io",
          "https://rpc.flashbots.net",
          // Or run your own node over Tor
      ];

      // 3. Rotate relayers
      async function selectRelayer() {
          const relayers = await fetchActiveRelayers();
          // Random selection, weighted by reputation
          return relayers[Math.floor(Math.random() * relayers.length)];
      }

      // 4. Use Tor/VPN for network requests
      // Different IP for each privacy operation
    references:
      - https://medium.com/@tornadocash/tornado-cash-got-hacked-by-the-government-ae85c95d4e9a

  - id: small-anonymity-set
    severity: HIGH
    title: Small Anonymity Set Provides Weak Privacy
    description: Privacy pools with few participants offer little protection - 100 users means 1% chance of correct guess
    symptoms:
      - New or niche privacy pool
      - Low total deposits
      - Few active users
      - Custom denomination amounts
    detection_pattern: "deposit|pool|mixer|anonymity"
    solution: |
      // Anonymity set size directly determines privacy level

      // Quick math:
      // 10 users = 10% chance of correct identification
      // 100 users = 1% chance
      // 1000 users = 0.1% chance
      // 10000 users = 0.01% chance

      // Before using any privacy pool:
      async function assessPool(poolAddress) {
          const pool = new ethers.Contract(poolAddress, ABI, provider);

          const totalDeposits = await pool.totalDeposits();
          const uniqueDepositors = await pool.uniqueDepositors();

          // Minimum thresholds
          const MINIMUM_DEPOSITS = 1000;
          const MINIMUM_DEPOSITORS = 500;

          if (totalDeposits < MINIMUM_DEPOSITS) {
              console.warn(`PRIVACY WARNING: Only ${totalDeposits} deposits`);
              console.warn("Anonymity set too small for meaningful privacy");
          }

          // Check activity
          const recentDeposits = await getDepositsLast30Days(pool);
          if (recentDeposits < 100) {
              console.warn("Low activity - timing attacks easier");
          }

          return {
              totalDeposits,
              uniqueDepositors,
              isPrivate: totalDeposits >= MINIMUM_DEPOSITS
          };
      }

      // UI should show clear warnings:
      // "Current anonymity set: 234 deposits"
      // "RECOMMENDED: Wait for 1000+ deposits before withdrawing"
    references:
      - https://tornado.ws/compliance/

  - id: amount-correlation
    severity: HIGH
    title: Deposit/Withdrawal Amount Correlation
    description: Depositing and withdrawing the same total amount (even split across transactions) links identity
    symptoms:
      - Non-standard denomination deposits
      - Withdrawal amounts matching deposits exactly
      - Split transactions totaling original amount
    detection_pattern: "msg\\.value|deposit|withdraw|amount"
    solution: |
      // Problem: Deposit 7.5 ETH, withdraw 7.5 ETH = trivially linked
      // Even: Deposit 7.5 ETH, withdraw 5 ETH + 2.5 ETH = linked

      // Solution 1: Fixed denominations
      contract FixedDenominationPool {
          uint256 public immutable DENOMINATION;

          constructor(uint256 _denomination) {
              // Only allow: 0.1, 1, 10, 100 ETH
              require(
                  _denomination == 0.1 ether ||
                  _denomination == 1 ether ||
                  _denomination == 10 ether ||
                  _denomination == 100 ether
              );
              DENOMINATION = _denomination;
          }

          function deposit(bytes32 commitment) external payable {
              require(msg.value == DENOMINATION, "Exact denomination only");
              // ...
          }
      }

      // Solution 2: Shielded pools with hidden amounts
      // (Confidential transactions - more complex)

      // User guidance:
      // 1. Only use fixed denomination pools
      // 2. Don't deposit unique amounts
      // 3. Wait between multiple deposits
      // 4. Withdraw to multiple addresses over time
    references:
      - https://arxiv.org/abs/2210.15497

  - id: graph-analysis
    severity: HIGH
    title: Graph Analysis Tracks Fund Flow
    description: Chain analysis tools can trace funds through multiple hops using graph analysis
    symptoms:
      - Direct transfers between related addresses
      - Common contract interactions
      - Shared token holdings
      - Similar transaction patterns
    detection_pattern: "transfer|send|call"
    solution: |
      // Problem: Even with privacy tools, graph analysis can link addresses

      // Attack vector:
      // 1. Analyze all addresses that withdrew from mixer
      // 2. Find common patterns (same contracts, tokens, timing)
      // 3. Cluster addresses by behavior
      // 4. Link to known identities

      // Defense strategies:

      // 1. Complete behavior separation
      // - Never interact with same contracts
      // - Use different tokens
      // - Different transaction patterns

      // 2. Break the graph
      // - Use multiple privacy pools
      // - Chain through different protocols
      // - Allow time between hops

      // 3. Avoid consolidation
      // Bad:
      // Address A -> Mixer -> Address B
      // Address C -> Mixer -> Address B  (LINKED!)

      // Good:
      // Address A -> Mixer -> Address B
      // Address C -> Mixer -> Address D  (separate)

      // 4. Use fresh receiving addresses
      async function generateReceivingAddress() {
          // New address for each withdrawal
          const wallet = ethers.Wallet.createRandom();
          // Fund through privacy pool
          // Use for single purpose, then abandon
          return wallet.address;
      }
    references:
      - https://www.chainalysis.com/

  - id: relayer-centralization
    severity: HIGH
    title: Centralized Relayer Surveillance
    description: Using a single relayer allows that relayer to link all your transactions
    symptoms:
      - Using same relayer repeatedly
      - Self-hosting single relayer
      - Relayer requiring KYC
      - Limited relayer selection
    detection_pattern: "relayer|relay"
    solution: |
      // Problem: Relayer sees your IP and the withdrawal address
      // Single relayer = complete transaction linkage

      contract PrivacyPoolWithRelayer {
          mapping(address => bool) public registeredRelayers;
          mapping(address => uint256) public relayerReputation;

          // Decentralized relayer network
          function registerRelayer() external payable {
              require(msg.value >= 1 ether, "Stake required");
              registeredRelayers[msg.sender] = true;
          }

          function withdraw(
              bytes calldata proof,
              address relayer,
              uint256 fee,
              // ...
          ) external {
              require(registeredRelayers[relayer], "Unknown relayer");
              // ... verify proof includes relayer and fee ...

              // Pay relayer
              payable(relayer).transfer(fee);
          }
      }

      // Client-side relayer selection:
      async function selectRelayer(relayers) {
          // 1. Never use same relayer twice in a row
          const lastRelayer = getLastUsedRelayer();
          const available = relayers.filter(r => r !== lastRelayer);

          // 2. Random selection weighted by reputation
          const totalRep = available.reduce((s, r) => s + r.reputation, 0);
          let random = Math.random() * totalRep;

          for (const relayer of available) {
              random -= relayer.reputation;
              if (random <= 0) return relayer;
          }

          // 3. Rotate across different relayers
          // 4. Use Tor to hide IP from relayer
      }
    references:
      - https://github.com/tornadocash/relayer-registry

  - id: circuit-vulnerability
    severity: CRITICAL
    title: ZK Circuit Vulnerabilities Allow Fund Theft
    description: Bugs in ZK circuits can allow forging proofs to steal funds or break privacy
    symptoms:
      - Unaudited circuits
      - Complex constraint systems
      - Edge cases in field arithmetic
      - Missing range checks
    detection_pattern: "circuit|circom|noir|halo2|cairo"
    solution: |
      // Circuit bugs are catastrophic - can steal ALL funds

      // Common vulnerability patterns:

      // 1. Field overflow
      // Circom uses finite field arithmetic
      // Values wrap around at the field prime
      template Dangerous() {
          signal input a;
          signal input b;
          signal output c;

          // BUG: If a + b > field_prime, wraps around!
          c <== a + b;

          // FIX: Add range checks
          component rangeA = Num2Bits(64);
          rangeA.in <== a;
          component rangeB = Num2Bits(64);
          rangeB.in <== b;
          // Now both are < 2^64, sum can't overflow
      }

      // 2. Under-constrained circuits
      template Underconstrained() {
          signal input secret;
          signal output hash;

          component hasher = Poseidon(1);
          hasher.inputs[0] <== secret;
          hash <== hasher.out;

          // BUG: Nothing constrains relationship
          // Prover can use any secret, any hash

          // FIX: Public inputs must be constrained
          signal input publicHash;
          publicHash === hash;
      }

      // 3. Missing nullifier uniqueness
      // See nullifier-collision edge case

      // Mandatory practices:
      // - Multiple independent audits
      // - Formal verification where possible
      // - Extensive test coverage including edge cases
      // - Bug bounty program before mainnet
    references:
      - https://github.com/0xPARC/zk-bug-tracker

  - id: compliance-risk
    severity: HIGH
    title: Regulatory and Legal Compliance Risks
    description: Privacy protocols may face regulatory action; users may face legal consequences
    symptoms:
      - Using sanctioned protocols
      - Interacting with blacklisted addresses
      - No compliance mechanisms
      - Operating in strict jurisdictions
    detection_pattern: "privacy|mixer|tornado|anonymity"
    solution: |
      // Reality check: Privacy != Illegal, but regulators disagree

      // The Tornado Cash situation:
      // - OFAC sanctioned the protocol (not just addresses)
      // - Core developer arrested
      // - Users who interacted may face scrutiny

      // For protocol developers:

      // 1. Consider optional compliance features
      contract ComplianceAwarePool {
          // Opt-in compliance proof
          function depositWithCompliance(
              bytes32 commitment,
              bytes calldata complianceProof // KYC attestation
          ) external payable {
              require(verifyComplianceAttestation(complianceProof));
              // ... normal deposit
          }

          // Allow withdrawal with audit trail
          function withdrawWithDisclosure(
              bytes calldata proof,
              bytes calldata disclosureCert // Proves source of funds
          ) external {
              // User voluntarily discloses for compliance
          }
      }

      // 2. Implement view keys for auditors
      // User can prove transaction history to regulators

      // 3. Build in geographic restrictions
      // Sadly necessary for legal operation

      // For users:
      // - Understand legal status in your jurisdiction
      // - Don't use sanctioned protocols
      // - Keep records you can disclose if needed
      // - Consider privacy for legitimate reasons only
    references:
      - https://home.treasury.gov/policy-issues/financial-sanctions/recent-actions/20220808

  - id: proof-size-dos
    severity: MEDIUM
    title: Large Proof Size Causes DoS
    description: ZK proofs can be large and expensive to verify on-chain, enabling DoS attacks
    symptoms:
      - High gas costs for verification
      - Transaction size limits exceeded
      - Slow proof verification
      - Block gas limit issues
    detection_pattern: "verify.*proof|proof.*verify|groth16|plonk"
    solution: |
      // Proof verification gas costs:
      // - Groth16: ~200k gas (fixed, small proof)
      // - PLONK: ~300-500k gas (proof size varies)
      // - STARKs: ~1M+ gas (large proofs)

      contract EfficientVerifier {
          // Gas limits for verification
          uint256 constant MAX_VERIFICATION_GAS = 500000;

          function withdrawWithLimit(
              bytes calldata proof,
              // ...
          ) external {
              uint256 gasBefore = gasleft();

              bool valid = verifyProof(proof);

              require(gasBefore - gasleft() < MAX_VERIFICATION_GAS, "DoS protection");
              require(valid, "Invalid proof");
          }

          // Batch verification for multiple proofs (cheaper per proof)
          function batchWithdraw(
              bytes[] calldata proofs,
              // ...
          ) external {
              // Aggregate verification where possible
              // Groth16 supports batch verification
          }
      }

      // Off-chain verification first:
      async function submitWithdrawal(proof) {
          // Verify locally before spending gas
          const isValid = await verifyOffChain(proof);
          if (!isValid) throw "Invalid proof - won't submit";

          return contract.withdraw(proof);
      }
    references:
      - https://vitalik.ca/general/2021/11/05/halo.html

  - id: randomness-exploitation
    severity: HIGH
    title: Weak Randomness in Privacy Protocols
    description: Predictable randomness in commitment or nullifier generation breaks privacy
    symptoms:
      - Using block.timestamp for randomness
      - Deterministic nullifier generation
      - Reused random values
      - Client-side Math.random() for secrets
    detection_pattern: "random|secret|nullifier|commitment"
    solution: |
      // Randomness requirements for privacy:
      // 1. Secret: Must be truly random
      // 2. Nullifier: Must be deterministic from secret
      // 3. Blinding factors: Must be unpredictable

      // BAD: Predictable randomness
      function generateSecretBad() {
          // DON'T: Use block data
          return keccak256(abi.encode(block.timestamp, msg.sender));
          // Anyone can compute this!
      }

      // GOOD: Cryptographically secure randomness
      async function generateSecretGood() {
          // Client-side: Use crypto.getRandomValues
          const secret = ethers.randomBytes(32);

          // Derive nullifier deterministically
          const nullifier = ethers.keccak256(
              ethers.concat([secret, ethers.toBeArray(0)])
          );

          return { secret, nullifier };
      }

      // On-chain randomness (if needed):
      import "@chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol";

      contract SecureRandom is VRFV2WrapperConsumerBase {
          function requestRandomness() external returns (uint256) {
              return requestRandomness(
                  callbackGasLimit,
                  requestConfirmations,
                  numWords
              );
          }

          function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
              // Use randomWords[0] for commitment randomness
          }
      }
    references:
      - https://docs.chain.link/vrf

  - id: ens-identity-link
    severity: MEDIUM
    title: ENS and Identity Services Link Private Addresses
    description: Using ENS or other identity services with stealth addresses defeats privacy
    symptoms:
      - ENS registered for stealth address
      - Lens/Farcaster profiles linked
      - NFT profile pictures
      - On-chain identity attestations
    detection_pattern: "ens|lens|farcaster|identity|profile"
    solution: |
      // Problem: Identity links defeat privacy

      // Attack scenario:
      // 1. User creates stealth address for privacy
      // 2. User registers ENS for convenience
      // 3. ENS lookup reveals the "private" address
      // 4. All transactions now linked to identity

      // Rules for private addresses:

      // 1. NEVER register ENS or identity services
      // 2. NEVER link to social profiles
      // 3. NEVER receive NFTs with identity data

      // For receiving payments privately:
      async function receivePrivatePayment(sender) {
          // Give sender one-time stealth address
          const stealthAddr = await generateStealthAddress();

          // Sender publishes ephemeral key to registry
          // (not linked to receiver identity)

          // Receiver scans registry privately
          // No on-chain identity link created
      }

      // If you need human-readable addresses:
      // Use off-chain resolution that doesn't publish on-chain
      // Example: encrypted address book, Signal contacts
    references:
      - https://eips.ethereum.org/EIPS/eip-5564

  - id: front-running-deposit
    severity: MEDIUM
    title: Front-Running Privacy Pool Deposits
    description: Miners/MEV searchers can observe and front-run deposits to track them
    symptoms:
      - Deposits visible in mempool
      - MEV searchers tracking privacy pools
      - Commitment front-running
    detection_pattern: "deposit|commit"
    solution: |
      // Problem: Deposit txs visible in mempool
      // MEV searchers can:
      // 1. See commitment before inclusion
      // 2. Front-run with their own deposit
      // 3. Link your deposit to withdrawal timing

      // Solution 1: Private mempool
      async function privateDeposit(commitment) {
          const privateTx = await wallet.signTransaction({
              to: poolAddress,
              data: pool.interface.encodeFunctionData("deposit", [commitment]),
              value: ethers.parseEther("1")
          });

          // Submit to Flashbots/MEV Blocker
          const bundle = [{signedTransaction: privateTx}];
          await flashbotsProvider.sendBundle(bundle, targetBlock);
      }

      // Solution 2: Commit-reveal deposit
      contract PrivateDeposit {
          mapping(bytes32 => uint256) public pendingDeposits;

          // Phase 1: Commit (hides commitment)
          function commitDeposit(bytes32 commitmentHash) external payable {
              require(msg.value == DENOMINATION);
              pendingDeposits[commitmentHash] = block.timestamp;
          }

          // Phase 2: Reveal (after 1 block)
          function revealDeposit(bytes32 commitment, bytes32 salt) external {
              bytes32 commitHash = keccak256(abi.encode(commitment, salt));
              require(pendingDeposits[commitHash] > 0, "No pending");
              require(block.timestamp > pendingDeposits[commitHash], "Wait 1 block");

              delete pendingDeposits[commitHash];
              _addToTree(commitment);
          }
      }
    references:
      - https://docs.flashbots.net/flashbots-protect/overview
