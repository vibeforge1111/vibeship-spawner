# Procedural Generation - Collaboration
# How this skill works with other skills in the ecosystem

id: procedural-generation
skill: Procedural Generation
version: "2.0.0"

# ============================================================================
# Receiving Work From Other Skills
# ============================================================================

receives_from:

  - skill: game-design-core
    description: |
      Game design provides the "what" and "why" - procedural generation provides
      the "how". Without design direction, generation is aimless.
    receives:
      - Gameplay requirements and constraints
      - Target session length and pacing
      - Difficulty curve specifications
      - Player progression requirements
      - Replayability goals
      - Risk/reward balance targets
    provides:
      - Generated level layouts
      - Procedural content parameters
      - Seed management systems
      - Variety distribution reports
    integration_example: |
      // Game design says: "Players should reach boss after 5-7 rooms"
      // Procedural generation implements:
      class ConstrainedDungeonGenerator {
        generate(params) {
          return {
            rooms: this.generateRooms({
              minRooms: params.minRoomsBeforeBoss || 5,
              maxRooms: params.maxRoomsBeforeBoss || 7,
              bossRoomRequired: true,
              difficultyProgression: params.difficultyCurve
            }),
            validation: {
              criticalPath: this.validateCriticalPathLength(5, 7),
              bossAccessible: this.validateBossReachable()
            }
          };
        }
      }

  - skill: level-design
    description: |
      Level design provides the principles and vocabulary; procedural generation
      implements them at scale. Hand-authored templates and procedural glue work
      together.
    receives:
      - Level flow principles (gates, keys, backtracking)
      - Landmark requirements
      - Pacing guidelines
      - Hand-authored room templates
      - Tile set compatibility rules
      - Navigation requirements
    provides:
      - Generated room layouts for polish
      - Procedural corridors and connections
      - Spawn point suggestions
      - Item placement candidates
    integration_example: |
      // Level design provides room templates
      const TEMPLATES = {
        entrance: ['entrance_a.tmx', 'entrance_b.tmx'],
        boss: ['boss_arena_large.tmx'],
        treasure: ['treasure_room_1.tmx', 'treasure_room_2.tmx']
      };

      // Procedural generation connects them
      class HybridDungeonGenerator {
        generate(seed) {
          const rng = new PRNG(seed);

          // Use hand-designed templates for critical rooms
          const entrance = this.loadTemplate(rng.pick(TEMPLATES.entrance));
          const boss = this.loadTemplate(rng.pick(TEMPLATES.boss));

          // Generate procedural rooms between
          const middleRooms = this.generateRooms(rng, { count: 5 });

          // Connect with procedural corridors
          return this.connectRooms([entrance, ...middleRooms, boss]);
        }
      }

  - skill: worldbuilding
    description: |
      Worldbuilding provides lore and setting; procedural generation respects
      and reinforces it through consistent content creation.
    receives:
      - World lore and rules
      - Geographic constraints (where deserts exist, etc.)
      - Named location requirements
      - Cultural/architectural patterns
      - Historical events affecting geography
      - Faction territories
    provides:
      - Terrain generation respecting lore
      - Biome distribution
      - Procedural place names
      - Ruin/structure placement
      - Resource distribution
    integration_example: |
      // Worldbuilding says: "The Ashlands were scorched by dragon war"
      class LoreAwareTerrain {
        generateBiome(x, y, worldLore) {
          const baseBiome = this.getClimateBasedBiome(x, y);

          // Override based on lore events
          if (worldLore.regions.ashlands.contains(x, y)) {
            return this.applyAshlandsMutation(baseBiome, {
              vegetation: 0.1,  // Mostly dead
              structures: ['ruined_fortress', 'dragon_skeleton'],
              groundColor: 'scorched'
            });
          }

          return baseBiome;
        }

        generatePlaceName(x, y, biome, worldLore) {
          // Use lore-appropriate naming conventions
          const culture = worldLore.getCultureAt(x, y);
          return this.nameGenerator.generate({
            syllables: culture.namingPatterns,
            suffixes: biome.placeSuffixes
          });
        }
      }

  - skill: narrative-design
    description: |
      Narrative design provides story beats; procedural generation creates
      spaces that support them without railroading.
    receives:
      - Story beat requirements
      - Character encounter needs
      - Environmental storytelling goals
      - Pacing between narrative moments
      - Optional vs mandatory story content
    provides:
      - Locations for story events
      - Environmental storytelling elements
      - Procedural side content
      - Emergent narrative hooks
    integration_example: |
      // Narrative: "Player should find evidence of betrayal in any dungeon"
      class NarrativeAwareDungeon {
        generate(params, narrativeRequirements) {
          const dungeon = this.baseGenerate(params);

          // Inject narrative requirements
          for (const req of narrativeRequirements) {
            if (req.type === 'environmental_storytelling') {
              dungeon.placeStoryElement({
                element: req.element,  // e.g., 'betrayal_letter'
                placement: 'hidden_but_findable',
                frequency: req.frequency  // 1 per dungeon
              });
            }
          }

          return dungeon;
        }
      }

  - skill: threejs-3d-graphics
    description: |
      3D graphics needs mesh data from terrain; procedural generation provides
      heightmaps, biome data, and chunk boundaries.
    receives:
      - LOD requirements
      - Mesh budget constraints
      - Streaming architecture
      - Material capabilities
    provides:
      - Heightmap data
      - Biome/material indices
      - Chunk boundary definitions
      - Normal and tangent data
      - Object placement coordinates
    integration_example: |
      // Export format for 3D rendering
      class TerrainExporter {
        exportChunk(chunk) {
          return {
            // Raw height data for mesh generation
            heightmap: chunk.heights,  // Float32Array
            normalMap: this.computeNormals(chunk.heights),

            // Material blending
            splatMap: chunk.biomeWeights,  // Which material where
            biomes: chunk.biomeTypes,      // Material IDs

            // Object placement
            vegetation: chunk.trees.map(t => ({
              position: t.position,
              type: t.species,
              scale: t.size,
              rotation: t.rotation
            })),

            // LOD hints
            lodHints: {
              maxHeight: chunk.maxHeight,
              complexity: chunk.polygonEstimate
            }
          };
        }
      }

  - skill: shader-programming
    description: |
      Shaders can use procedural generation at render time for effects,
      textures, and detail that doesn't need to persist.
    receives:
      - Shader-based noise requirements
      - Real-time generation needs
      - GPU-friendly algorithm requests
    provides:
      - Noise function specifications
      - Seed values for shader consistency
      - Lookup table data
      - Algorithm pseudocode for GLSL/HLSL
    integration_example: |
      // Provide shader-compatible noise specs
      const noiseSpec = {
        type: 'simplex',
        octaves: 4,
        persistence: 0.5,
        lacunarity: 2.0,
        scale: 0.01,

        // For shader implementation
        glsl: `
          float fbm(vec2 p) {
            float total = 0.0;
            float amplitude = 1.0;
            float frequency = ${scale};

            for (int i = 0; i < ${octaves}; i++) {
              total += snoise(p * frequency) * amplitude;
              amplitude *= ${persistence};
              frequency *= ${lacunarity};
            }

            return total;
          }
        `
      };

# ============================================================================
# Handing Work To Other Skills
# ============================================================================

hands_to:

  - skill: level-design
    trigger: "polish|refine|hand-craft|playtest feedback|designer review"
    description: |
      Generated layouts need designer review and polish. Hand off base layouts
      for refinement, especially for critical areas.
    provides:
      - Generated level layouts
      - Validation reports
      - Seed for regeneration
      - Statistics (room count, path length, etc.)
    expects_back:
      - Polished layouts
      - Template additions
      - Rule adjustments
    handoff_example: |
      /**
       * HANDOFF TO LEVEL-DESIGN
       *
       * Generated base layout for dungeon floor 3.
       *
       * Seed: 847293847
       * Stats:
       * - Rooms: 12
       * - Critical path: 7 rooms
       * - Dead ends: 3
       * - Treasure rooms: 2
       *
       * Validation passed. Requesting designer review for:
       * - Boss room approach (rooms 10-12)
       * - Optional area (rooms 8-9)
       *
       * Export: dungeon_f3_layout.tmx
       */

  - skill: game-ai-behavior
    trigger: "ai|pathfinding|enemy|npc|navigation|spawn"
    description: |
      AI needs navigation meshes, spawn points, and patrol routes from
      generated content.
    provides:
      - Walkable area mask
      - Navigation mesh data
      - Spawn point candidates
      - Patrol route suggestions
      - Cover positions
      - Line-of-sight blockers
    handoff_example: |
      /**
       * HANDOFF TO GAME-AI-BEHAVIOR
       *
       * Generated level exported for AI setup.
       *
       * Navigation data:
       * - Walkable tiles: 847
       * - Nav mesh nodes: 156
       * - Connection graph: nav_graph.json
       *
       * Spawn suggestions:
       * - Player spawn: (12, 45)
       * - Enemy spawns: [(34, 12), (67, 23), ...]
       * - Boss spawn: (89, 67)
       *
       * Patrol routes pre-computed:
       * - Route A: Guard perimeter
       * - Route B: Treasure room patrol
       */

  - skill: game-design-core
    trigger: "balance|difficulty|tuning|pacing|playtest"
    description: |
      Generated content needs game design review for balance and pacing.
    provides:
      - Generation statistics
      - Difficulty distribution
      - Resource placement data
      - Player path analysis
    handoff_example: |
      /**
       * HANDOFF TO GAME-DESIGN-CORE
       *
       * Generated 1000 dungeons for balance analysis.
       *
       * Statistics:
       * - Average clear time: 12.3 minutes (target: 10-15)
       * - Difficulty variance: 2.1 (target: <3.0)
       * - Treasure distribution: Normal, mean=5.2 per floor
       * - Dead end rate: 18% (designer preference?)
       *
       * Outliers requiring review:
       * - Seed 847293: Unusually long critical path (12 rooms)
       * - Seed 293847: High enemy density in spawn area
       */

  - skill: worldbuilding
    trigger: "lore|story|history|culture|names"
    description: |
      Generated worlds need worldbuilding review for narrative consistency.
    provides:
      - Generated geography
      - Procedural names (for approval)
      - Settlement placements
      - Resource distributions
    handoff_example: |
      /**
       * HANDOFF TO WORLDBUILDING
       *
       * Generated world map for lore integration.
       *
       * Geography:
       * - Continents: 3 major, 5 minor
       * - Mountain ranges: 7
       * - River systems: 12
       * - Biomes: All 8 types represented
       *
       * Procedural names needing approval:
       * - Capital city: "Valdermoor" (generated from Northern culture)
       * - Major river: "Silverscar" (generated from geography)
       *
       * Requesting: Historical event placement, faction territories
       */

  - skill: narrative-design
    trigger: "story|quest|dialogue|encounter|event"
    description: |
      Generated spaces need narrative hooks and story integration.
    provides:
      - Interesting locations for story beats
      - Environmental storytelling opportunities
      - Random encounter spaces
      - Secret area locations
    handoff_example: |
      /**
       * HANDOFF TO NARRATIVE-DESIGN
       *
       * Generated dungeon with narrative hook opportunities.
       *
       * Suggested story locations:
       * - Room 7: Large chamber, good for revelation scene
       * - Room 3: Dead end, good for optional lore discovery
       * - Room 11: Before boss, good for NPC encounter
       *
       * Environmental storytelling spots:
       * - Collapsed tunnel (rooms 5-6): Past disaster?
       * - Empty treasure room: Someone got here first?
       */

# ============================================================================
# Delegation Triggers
# ============================================================================

delegation_triggers:
  - pattern: "render|visualize|3d|mesh|graphics"
    delegate_to: threejs-3d-graphics
    context: "Procedural content ready for 3D rendering"

  - pattern: "shader|material|texture|real-?time"
    delegate_to: shader-programming
    context: "Need shader-based procedural effects"

  - pattern: "balance|difficulty|tuning|pacing"
    delegate_to: game-design-core
    context: "Generated content needs game design review"

  - pattern: "level.*design|polish|refine|template"
    delegate_to: level-design
    context: "Generated layout needs designer polish"

  - pattern: "story|lore|narrative|quest"
    delegate_to: narrative-design
    context: "Generated space needs narrative integration"

  - pattern: "world.*build|history|culture|faction"
    delegate_to: worldbuilding
    context: "Procedural world needs lore integration"

  - pattern: "ai|pathfind|enemy|npc|behavior"
    delegate_to: game-ai-behavior
    context: "Generated level needs AI setup"

  - pattern: "physics|collision|movement"
    delegate_to: game-physics
    context: "Generated content needs physics setup"

# ============================================================================
# Common Skill Combinations
# ============================================================================

common_combinations:
  - name: Roguelike Development
    skills:
      - procedural-generation
      - game-design-core
      - pixel-art-sprites
    workflow: |
      1. Define gameplay parameters (game-design-core)
      2. Implement dungeon generator (procedural-generation)
      3. Create tileset and sprites (pixel-art-sprites)
      4. Iterate on balance (game-design-core)

  - name: Open World Terrain
    skills:
      - procedural-generation
      - threejs-3d-graphics
      - worldbuilding
      - shader-programming
    workflow: |
      1. Define world lore and geography (worldbuilding)
      2. Generate heightmaps and biomes (procedural-generation)
      3. Create terrain shaders (shader-programming)
      4. Build 3D rendering system (threejs-3d-graphics)

  - name: Story-Driven Roguelite
    skills:
      - procedural-generation
      - narrative-design
      - game-design-core
      - level-design
    workflow: |
      1. Define story beats and pacing (narrative-design)
      2. Create room templates (level-design)
      3. Build generator with story hooks (procedural-generation)
      4. Balance difficulty curve (game-design-core)

  - name: Survival Crafting Game
    skills:
      - procedural-generation
      - worldbuilding
      - game-ai-behavior
      - game-design-core
    workflow: |
      1. Define biomes and resources (worldbuilding)
      2. Generate infinite terrain (procedural-generation)
      3. Place creatures and AI (game-ai-behavior)
      4. Balance resource distribution (game-design-core)

# ============================================================================
# Cross-Domain Insights
# ============================================================================

cross_domain_insights:
  - domain: Biology
    insight: L-systems model plant growth mathematically
    application: Generate realistic trees, plants, and organic structures
    skill_connection: Can inform shader-programming for growth animations

  - domain: Geology
    insight: Erosion and tectonic processes shape terrain over time
    application: Apply realistic erosion algorithms post-generation
    skill_connection: Helps worldbuilding create believable geography

  - domain: Urban Planning
    insight: Cities follow transportation and economic patterns
    application: Generate realistic city layouts with districts
    skill_connection: Informs level-design for urban environments

  - domain: Music Theory
    insight: Markov chains model melodic progression
    application: Generate procedural music and ambient sound
    skill_connection: Can work with audio-design skills

  - domain: Linguistics
    insight: Phonotactic rules govern valid word structures
    application: Generate plausible fantasy names and languages
    skill_connection: Supports worldbuilding with consistent naming

  - domain: Architecture
    insight: Buildings follow structural rules and cultural styles
    application: Generate buildings that look structurally sound
    skill_connection: Level-design can polish generated structures

# ============================================================================
# Prerequisites and Setup
# ============================================================================

prerequisites:
  required_knowledge:
    - Basic mathematics (interpolation, modular arithmetic)
    - Random number generation concepts
    - Data structures (grids, graphs, trees)
    - Game design fundamentals

  recommended_knowledge:
    - Graph algorithms (BFS, DFS, A*)
    - Constraint satisfaction
    - Basic statistics (distributions, variance)
    - Performance profiling

  tools:
    - Code editor with good debugging
    - Canvas/visualization library for debugging
    - Parameter tweaking UI (dat.GUI or similar)
    - Testing framework for seed-based testing

environment_setup: |
  # Quick start for JavaScript procedural generation

  # 1. Create project
  npm create vite@latest procgen-demo -- --template vanilla-ts
  cd procgen-demo
  npm install

  # 2. Install useful packages
  npm install simplex-noise  # Quick noise functions
  npm install seedrandom     # Seedable random (or write your own)
  npm install dat.gui        # Parameter tweaking

  # 3. Create visualization helper
  cat > src/visualize.ts << 'EOF'
  export function createCanvas(width: number, height: number) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    document.body.appendChild(canvas);
    return canvas.getContext('2d')!;
  }

  export function drawGrid(ctx: CanvasRenderingContext2D, grid: number[][], colorFn: (v: number) => string) {
    const cellW = ctx.canvas.width / grid[0].length;
    const cellH = ctx.canvas.height / grid.length;

    for (let y = 0; y < grid.length; y++) {
      for (let x = 0; x < grid[0].length; x++) {
        ctx.fillStyle = colorFn(grid[y][x]);
        ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
      }
    }
  }
  EOF

  # 4. Start development
  npm run dev
