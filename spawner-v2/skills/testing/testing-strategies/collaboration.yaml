# Collaboration - Testing Strategies
# How this skill works with other skills

version: 1.0.0
skill_id: testing-strategies

prerequisites:
  required: []

  recommended:
    - skill: react-patterns
      reason: "Component testing patterns"
      what_to_know:
        - "Component structure"
        - "Hooks and state"
        - "Event handling"

    - skill: backend
      reason: "API testing patterns"
      what_to_know:
        - "REST/GraphQL APIs"
        - "Database interactions"
        - "Authentication"

  knowledge:
    - "JavaScript/TypeScript basics"
    - "Async/await patterns"
    - "DOM fundamentals"

delegation_triggers:
  - trigger: "user needs CI/CD setup for tests"
    delegate_to: cicd-pipelines
    context: "Test automation in pipeline"

  - trigger: "user needs performance testing"
    delegate_to: performance-profiling
    context: "Load testing, benchmarks"

  - trigger: "user needs security testing"
    delegate_to: security
    context: "Security scans, penetration testing"

  - trigger: "user needs accessibility testing"
    delegate_to: accessibility
    context: "axe-core, screen reader testing"

receives_context_from:
  - skill: react-patterns
    receives:
      - "Components to test"
      - "State management approach"
      - "Custom hooks"

  - skill: backend
    receives:
      - "API endpoints to test"
      - "Database models"
      - "Business logic"

  - skill: python-backend
    receives:
      - "FastAPI/Django code to test"
      - "pytest fixtures needed"

provides_context_to:
  - skill: cicd-pipelines
    provides:
      - "Test commands"
      - "Coverage requirements"
      - "Parallelization config"

  - skill: backend
    provides:
      - "Test patterns for new features"
      - "Mocking strategies"
      - "Integration test setup"

escalation_paths:
  - situation: "Test performance issues"
    escalate_to: performance-profiling
    context: "Test suite optimization"

  - situation: "Security testing needs"
    escalate_to: security
    context: "Security-focused tests"

  - situation: "CI/CD integration"
    escalate_to: cicd-pipelines
    context: "Pipeline configuration"

workflow_integration:
  typical_sequence:
    1:
      step: "Identify test needs"
      skills: [testing-strategies]
      output: "Test plan (unit, integration, E2E)"

    2:
      step: "Set up test infrastructure"
      skills: [testing-strategies]
      output: "Test config, fixtures, factories"

    3:
      step: "Write unit tests"
      skills: [testing-strategies]
      output: "Component and function tests"

    4:
      step: "Write integration tests"
      skills: [testing-strategies]
      output: "API and database tests"

    5:
      step: "Write E2E tests"
      skills: [testing-strategies]
      output: "Critical path tests"

    6:
      step: "CI/CD integration"
      skills: [cicd-pipelines]
      output: "Automated test runs"

  decision_points:
    - question: "Jest or Vitest?"
      guidance: |
        Jest when:
        - Not using Vite
        - Need extensive ecosystem
        - Create React App

        Vitest when:
        - Using Vite
        - Want faster execution
        - ESM-first project

    - question: "Playwright or Cypress?"
      guidance: |
        Playwright when:
        - Need multi-browser support
        - Want faster execution
        - API testing included
        - CI environment

        Cypress when:
        - Better debugging experience
        - Component testing focus
        - Learning E2E testing

    - question: "Mock or real database?"
      guidance: |
        Mock when:
        - Unit testing pure logic
        - Speed is critical
        - Isolation needed

        Real database when:
        - Integration testing
        - Testing queries/ORM
        - Testing transactions

collaboration_patterns:
  with_react:
    when: "Testing React components"
    approach: |
      React Testing Setup:

      // vitest.config.ts
      import { defineConfig } from 'vitest/config';
      import react from '@vitejs/plugin-react';

      export default defineConfig({
        plugins: [react()],
        test: {
          environment: 'jsdom',
          setupFiles: ['./src/test/setup.ts'],
          globals: true,
        },
      });

      // src/test/setup.ts
      import '@testing-library/jest-dom';
      import { cleanup } from '@testing-library/react';

      afterEach(() => {
        cleanup();
      });

      // Example test
      import { render, screen } from '@testing-library/react';
      import userEvent from '@testing-library/user-event';
      import { Button } from './Button';

      describe('Button', () => {
        it('calls onClick when clicked', async () => {
          const handleClick = vi.fn();
          const user = userEvent.setup();

          render(<Button onClick={handleClick}>Click me</Button>);
          await user.click(screen.getByRole('button'));

          expect(handleClick).toHaveBeenCalledOnce();
        });
      });

  with_nextjs:
    when: "Testing Next.js applications"
    approach: |
      Next.js Testing:

      // jest.config.js
      const nextJest = require('next/jest');

      const createJestConfig = nextJest({
        dir: './',
      });

      const customJestConfig = {
        setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
        testEnvironment: 'jest-environment-jsdom',
      };

      module.exports = createJestConfig(customJestConfig);


      // Testing Server Components
      // Use integration/E2E tests for RSC

      // Testing API Routes
      import { createMocks } from 'node-mocks-http';
      import handler from '@/app/api/users/route';

      test('GET /api/users', async () => {
        const { req, res } = createMocks({
          method: 'GET',
        });

        await handler(req, res);

        expect(res._getStatusCode()).toBe(200);
        expect(JSON.parse(res._getData())).toHaveProperty('users');
      });

  with_api:
    when: "Testing APIs"
    approach: |
      API Testing Patterns:

      // Supertest (Express/Node)
      import request from 'supertest';
      import { app } from '../app';

      describe('Users API', () => {
        it('creates a user', async () => {
          const response = await request(app)
            .post('/api/users')
            .send({ email: 'test@test.com' })
            .expect(201);

          expect(response.body.id).toBeDefined();
        });
      });


      // pytest (Python)
      import pytest
      from httpx import AsyncClient

      @pytest.fixture
      async def client():
          async with AsyncClient(app=app, base_url="http://test") as client:
              yield client

      @pytest.mark.asyncio
      async def test_create_user(client):
          response = await client.post(
              "/users",
              json={"email": "test@test.com"}
          )
          assert response.status_code == 201
          assert response.json()["id"] is not None

platform_integration:
  vitest:
    setup: |
      # Vitest Setup

      npm install -D vitest @testing-library/react @testing-library/user-event jsdom

      // vitest.config.ts
      export default defineConfig({
        test: {
          environment: 'jsdom',
          globals: true,
          setupFiles: './src/test/setup.ts',
          coverage: {
            provider: 'v8',
            reporter: ['text', 'json', 'html'],
          },
        },
      });

      // package.json
      "scripts": {
        "test": "vitest",
        "test:coverage": "vitest run --coverage"
      }
    considerations:
      - "ESM-first, works great with Vite"
      - "Jest-compatible API"
      - "Faster than Jest"

  playwright:
    setup: |
      # Playwright Setup

      npm init playwright@latest

      // playwright.config.ts
      export default defineConfig({
        testDir: './e2e',
        fullyParallel: true,
        forbidOnly: !!process.env.CI,
        retries: process.env.CI ? 2 : 0,
        use: {
          baseURL: 'http://localhost:3000',
          trace: 'retain-on-failure',
          screenshot: 'only-on-failure',
        },
        webServer: {
          command: 'npm run dev',
          port: 3000,
          reuseExistingServer: !process.env.CI,
        },
      });

      // package.json
      "scripts": {
        "test:e2e": "playwright test",
        "test:e2e:ui": "playwright test --ui"
      }
    considerations:
      - "Auto-waiting built in"
      - "Multi-browser support"
      - "Great debugging tools"

  pytest:
    setup: |
      # pytest Setup

      poetry add -D pytest pytest-asyncio pytest-cov httpx

      # pyproject.toml
      [tool.pytest.ini_options]
      asyncio_mode = "auto"
      testpaths = ["tests"]
      addopts = "-v --cov=app --cov-report=term-missing"

      # conftest.py
      import pytest
      from httpx import AsyncClient
      from app.main import app
      from app.database import get_db, Base, engine

      @pytest.fixture
      async def db():
          async with engine.begin() as conn:
              await conn.run_sync(Base.metadata.create_all)
          yield
          async with engine.begin() as conn:
              await conn.run_sync(Base.metadata.drop_all)

      @pytest.fixture
      async def client(db):
          async with AsyncClient(app=app, base_url="http://test") as client:
              yield client
    considerations:
      - "Fixtures are powerful"
      - "Great plugin ecosystem"
      - "Async support with pytest-asyncio"

ecosystem:
  primary_tools:
    - "Vitest / Jest"
    - "Testing Library"
    - "Playwright"
    - "pytest"
    - "MSW (Mock Service Worker)"

  utilities:
    - name: "@testing-library/user-event"
      use_when: "Simulating user interactions"
    - name: msw
      use_when: "Mocking API requests"
    - name: faker
      use_when: "Generating test data"
    - name: test-containers
      use_when: "Database integration tests"

  alternatives:
    - name: Cypress
      use_when: "E2E with great DX, component testing"
      avoid_when: "Need multi-browser or speed"

    - name: Puppeteer
      use_when: "Browser automation beyond testing"
      avoid_when: "Just need testing (use Playwright)"

    - name: Mocha + Chai
      use_when: "Existing project using them"
      avoid_when: "New projects (use Jest/Vitest)"

  deprecated:
    - "Enzyme (use Testing Library)"
    - "request (use httpx)"
    - "Puppeteer for E2E (use Playwright)"
    - "subscriptions-transport-ws tests (use graphql-ws)"
