# Collaboration - Firebase
# How this skill works with other skills

version: 1.0.0
skill_id: firebase

prerequisites:
  required: []

  recommended:
    - skill: frontend
      reason: "Client-side Firebase integration"
      what_to_know:
        - "React/Vue/Angular component lifecycle"
        - "State management patterns"
        - "Effect cleanup on unmount"

    - skill: backend
      reason: "Cloud Functions and server-side patterns"
      what_to_know:
        - "Node.js async patterns"
        - "API design principles"
        - "Error handling patterns"

    - skill: authentication-oauth
      reason: "Complex auth flows beyond Firebase Auth"
      what_to_know:
        - "OAuth 2.0 flows"
        - "Token handling"
        - "Session management"

  knowledge:
    - "JavaScript/TypeScript basics"
    - "Async/await patterns"
    - "NoSQL database concepts"
    - "JSON data structures"

delegation_triggers:
  - trigger: "user needs complex OAuth flow"
    delegate_to: authentication-oauth
    context: "Firebase Auth handles basics, complex flows need OAuth skill"

  - trigger: "user needs payment integration"
    delegate_to: stripe
    context: "Firebase + Stripe common pattern"

  - trigger: "user needs email functionality"
    delegate_to: email
    context: "Firebase doesn't include email - use SendGrid, Resend, etc."

  - trigger: "user needs container deployment"
    delegate_to: devops
    context: "Beyond Firebase Hosting - Kubernetes, Docker"

  - trigger: "user needs relational data model"
    delegate_to: postgres-wizard
    context: "Firestore is wrong choice for highly relational data"

  - trigger: "user needs full-text search"
    delegate_to: elasticsearch-search
    context: "Firestore doesn't support full-text search - use Algolia/Elastic"

receives_context_from:
  - skill: nextjs-app-router
    receives:
      - "Server-side rendering requirements"
      - "Client/server component boundaries"
      - "API route patterns"

  - skill: react-patterns
    receives:
      - "Component architecture"
      - "State management approach"
      - "Hook patterns in use"

  - skill: vue-nuxt
    receives:
      - "Composition API patterns"
      - "Nuxt SSR requirements"
      - "Pinia store structure"

provides_context_to:
  - skill: stripe
    provides:
      - "User authentication (Firebase Auth UIDs)"
      - "User data storage (Firestore)"
      - "Webhook handling (Cloud Functions)"

  - skill: email
    provides:
      - "User email addresses from Firebase Auth"
      - "Trigger events from Cloud Functions"
      - "User preferences from Firestore"

  - skill: devops
    provides:
      - "Firebase project configuration"
      - "Cloud Functions deployment needs"
      - "Monitoring and logging requirements"

escalation_paths:
  - situation: "Query requires full-text search"
    escalate_to: elasticsearch-search
    context: "Firestore can't do full-text search - need Algolia, Typesense, or Elastic"

  - situation: "Data is highly relational"
    escalate_to: postgres-wizard
    context: "Consider PostgreSQL if data requires complex joins"

  - situation: "Complex auth requirements"
    escalate_to: authentication-oauth
    context: "Custom OAuth providers, enterprise SSO"

  - situation: "High-volume background processing"
    escalate_to: bullmq
    context: "Cloud Functions have timeout limits - need proper queue"

workflow_integration:
  typical_sequence:
    1:
      step: "Initialize Firebase project"
      skills: [firebase]
      output: "firebase init with emulators configured"

    2:
      step: "Design data model"
      skills: [firebase]
      output: "Firestore collections optimized for queries"

    3:
      step: "Implement security rules"
      skills: [firebase]
      output: "Tested security rules with proper auth checks"

    4:
      step: "Build client features"
      skills: [firebase, frontend]
      output: "React/Vue components with Firebase integration"

    5:
      step: "Add Cloud Functions"
      skills: [firebase, backend]
      output: "Server-side logic, triggers, scheduled tasks"

    6:
      step: "Deploy and monitor"
      skills: [firebase, devops]
      output: "Production deployment with monitoring"

  decision_points:
    - question: "Firebase or traditional backend?"
      guidance: |
        Use Firebase when:
        - Rapid prototyping / MVP
        - Real-time features needed
        - Mobile-first apps
        - Small team, no DevOps resources
        - Read-heavy workloads

        Consider alternatives when:
        - Complex relational data
        - Heavy server-side processing
        - Need for complex queries (JOINs, full-text)
        - Data export/migration is a concern
        - Strict data residency requirements

    - question: "Firestore or Realtime Database?"
      guidance: |
        Firestore (recommended for most):
        - Richer queries
        - Better scaling
        - Offline support
        - Structured data

        Realtime Database:
        - Simpler pricing (bandwidth-based)
        - Lower latency for simple data
        - Better for streaming tiny updates
        - Good for presence/status

    - question: "Firebase Auth or Auth0/Clerk?"
      guidance: |
        Firebase Auth:
        - Free for most use cases
        - Simple integration
        - Basic social login
        - Email/password, phone

        Auth0/Clerk:
        - Enterprise SSO (SAML, OIDC)
        - Better admin UI
        - More customization
        - Higher cost

collaboration_patterns:
  with_frontend:
    when: "Building client-side Firebase features"
    approach: |
      React + Firebase pattern:

      // 1. Initialize once at app root
      // lib/firebase.ts
      import { initializeApp, getApps } from 'firebase/app';
      import { getAuth } from 'firebase/auth';
      import { getFirestore } from 'firebase/firestore';

      const firebaseConfig = { ... };

      const app = getApps().length ? getApps()[0] : initializeApp(firebaseConfig);
      export const auth = getAuth(app);
      export const db = getFirestore(app);

      // 2. Auth context provider
      // contexts/AuthContext.tsx
      import { createContext, useContext, useEffect, useState } from 'react';
      import { onAuthStateChanged, User } from 'firebase/auth';
      import { auth } from '@/lib/firebase';

      const AuthContext = createContext<{ user: User | null }>({ user: null });

      export function AuthProvider({ children }) {
        const [user, setUser] = useState<User | null>(null);
        const [loading, setLoading] = useState(true);

        useEffect(() => {
          return onAuthStateChanged(auth, (user) => {
            setUser(user);
            setLoading(false);
          });
        }, []);

        if (loading) return <Loading />;
        return <AuthContext.Provider value={{ user }}>{children}</AuthContext.Provider>;
      }

      // 3. Custom hooks for data
      // hooks/useDocument.ts
      export function useDocument<T>(path: string) {
        const [data, setData] = useState<T | null>(null);
        const [loading, setLoading] = useState(true);

        useEffect(() => {
          const unsub = onSnapshot(doc(db, path), (snap) => {
            setData(snap.exists() ? snap.data() as T : null);
            setLoading(false);
          });
          return unsub;
        }, [path]);

        return { data, loading };
      }

  with_nextjs:
    when: "Next.js App Router + Firebase"
    approach: |
      Firebase with Next.js App Router:

      // Client components for Firebase
      // components/Posts.tsx
      'use client';

      import { useEffect, useState } from 'react';
      import { collection, query, orderBy, limit, onSnapshot } from 'firebase/firestore';
      import { db } from '@/lib/firebase';

      export function Posts() {
        const [posts, setPosts] = useState([]);

        useEffect(() => {
          const q = query(
            collection(db, 'posts'),
            orderBy('createdAt', 'desc'),
            limit(10)
          );

          return onSnapshot(q, (snap) => {
            setPosts(snap.docs.map(d => ({ id: d.id, ...d.data() })));
          });
        }, []);

        return <ul>{posts.map(p => <li key={p.id}>{p.title}</li>)}</ul>;
      }

      // Server-side with Admin SDK (API routes / Server Actions)
      // app/api/posts/route.ts
      import { getFirestore } from 'firebase-admin/firestore';
      import { initAdmin } from '@/lib/firebase-admin';

      initAdmin();
      const db = getFirestore();

      export async function GET() {
        const snap = await db.collection('posts')
          .orderBy('createdAt', 'desc')
          .limit(10)
          .get();

        return Response.json(snap.docs.map(d => ({ id: d.id, ...d.data() })));
      }

  with_stripe:
    when: "Payments with Firebase"
    approach: |
      Firebase + Stripe pattern:

      // 1. Store Stripe customer ID in Firestore
      // Cloud Function to create Stripe customer
      export const createStripeCustomer = onDocumentCreated(
        'users/{userId}',
        async (event) => {
          const user = event.data?.data();
          const userId = event.params.userId;

          const customer = await stripe.customers.create({
            email: user.email,
            metadata: { firebaseUID: userId }
          });

          await db.doc(`users/${userId}`).update({
            stripeCustomerId: customer.id
          });
        }
      );

      // 2. Create checkout session
      export const createCheckout = onCall(async (request) => {
        const uid = request.auth?.uid;
        if (!uid) throw new Error('Unauthenticated');

        const userDoc = await db.doc(`users/${uid}`).get();
        const customerId = userDoc.data()?.stripeCustomerId;

        const session = await stripe.checkout.sessions.create({
          customer: customerId,
          line_items: [{ price: 'price_xxx', quantity: 1 }],
          mode: 'subscription',
          success_url: 'https://app.com/success',
          cancel_url: 'https://app.com/cancel',
        });

        return { url: session.url };
      });

      // 3. Handle webhooks
      export const stripeWebhook = onRequest(async (req, res) => {
        const sig = req.headers['stripe-signature'];
        const event = stripe.webhooks.constructEvent(
          req.rawBody, sig, webhookSecret
        );

        switch (event.type) {
          case 'checkout.session.completed':
            const session = event.data.object;
            const customerId = session.customer;

            // Find user by Stripe customer ID
            const users = await db.collection('users')
              .where('stripeCustomerId', '==', customerId)
              .get();

            if (!users.empty) {
              await users.docs[0].ref.update({
                subscriptionStatus: 'active',
                subscriptionId: session.subscription
              });
            }
            break;
        }

        res.json({ received: true });
      });

platform_integration:
  emulators:
    setup: |
      # Firebase Emulator setup

      # Install Firebase CLI
      npm install -g firebase-tools

      # Login
      firebase login

      # Initialize project
      firebase init

      # Select emulators:
      # - Auth Emulator
      # - Firestore Emulator
      # - Functions Emulator
      # - Hosting Emulator

      # Start emulators
      firebase emulators:start

      # With persistent data
      firebase emulators:start --import=./emulator-data --export-on-exit

      # In code, connect to emulators
      if (process.env.NODE_ENV === 'development') {
        connectAuthEmulator(auth, 'http://localhost:9099');
        connectFirestoreEmulator(db, 'localhost', 8080);
        connectFunctionsEmulator(functions, 'localhost', 5001);
      }
    considerations:
      - "Use emulators for all development"
      - "Test security rules with @firebase/rules-unit-testing"
      - "Export emulator data for consistent dev environment"

  ci_cd:
    setup: |
      # GitHub Actions for Firebase

      # .github/workflows/deploy.yml
      name: Deploy to Firebase

      on:
        push:
          branches: [main]

      jobs:
        deploy:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4

            - uses: actions/setup-node@v4
              with:
                node-version: '20'
                cache: 'npm'

            - run: npm ci

            - name: Deploy to Firebase
              uses: FirebaseExtended/action-hosting-deploy@v0
              with:
                repoToken: '${{ secrets.GITHUB_TOKEN }}'
                firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
                channelId: live
                projectId: your-project-id

      # For Functions
            - name: Deploy Functions
              run: |
                npm install -g firebase-tools
                firebase deploy --only functions --token "${{ secrets.FIREBASE_TOKEN }}"
    considerations:
      - "Use service account for CI deployments"
      - "Test security rules in CI before deploy"
      - "Use preview channels for PR previews"

ecosystem:
  primary_tools:
    - "Firebase Console"
    - "Firebase CLI (firebase-tools)"
    - "Firebase Emulator Suite"
    - "Firestore Data Viewer"

  extensions:
    - name: "Resize Images"
      use_when: "Auto-resize uploaded images"
    - name: "Translate Text"
      use_when: "Multi-language content"
    - name: "Run Payments with Stripe"
      use_when: "Stripe integration"
    - name: "Trigger Email"
      use_when: "Transactional emails from Firestore"

  alternatives:
    - name: Supabase
      use_when: "Need PostgreSQL, open source preference"
      avoid_when: "Need Firebase's mobile SDKs, real-time performance"

    - name: AWS Amplify
      use_when: "Already on AWS, need more AWS services"
      avoid_when: "Want simpler setup, prefer Google ecosystem"

    - name: Appwrite
      use_when: "Self-hosted, open source requirement"
      avoid_when: "Need enterprise support, managed service"

  deprecated:
    - "Firebase v8 SDK (use modular v9+)"
    - "Cloud Functions v1 (use v2)"
    - "firebase.initializeApp() (use modular initializeApp())"
