# Collaboration - Salesforce Development
# How this skill works with other skills

version: 1.0.0
skill_id: salesforce-development

prerequisites:
  required: []

  recommended:
    - skill: backend
      reason: "API design patterns for integrations"
      what_to_know:
        - "REST API patterns"
        - "OAuth flows"
        - "Error handling"

    - skill: frontend
      reason: "JavaScript/React for LWC development"
      what_to_know:
        - "Component lifecycle"
        - "Event handling"
        - "State management"

    - skill: test-architect
      reason: "Testing Apex and LWC"
      what_to_know:
        - "Unit testing patterns"
        - "Mocking strategies"
        - "Code coverage requirements"

delegation_triggers:
  - trigger: "user needs external API integration"
    delegate_to: backend
    context: "REST API design, external system sync"

  - trigger: "user needs complex UI beyond LWC"
    delegate_to: frontend
    context: "Custom portal with React/Next.js"

  - trigger: "user needs HubSpot integration"
    delegate_to: hubspot-integration
    context: "Salesforce-HubSpot sync patterns"

  - trigger: "user needs data warehouse sync"
    delegate_to: data-engineer
    context: "ETL from Salesforce to warehouse"

  - trigger: "user needs payment processing"
    delegate_to: stripe-integration
    context: "Beyond Salesforce Billing"

  - trigger: "user needs advanced auth"
    delegate_to: auth-specialist
    context: "SSO, SAML, custom portals"

receives_context_from:
  - skill: backend
    receives:
      - "API design patterns"
      - "Webhook handling"
      - "Queue patterns"

  - skill: frontend
    receives:
      - "Component patterns"
      - "State management"
      - "Event architecture"

  - skill: devops
    receives:
      - "CI/CD patterns"
      - "Environment management"
      - "Deployment automation"

provides_context_to:
  - skill: hubspot-integration
    provides:
      - "CRM data structures"
      - "Object relationships"
      - "Sync patterns"

  - skill: workflow-automation
    provides:
      - "Salesforce triggers"
      - "Platform events"
      - "Outbound messaging"

  - skill: data-engineer
    provides:
      - "SOQL patterns"
      - "Bulk API usage"
      - "Data export strategies"

escalation_paths:
  - situation: "Complex external integrations"
    escalate_to: backend
    context: "Middleware, ESB patterns"

  - situation: "AppExchange packaging"
    escalate_to: devops
    context: "2GP, security review prep"

  - situation: "Marketing Cloud integration"
    escalate_to: email-marketing
    context: "Journey Builder, data extensions"

  - situation: "Custom analytics"
    escalate_to: analytics-specialist
    context: "Beyond Salesforce Reports/Dashboards"

workflow_integration:
  typical_sequence:
    1:
      step: "Set up Salesforce DX project"
      skills: [salesforce-development]
      output: "sfdx-project.json, scratch org config"

    2:
      step: "Create scratch org for development"
      skills: [salesforce-development]
      output: "Working scratch org with config"

    3:
      step: "Implement Apex business logic"
      skills: [salesforce-development]
      output: "Apex classes, triggers with handlers"

    4:
      step: "Build Lightning Web Components"
      skills: [salesforce-development, frontend]
      output: "LWC components with tests"

    5:
      step: "Implement external integrations"
      skills: [salesforce-development, backend]
      output: "Named Credentials, callout classes"

    6:
      step: "Write tests (75%+ coverage)"
      skills: [salesforce-development, test-architect]
      output: "Test classes passing"

    7:
      step: "Create package version"
      skills: [salesforce-development, devops]
      output: "2GP package ready for deployment"

    8:
      step: "Deploy to target org"
      skills: [salesforce-development]
      output: "Production deployment"

  decision_points:
    - question: "Managed Package or Unlocked Package?"
      guidance: |
        Managed Package:
        - Namespaced, protected IP
        - AppExchange distribution
        - License enforcement
        - Upgrade paths guaranteed
        - Required for ISV

        Unlocked Package:
        - No namespace (or optional)
        - Internal distribution
        - No IP protection
        - More flexible upgrades
        - Better for enterprise IT

    - question: "Apex or Flow for automation?"
      guidance: |
        Apex:
        - Complex logic
        - External integrations
        - Governor limit control
        - Full error handling
        - Better for developers

        Flow:
        - Simple record updates
        - Approval processes
        - Admin-maintainable
        - Screen flows for UX
        - Better for admins

    - question: "LWC or Aura?"
      guidance: |
        LWC (ALWAYS for new development):
        - Modern web standards
        - Better performance
        - Smaller bundle size
        - Standard JavaScript
        - Active development

        Aura (legacy only):
        - Existing components
        - Deprecated features needed
        - Migration path to LWC
        - Do not start new projects

    - question: "Custom Object or Platform Event?"
      guidance: |
        Custom Object:
        - Persistent data storage
        - Queryable/reportable
        - Relationships
        - Security (CRUD/FLS)
        - Standard CRUD operations

        Platform Event:
        - Event-driven architecture
        - Real-time notifications
        - External system integration
        - Pub/sub pattern
        - No persistent storage

collaboration_patterns:
  with_heroku:
    when: "Need Node.js/Python or stateful compute"
    approach: |
      Heroku Connect for data sync:

      ```javascript
      // Heroku app with Heroku Connect
      // Salesforce data synced to PostgreSQL automatically

      // package.json
      {
        "dependencies": {
          "pg": "^8.11.0",
          "express": "^4.18.0"
        }
      }

      // app.js
      const { Pool } = require('pg');

      const pool = new Pool({
        connectionString: process.env.DATABASE_URL,
        ssl: { rejectUnauthorized: false }
      });

      // Query synced Salesforce data
      app.get('/api/accounts', async (req, res) => {
        const result = await pool.query(
          'SELECT sfid, name, industry FROM salesforce.account'
        );
        res.json(result.rows);
      });

      // Heroku Connect syncs back to Salesforce
      app.post('/api/accounts', async (req, res) => {
        const { name, industry } = req.body;
        await pool.query(
          'INSERT INTO salesforce.account (name, industry) VALUES ($1, $2)',
          [name, industry]
        );
        // Heroku Connect syncs to Salesforce
        res.json({ status: 'syncing' });
      });
      ```

  with_mulesoft:
    when: "Enterprise integration hub needed"
    approach: |
      MuleSoft Anypoint with Salesforce Connector:

      ```xml
      <!-- Mule flow for Salesforce integration -->
      <flow name="salesforce-sync-flow">
        <!-- Receive webhook from external system -->
        <http:listener config-ref="HTTP_Listener" path="/sync" />

        <!-- Transform to Salesforce format -->
        <ee:transform>
          <ee:message>
            <ee:set-payload><![CDATA[%dw 2.0
              output application/java
              ---
              {
                "Name": payload.customerName,
                "Industry": payload.industry,
                "External_Id__c": payload.customerId
              }
            ]]></ee:set-payload>
          </ee:message>
        </ee:transform>

        <!-- Upsert to Salesforce -->
        <salesforce:upsert
          config-ref="Salesforce_Config"
          objectType="Account"
          externalIdFieldName="External_Id__c" />

        <!-- Log result -->
        <logger level="INFO" message="Synced: #[payload]" />
      </flow>
      ```

  with_external_api:
    when: "Integrating external REST APIs"
    approach: |
      Named Credentials + Callout pattern:

      ```apex
      // 1. Setup Named Credential (Setup > Named Credentials)
      // Name: ExternalCRM
      // URL: https://api.externalcrm.com
      // Auth: OAuth 2.0 or API Key

      // 2. Apex callout class
      public class ExternalCRMService {
        private static final String ENDPOINT = 'callout:ExternalCRM';

        @future(callout=true)
        public static void syncAccount(Id accountId) {
          Account acc = [
            SELECT Id, Name, Industry, External_CRM_Id__c
            FROM Account
            WHERE Id = :accountId
          ];

          HttpRequest req = new HttpRequest();
          req.setEndpoint(ENDPOINT + '/api/customers');
          req.setMethod(acc.External_CRM_Id__c != null ? 'PUT' : 'POST');
          req.setHeader('Content-Type', 'application/json');
          req.setBody(JSON.serialize(new Map<String, Object>{
            'name' => acc.Name,
            'industry' => acc.Industry,
            'salesforceId' => acc.Id
          }));

          Http http = new Http();
          HttpResponse res = http.send(req);

          if (res.getStatusCode() >= 200 && res.getStatusCode() < 300) {
            Map<String, Object> response = (Map<String, Object>)
              JSON.deserializeUntyped(res.getBody());

            // Update external ID
            acc.External_CRM_Id__c = (String) response.get('id');
            update acc;
          } else {
            // Log error
            insert new Integration_Error__c(
              Type__c = 'External CRM Sync',
              Account__c = accountId,
              Status_Code__c = res.getStatusCode(),
              Response__c = res.getBody().left(32768)
            );
          }
        }
      }
      ```

  with_platform_events:
    when: "Real-time event-driven architecture"
    approach: |
      Platform Events for loosely coupled integration:

      ```apex
      // 1. Create Platform Event: Account_Change__e
      // Fields: Account_Id__c (Text), Change_Type__c (Text), Data__c (Long Text)

      // 2. Publish from trigger
      public class AccountEventPublisher {
        public static void publishChanges(
          List<Account> newAccounts,
          Map<Id, Account> oldMap
        ) {
          List<Account_Change__e> events = new List<Account_Change__e>();

          for (Account acc : newAccounts) {
            Account oldAcc = oldMap?.get(acc.Id);
            String changeType = oldAcc == null ? 'CREATE' : 'UPDATE';

            events.add(new Account_Change__e(
              Account_Id__c = acc.Id,
              Change_Type__c = changeType,
              Data__c = JSON.serialize(new Map<String, Object>{
                'name' => acc.Name,
                'industry' => acc.Industry,
                'owner' => acc.OwnerId
              })
            ));
          }

          if (!events.isEmpty()) {
            EventBus.publish(events);
          }
        }
      }

      // 3. Subscribe from external system (Node.js)
      const jsforce = require('jsforce');

      const conn = new jsforce.Connection({
        loginUrl: process.env.SF_LOGIN_URL
      });

      await conn.login(process.env.SF_USERNAME, process.env.SF_PASSWORD);

      // Subscribe to platform event
      conn.streaming.topic('/event/Account_Change__e').subscribe((message) => {
        console.log('Account changed:', message);
        const data = JSON.parse(message.payload.Data__c);
        // Process event...
      });
      ```

  with_github_actions:
    when: "CI/CD for Salesforce development"
    approach: |
      GitHub Actions workflow for Salesforce:

      ```yaml
      # .github/workflows/salesforce-ci.yml
      name: Salesforce CI/CD

      on:
        push:
          branches: [main, develop]
        pull_request:
          branches: [main]

      env:
        SFDX_AUDIENCE: "https://login.salesforce.com"

      jobs:
        validate:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4

            - name: Install Salesforce CLI
              run: |
                npm install -g @salesforce/cli
                sf version

            - name: Authenticate to DevHub
              run: |
                echo "${{ secrets.SFDX_JWT_KEY }}" > server.key
                sf org login jwt \
                  --client-id ${{ secrets.SFDX_CLIENT_ID }} \
                  --jwt-key-file server.key \
                  --username ${{ secrets.SFDX_DEVHUB_USERNAME }} \
                  --set-default-dev-hub \
                  --alias DevHub

            - name: Create Scratch Org
              run: |
                sf org create scratch \
                  --definition-file config/project-scratch-def.json \
                  --alias ci-scratch \
                  --duration-days 1 \
                  --set-default

            - name: Push Source
              run: sf project deploy start --target-org ci-scratch

            - name: Run Apex Tests
              run: |
                sf apex run test \
                  --target-org ci-scratch \
                  --code-coverage \
                  --result-format human \
                  --output-dir ./test-results \
                  --wait 20

            - name: Check Code Coverage
              run: |
                COVERAGE=$(cat ./test-results/test-result-codecoverage.json | jq '.summary.orgWideCoverage' | tr -d '"' | tr -d '%')
                if [ "$COVERAGE" -lt 75 ]; then
                  echo "Code coverage ${COVERAGE}% is below 75%"
                  exit 1
                fi

            - name: Cleanup
              if: always()
              run: sf org delete scratch --target-org ci-scratch --no-prompt || true

        deploy:
          needs: validate
          if: github.ref == 'refs/heads/main'
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4

            - name: Install Salesforce CLI
              run: npm install -g @salesforce/cli

            - name: Authenticate to Production
              run: |
                echo "${{ secrets.SFDX_JWT_KEY }}" > server.key
                sf org login jwt \
                  --client-id ${{ secrets.SFDX_CLIENT_ID }} \
                  --jwt-key-file server.key \
                  --username ${{ secrets.SFDX_PROD_USERNAME }} \
                  --alias Production

            - name: Deploy to Production
              run: |
                sf project deploy start \
                  --target-org Production \
                  --test-level RunLocalTests \
                  --wait 30
      ```

platform_integration:
  vscode:
    setup: |
      # Install Salesforce Extensions
      code --install-extension salesforce.salesforcedx-vscode

      # Create project
      sf project generate --name myproject --template standard

      # Authorize org
      sf org login web --alias myorg --set-default

  scratch_org:
    setup: |
      # Enable Dev Hub first (Setup > Dev Hub)

      # Create scratch org
      sf org create scratch \
        --definition-file config/project-scratch-def.json \
        --alias dev \
        --set-default \
        --duration-days 7

      # Push source
      sf project deploy start

      # Open org
      sf org open

security_checklist:
  - "WITH SECURITY_ENFORCED on all SOQL"
  - "CRUD/FLS checks before DML"
  - "No hardcoded credentials"
  - "Named Credentials for callouts"
  - "with sharing on all classes by default"
  - "Input validation on Apex methods"
  - "escapeSingleQuotes for dynamic SOQL"
  - "Session security in Connected Apps"

cost_optimization:
  - "Use Bulk API for 10K+ records"
  - "Cache frequently accessed data"
  - "Minimize API calls with composite requests"
  - "Use Platform Events over polling"
  - "Batch async operations"
  - "Monitor org limits in Setup"
