id: bullmq-specialist-collaboration
skill: bullmq-specialist
version: 1.0.0

# ============================================================================
# RECEIVES FROM (Who delegates TO this skill)
# ============================================================================
receives_from:
  - skill: backend
    context: "Backend needs async job processing"
    receives:
      - "Job types to implement"
      - "Processing requirements"
      - "Retry strategies"
    provides: "Queue infrastructure and workers"

  - skill: email-systems
    context: "Email needs reliable delivery via queue"
    receives:
      - "Email types to queue"
      - "Rate limits for providers"
      - "Priority requirements"
    provides: "Email queue with rate limiting"

  - skill: ai-workflow-automation
    context: "AI workflows need job orchestration"
    receives:
      - "Workflow steps"
      - "Dependencies between jobs"
      - "Timeout requirements"
    provides: "Flow-based job dependencies"

  - skill: nextjs-app-router
    context: "Next.js needs background processing"
    receives:
      - "API routes that trigger jobs"
      - "Long-running tasks"
      - "Scheduled tasks"
    provides: "Queue integration for serverless"

  - skill: performance-hunter
    context: "Performance needs async offloading"
    receives:
      - "Slow operations to offload"
      - "Throughput requirements"
      - "Latency budgets"
    provides: "Async processing pattern"

# ============================================================================
# DELEGATION TRIGGERS
# ============================================================================
delegation_triggers:
  - trigger: "redis infrastructure|redis cluster|memory tuning"
    delegate_to: redis-specialist
    pattern: sequential
    context: "Queue needs Redis infrastructure"
    handoff_data:
      - "Memory requirements"
      - "Persistence needs"
      - "Cluster configuration"
    receive: "Redis setup"

  - trigger: "serverless queue|edge queue|no redis"
    delegate_to: upstash-qstash
    pattern: sequential
    context: "Need queues without managing Redis"
    handoff_data:
      - "Job types"
      - "Volume estimates"
      - "Retry requirements"
    receive: "Serverless queue solution"

  - trigger: "complex workflow|saga|compensation|long-running"
    delegate_to: temporal-craftsman
    pattern: sequential
    context: "Need workflow orchestration beyond simple jobs"
    handoff_data:
      - "Workflow complexity"
      - "Compensation requirements"
      - "State management needs"
    receive: "Temporal workflow design"

  - trigger: "event sourcing|CQRS|event streaming"
    delegate_to: event-architect
    pattern: sequential
    context: "Need event-driven architecture"
    handoff_data:
      - "Event types"
      - "Replay requirements"
      - "Ordering guarantees"
    receive: "Event architecture"

  - trigger: "deploy|kubernetes|scaling|infrastructure"
    delegate_to: devops
    pattern: parallel
    context: "Queue needs infrastructure"
    handoff_data:
      - "Worker scaling requirements"
      - "Redis deployment needs"
      - "Monitoring requirements"
    receive: "Infrastructure setup"

  - trigger: "monitor|metrics|alerting|dashboard"
    delegate_to: performance-hunter
    pattern: parallel
    context: "Queue needs monitoring"
    handoff_data:
      - "Key metrics (queue depth, processing time)"
      - "Alert thresholds"
      - "Dashboard requirements"
    receive: "Monitoring setup"

# ============================================================================
# FEEDBACK LOOPS
# ============================================================================
feedback_loops:
  receives_feedback_from:
    - skill: redis-specialist
      signal: "Redis memory/performance issues"
      action: "Optimize job data size, adjust TTLs"

    - skill: performance-hunter
      signal: "Queue latency metrics"
      action: "Tune concurrency and rate limits"

    - skill: devops
      signal: "Worker scaling patterns"
      action: "Adjust concurrency per worker"

  sends_feedback_to:
    - skill: backend
      signal: "Job processing patterns"
      action: "Optimize job creation"

    - skill: email-systems
      signal: "Delivery rate metrics"
      action: "Adjust email sending patterns"

    - skill: redis-specialist
      signal: "Redis usage patterns"
      action: "Optimize Redis configuration"

# ============================================================================
# CROSS-DOMAIN INSIGHTS
# ============================================================================
cross_domain_insights:
  - domain: Factory Assembly Lines
    insight: |
      Factory managers know throughput:
      - Bottlenecks determine total capacity
      - Buffer sizes prevent starvation
      - Quality control at each station
      - Downtime must be planned
      Job queues follow manufacturing flow principles.
    applies_when: "Designing job processing pipelines"

  - domain: Restaurant Kitchens
    insight: |
      Kitchen expeditors know coordination:
      - Orders queued by priority
      - Parallel prep when possible
      - Dependencies managed (can't plate before cook)
      - Backpressure when overwhelmed (86'd items)
      Job flows mirror kitchen order management.
    applies_when: "Implementing job dependencies"

  - domain: Postal Systems
    insight: |
      Postal experts know delivery:
      - Retry with backoff (not home, try again)
      - Dead letter for undeliverable
      - Tracking from origin to destination
      - Priority affects handling
      Job queues are message delivery systems.
    applies_when: "Designing retry and DLQ strategies"

# ============================================================================
# COMMON COMBINATIONS
# ============================================================================
common_combinations:
  - name: Email Queue Stack
    skills:
      - bullmq-specialist
      - email-systems
      - redis-specialist
    workflow: |
      1. Email request received (API)
      2. Job queued with rate limiting (bullmq-specialist)
      3. Worker processes with backoff (bullmq-specialist)
      4. Email sent via provider (email-systems)
      5. Status tracked in Redis (redis-specialist)

  - name: Background Processing Stack
    skills:
      - bullmq-specialist
      - backend
      - devops
    workflow: |
      1. API receives request (backend)
      2. Long task queued for background (bullmq-specialist)
      3. Worker processes async (bullmq-specialist)
      4. Result stored/notified (backend)
      5. Workers scaled per load (devops)

  - name: AI Processing Pipeline
    skills:
      - bullmq-specialist
      - ai-workflow-automation
      - performance-hunter
    workflow: |
      1. AI task submitted (ai-workflow-automation)
      2. Job flow created with dependencies (bullmq-specialist)
      3. Workers process stages (bullmq-specialist)
      4. Performance monitored (performance-hunter)
      5. Results aggregated (ai-workflow-automation)

  - name: Scheduled Tasks Stack
    skills:
      - bullmq-specialist
      - backend
      - redis-specialist
    workflow: |
      1. Repeatable jobs defined (bullmq-specialist)
      2. Cron patterns with timezone (bullmq-specialist)
      3. Jobs execute on schedule (bullmq-specialist)
      4. State managed in Redis (redis-specialist)
      5. Results handled (backend)

# ============================================================================
# INTEGRATION CONTRACTS
# ============================================================================
contracts:
  with_redis_specialist:
    bullmq_specialist_provides:
      - "Memory usage patterns from job data"
      - "Connection requirements (maxRetriesPerRequest)"
      - "Key patterns for monitoring"
    redis_specialist_provides:
      - "Redis cluster configuration"
      - "Memory and persistence settings"
      - "Connection pooling guidance"
    interface_example: |
      // bullmq-specialist configures connection
      const connection = new IORedis(process.env.REDIS_URL, {
        maxRetriesPerRequest: null,  // Required for BullMQ
        enableReadyCheck: false,
      });

      // redis-specialist ensures Redis is configured for:
      // - Adequate memory for job storage
      // - Persistence if jobs must survive restart
      // - Cluster if horizontal scaling needed

  with_backend:
    bullmq_specialist_provides:
      - "Queue add patterns"
      - "Job completion notifications"
      - "Error handling patterns"
    backend_provides:
      - "Job types and data shapes"
      - "Processing logic"
      - "Result handling"
    interface_example: |
      // backend adds jobs
      const job = await emailQueue.add('welcome', {
        userId: user.id,
        templateId: 'welcome',
      });

      // bullmq-specialist handles processing
      const worker = new Worker('emails', async (job) => {
        const { userId, templateId } = job.data;
        await sendEmail(userId, templateId);
      });

      // backend handles results via webhook or polling
      await job.waitUntilFinished(queueEvents);

  with_devops:
    bullmq_specialist_provides:
      - "Worker scaling requirements"
      - "Health check endpoints"
      - "Graceful shutdown signals"
    devops_provides:
      - "Kubernetes deployment"
      - "Horizontal pod autoscaling"
      - "Monitoring and alerting"
    interface_example: |
      // bullmq-specialist provides health check
      app.get('/health', async (req, res) => {
        const queueHealth = await queue.isPaused() ? 'paused' : 'healthy';
        const workerHealth = worker.isRunning() ? 'healthy' : 'stopped';
        res.json({ queue: queueHealth, worker: workerHealth });
      });

      // devops scales based on queue depth
      // HPA: scale when queue.getWaitingCount() > threshold

  with_email_systems:
    bullmq_specialist_provides:
      - "Rate limited queue for sending"
      - "Retry with exponential backoff"
      - "Priority queue for transactional"
    email_systems_provides:
      - "Email templates and data"
      - "Provider rate limits"
      - "Bounce handling"
    interface_example: |
      // bullmq-specialist configures rate limited queue
      const emailWorker = new Worker('emails', processor, {
        connection,
        limiter: {
          max: 100,        // Provider limit: 100/second
          duration: 1000,
        },
      });

      // email-systems provides processing
      async function processor(job) {
        await resend.emails.send({
          to: job.data.to,
          subject: job.data.subject,
          html: job.data.html,
        });
      }

# ============================================================================
# PREREQUISITES
# ============================================================================
prerequisites:
  skills:
    - redis-specialist  # For Redis infrastructure
  knowledge:
    - "Redis data structures (Lists, Sorted Sets)"
    - "Async/await and Promise patterns"
    - "Error handling and retry strategies"
  tools:
    - "bullmq npm package"
    - "ioredis for Redis connection"
    - "bull-board for dashboard (optional)"

# ============================================================================
# DELEGATION PATTERNS
# ============================================================================
delegation_triggers_inbound:
  - phrase: "background job"
    confidence: high
  - phrase: "job queue"
    confidence: high
  - phrase: "bullmq"
    confidence: high
  - phrase: "delayed job"
    confidence: high
  - phrase: "repeatable job"
    confidence: high
  - phrase: "scheduled task"
    confidence: high
  - phrase: "worker process"
    confidence: high
  - phrase: "async processing"
    confidence: medium
  - phrase: "rate limited queue"
    confidence: high
  - phrase: "job flow"
    confidence: high
