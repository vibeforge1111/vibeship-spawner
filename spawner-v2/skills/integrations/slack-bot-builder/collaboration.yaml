# Collaboration - Slack Bot Builder
# How this skill works with other skills

version: 1.0.0
skill_id: slack-bot-builder

prerequisites:
  required: []

  recommended:
    - skill: backend
      reason: "Webhook endpoints and API integration"
      what_to_know:
        - "REST API patterns"
        - "Webhook security"
        - "Background job processing"

    - skill: auth-specialist
      reason: "OAuth implementation for multi-workspace apps"
      what_to_know:
        - "OAuth 2.0 flows"
        - "Token storage and encryption"
        - "Session management"

delegation_triggers:
  - trigger: "user needs AI-powered Slack bot"
    delegate_to: llm-architect
    context: "Integrate LLM for conversational Slack bot"

  - trigger: "user needs voice notifications"
    delegate_to: twilio-communications
    context: "Escalate Slack alerts to SMS or voice calls"

  - trigger: "user needs workflow automation"
    delegate_to: workflow-automation
    context: "Slack as trigger/action in n8n/Temporal workflows"

  - trigger: "user needs bot for Discord too"
    delegate_to: discord-bot-architect
    context: "Cross-platform bot architecture"

  - trigger: "user needs full auth system"
    delegate_to: auth-specialist
    context: "OAuth, workspace management, enterprise SSO"

  - trigger: "user needs database for bot data"
    delegate_to: postgres-wizard
    context: "Store installations, user preferences, message history"

  - trigger: "user needs high availability"
    delegate_to: devops
    context: "Scale webhooks, monitoring, alerting"

receives_context_from:
  - skill: backend
    receives:
      - "API design patterns"
      - "Error handling strategies"
      - "Background job patterns"

  - skill: auth-specialist
    receives:
      - "OAuth implementation patterns"
      - "Token encryption strategies"
      - "Session handling"

  - skill: workflow-automation
    receives:
      - "Workflow trigger patterns"
      - "Event-driven architecture"
      - "Retry and error handling"

  - skill: llm-architect
    receives:
      - "Conversational AI patterns"
      - "Context management"
      - "Response generation"

provides_context_to:
  - skill: workflow-automation
    provides:
      - "Slack as notification channel"
      - "Interactive approval workflows"
      - "Event triggers for automations"

  - skill: twilio-communications
    provides:
      - "Slack alerts for SMS/call failures"
      - "Cross-channel notification patterns"
      - "Alert escalation triggers"

  - skill: devops
    provides:
      - "Webhook requirements"
      - "Monitoring integration"
      - "Alert notification patterns"

  - skill: llm-architect
    provides:
      - "Chat interface patterns"
      - "Thread context management"
      - "User interaction patterns"

escalation_paths:
  - situation: "Enterprise SSO requirements"
    escalate_to: auth-specialist
    context: "SAML, SCIM, enterprise OAuth patterns"

  - situation: "High-volume message processing"
    escalate_to: devops
    context: "Queue systems, horizontal scaling, rate limiting"

  - situation: "AI-powered conversational bot"
    escalate_to: llm-architect
    context: "LLM integration, context windows, response generation"

  - situation: "Complex workflow automation"
    escalate_to: workflow-automation
    context: "Multi-step approvals, conditional logic, external systems"

  - situation: "Database design for bot data"
    escalate_to: postgres-wizard
    context: "Schema design, queries, performance"

workflow_integration:
  typical_sequence:
    1:
      step: "Create Slack app in API dashboard"
      skills: [slack-bot-builder]
      output: "App credentials, signing secret"

    2:
      step: "Configure OAuth scopes"
      skills: [slack-bot-builder]
      output: "Minimal required scopes"

    3:
      step: "Implement Bolt app foundation"
      skills: [slack-bot-builder, backend]
      output: "Working bot with event handling"

    4:
      step: "Add slash commands and modals"
      skills: [slack-bot-builder]
      output: "Interactive features"

    5:
      step: "Implement OAuth for distribution"
      skills: [slack-bot-builder, auth-specialist]
      output: "Multi-workspace installation"

    6:
      step: "Add database for installations"
      skills: [slack-bot-builder, postgres-wizard]
      output: "Persistent token storage"

    7:
      step: "Deploy with HTTP webhooks"
      skills: [slack-bot-builder, devops]
      output: "Production-ready deployment"

  decision_points:
    - question: "Socket Mode or HTTP webhooks?"
      guidance: |
        Socket Mode:
        - No public URL needed
        - Great for development
        - Single connection per app
        - Can't scale horizontally
        - Best for: development, internal tools

        HTTP Webhooks:
        - Requires public HTTPS endpoint
        - Standard production approach
        - Scales with your infrastructure
        - Works with any hosting
        - Best for: production, distributed apps

    - question: "Which Bolt SDK?"
      guidance: |
        Python (slack-bolt):
        - Most popular
        - Great async support
        - Rich ecosystem
        - Best for: most projects

        JavaScript (slack-bolt):
        - Native Node.js
        - Works with Express, Fastify
        - Good for serverless
        - Best for: Node.js teams, serverless

        Java (slack-bolt):
        - Enterprise environments
        - Spring Boot integration
        - Best for: Java shops

    - question: "Single workspace or distributed?"
      guidance: |
        Single Workspace (Internal App):
        - Simpler setup
        - No OAuth needed
        - Direct token install
        - Best for: internal tools

        Distributed (Multi-workspace):
        - OAuth installation flow
        - Token storage per workspace
        - App Directory submission
        - Best for: products, external apps

collaboration_patterns:
  with_llm:
    when: "Building conversational AI bot"
    approach: |
      Slack bot as chat interface, LLM for responses:

      ```python
      from slack_bolt import App
      from openai import OpenAI

      app = App(...)
      ai = OpenAI()

      # Store conversation context per thread
      thread_contexts = {}

      @app.event("app_mention")
      def handle_mention(event, say, client):
          thread_ts = event.get("thread_ts", event["ts"])
          user = event["user"]
          text = event["text"]

          # Get or create thread context
          context = thread_contexts.get(thread_ts, [])
          context.append({"role": "user", "content": text})

          # Get AI response
          response = ai.chat.completions.create(
              model="gpt-4",
              messages=[
                  {"role": "system", "content": "You are a helpful assistant in Slack."},
                  *context
              ]
          )

          reply = response.choices[0].message.content

          # Save to context
          context.append({"role": "assistant", "content": reply})
          thread_contexts[thread_ts] = context

          # Reply in thread
          say(text=reply, thread_ts=thread_ts)
      ```

  with_workflow_automation:
    when: "Slack as trigger/action in workflows"
    approach: |
      Slack events trigger workflows, workflows post to Slack:

      ```python
      # Slack reaction triggers workflow
      @app.event("reaction_added")
      def handle_reaction(event, client):
          if event["reaction"] == "white_check_mark":
              # Trigger approval workflow
              workflow_client.start_workflow(
                  "approval-workflow",
                  input={
                      "message_ts": event["item"]["ts"],
                      "channel": event["item"]["channel"],
                      "approver": event["user"]
                  }
              )

      # Workflow step posts to Slack
      async def post_approval_result(channel: str, result: dict):
          await client.chat_postMessage(
              channel=channel,
              blocks=[
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"*Approval Result:* {result['status']}"
                      }
                  }
              ]
          )
      ```

  with_sms_alerts:
    when: "Escalate Slack alerts to SMS/voice"
    approach: |
      Unacknowledged Slack alerts escalate to SMS:

      ```python
      import asyncio
      from slack_bolt import App
      from twilio.rest import Client as TwilioClient

      app = App(...)
      twilio = TwilioClient(...)

      # Track unacknowledged alerts
      pending_alerts = {}

      @app.command("/alert")
      def create_alert(ack, command, client):
          ack()

          # Post alert with acknowledge button
          result = client.chat_postMessage(
              channel=command["channel_id"],
              text=f":rotating_light: Alert: {command['text']}",
              blocks=[
                  {
                      "type": "section",
                      "text": {"type": "mrkdwn", "text": f":rotating_light: *Alert:* {command['text']}"}
                  },
                  {
                      "type": "actions",
                      "elements": [
                          {
                              "type": "button",
                              "text": {"type": "plain_text", "text": "Acknowledge"},
                              "action_id": "ack_alert",
                              "style": "primary"
                          }
                      ]
                  }
              ]
          )

          # Schedule escalation
          alert_id = result["ts"]
          pending_alerts[alert_id] = {
              "text": command["text"],
              "channel": command["channel_id"],
              "on_call_phone": get_on_call_phone()
          }

          # Escalate after 5 minutes if not acknowledged
          asyncio.create_task(escalate_if_unacked(alert_id))

      async def escalate_if_unacked(alert_id: str):
          await asyncio.sleep(300)  # 5 minutes

          if alert_id in pending_alerts:
              alert = pending_alerts[alert_id]
              twilio.messages.create(
                  to=alert["on_call_phone"],
                  from_=os.environ["TWILIO_PHONE"],
                  body=f"UNACKED ALERT: {alert['text']}"
              )

      @app.action("ack_alert")
      def handle_ack(ack, body, client):
          ack()
          alert_id = body["message"]["ts"]

          if alert_id in pending_alerts:
              del pending_alerts[alert_id]

          # Update message to show acknowledged
          client.chat_update(
              channel=body["channel"]["id"],
              ts=alert_id,
              text=":white_check_mark: Alert acknowledged",
              blocks=[
                  {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f":white_check_mark: *Acknowledged* by <@{body['user']['id']}>"
                      }
                  }
              ]
          )
      ```

platform_integration:
  python_flask:
    setup: |
      pip install slack-bolt flask

      from slack_bolt import App
      from slack_bolt.adapter.flask import SlackRequestHandler
      from flask import Flask, request

      bolt_app = App(
          token=os.environ["SLACK_BOT_TOKEN"],
          signing_secret=os.environ["SLACK_SIGNING_SECRET"]
      )
      flask_app = Flask(__name__)
      handler = SlackRequestHandler(bolt_app)

      @flask_app.route("/slack/events", methods=["POST"])
      def slack_events():
          return handler.handle(request)

      @flask_app.route("/slack/commands", methods=["POST"])
      def slack_commands():
          return handler.handle(request)

      @flask_app.route("/slack/interactions", methods=["POST"])
      def slack_interactions():
          return handler.handle(request)
    considerations:
      - "Use gunicorn for production"
      - "Configure webhook URLs in Slack app settings"
      - "Set up ngrok for development"

  python_fastapi:
    setup: |
      pip install slack-bolt fastapi uvicorn

      from slack_bolt.async_app import AsyncApp
      from slack_bolt.adapter.fastapi.async_handler import AsyncSlackRequestHandler
      from fastapi import FastAPI, Request

      bolt_app = AsyncApp(
          token=os.environ["SLACK_BOT_TOKEN"],
          signing_secret=os.environ["SLACK_SIGNING_SECRET"]
      )
      api = FastAPI()
      handler = AsyncSlackRequestHandler(bolt_app)

      @api.post("/slack/events")
      async def slack_events(request: Request):
          return await handler.handle(request)
    considerations:
      - "Use AsyncApp for FastAPI"
      - "All handlers should be async"
      - "Better performance for high-volume bots"

  node_express:
    setup: |
      npm install @slack/bolt express

      const { App, ExpressReceiver } = require('@slack/bolt');

      const receiver = new ExpressReceiver({
        signingSecret: process.env.SLACK_SIGNING_SECRET
      });

      const app = new App({
        token: process.env.SLACK_BOT_TOKEN,
        receiver
      });

      app.command('/hello', async ({ ack, command, respond }) => {
        await ack();
        await respond(`Hello, ${command.user_name}!`);
      });

      (async () => {
        await app.start(3000);
        console.log('Bot is running!');
      })();
    considerations:
      - "ExpressReceiver for custom Express middleware"
      - "Can add health checks and custom routes"
      - "Works with existing Express apps"

  serverless:
    aws_lambda: |
      from slack_bolt import App
      from slack_bolt.adapter.aws_lambda import SlackRequestHandler

      app = App(
          token=os.environ["SLACK_BOT_TOKEN"],
          signing_secret=os.environ["SLACK_SIGNING_SECRET"],
          process_before_response=True  # Required for Lambda
      )

      handler = SlackRequestHandler(app)

      def lambda_handler(event, context):
          return handler.handle(event, context)

    cloudflare_workers: |
      // Note: Bolt JS doesn't officially support Workers
      // Use raw Slack SDK with signature verification

      import { verifySlackRequest } from './verify';

      export default {
        async fetch(request, env) {
          if (!await verifySlackRequest(request, env.SLACK_SIGNING_SECRET)) {
            return new Response('Invalid signature', { status: 403 });
          }

          const body = await request.json();

          // Handle URL verification
          if (body.type === 'url_verification') {
            return new Response(body.challenge);
          }

          // Handle events
          // ...
        }
      };

cost_optimization:
  - "Use Socket Mode during development (free, no hosting)"
  - "Batch similar messages to reduce API calls"
  - "Cache user info to avoid repeated lookups"
  - "Use ephemeral messages when privacy allows"

security_checklist:
  - "Signing secret in environment variables"
  - "Bot token in environment variables"
  - "OAuth state parameter validated"
  - "Tokens encrypted in database"
  - "Minimal OAuth scopes requested"
  - "No tokens logged or exposed"
  - "Webhook signature verification enabled"
  - "HTTPS for all webhook endpoints"
