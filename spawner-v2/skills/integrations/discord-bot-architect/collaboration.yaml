# Collaboration - Discord Bot Architect
# How this skill works with other skills

version: 1.0.0
skill_id: discord-bot-architect

prerequisites:
  required: []

  recommended:
    - skill: backend
      reason: "API integration and database patterns"
      what_to_know:
        - "REST API patterns"
        - "Database queries"
        - "Background job processing"

    - skill: devops
      reason: "Deployment, sharding, monitoring"
      what_to_know:
        - "Container orchestration"
        - "Process management"
        - "Monitoring and alerting"

delegation_triggers:
  - trigger: "user needs AI-powered Discord bot"
    delegate_to: llm-architect
    context: "Integrate LLM for conversational Discord bot"

  - trigger: "user needs Slack integration too"
    delegate_to: slack-bot-builder
    context: "Cross-platform bot architecture"

  - trigger: "user needs voice features"
    delegate_to: voice-agents
    context: "Discord voice channel integration"

  - trigger: "user needs database for bot data"
    delegate_to: postgres-wizard
    context: "Store user data, server configs, moderation logs"

  - trigger: "user needs workflow automation"
    delegate_to: workflow-automation
    context: "Discord events trigger workflows"

  - trigger: "user needs high availability"
    delegate_to: devops
    context: "Sharding, scaling, monitoring for large bots"

  - trigger: "user needs payment integration"
    delegate_to: stripe-specialist
    context: "Premium bot features, subscription management"

receives_context_from:
  - skill: backend
    receives:
      - "API design patterns"
      - "Error handling strategies"
      - "Database query patterns"

  - skill: llm-architect
    receives:
      - "LLM integration patterns"
      - "Context management"
      - "Response generation"

  - skill: devops
    receives:
      - "Deployment strategies"
      - "Scaling patterns"
      - "Monitoring setup"

  - skill: workflow-automation
    receives:
      - "Event-driven patterns"
      - "Workflow triggers"
      - "Background processing"

provides_context_to:
  - skill: slack-bot-builder
    provides:
      - "Cross-platform bot patterns"
      - "Interaction handling similarities"
      - "Rate limit strategies"

  - skill: llm-architect
    provides:
      - "Chat interface patterns"
      - "Thread context management"
      - "User interaction patterns"

  - skill: workflow-automation
    provides:
      - "Discord event triggers"
      - "Notification delivery"
      - "Interactive approvals"

  - skill: devops
    provides:
      - "Sharding requirements"
      - "Resource usage patterns"
      - "Monitoring metrics"

escalation_paths:
  - situation: "AI-powered conversational bot"
    escalate_to: llm-architect
    context: "LLM integration, context windows, response generation"

  - situation: "Large scale bot (2500+ guilds)"
    escalate_to: devops
    context: "Sharding, horizontal scaling, monitoring"

  - situation: "Complex data persistence"
    escalate_to: postgres-wizard
    context: "Schema design, queries, caching"

  - situation: "Voice channel features"
    escalate_to: voice-agents
    context: "Audio processing, speech recognition"

  - situation: "Cross-platform bot"
    escalate_to: slack-bot-builder
    context: "Unified bot architecture for Discord + Slack"

workflow_integration:
  typical_sequence:
    1:
      step: "Create Discord application"
      skills: [discord-bot-architect]
      output: "Bot token, application ID"

    2:
      step: "Configure bot settings"
      skills: [discord-bot-architect]
      output: "Intents, permissions, OAuth URL"

    3:
      step: "Implement bot foundation"
      skills: [discord-bot-architect, backend]
      output: "Working bot with event handling"

    4:
      step: "Add slash commands"
      skills: [discord-bot-architect]
      output: "Interactive commands"

    5:
      step: "Add interactive components"
      skills: [discord-bot-architect]
      output: "Buttons, select menus, modals"

    6:
      step: "Add database"
      skills: [discord-bot-architect, postgres-wizard]
      output: "Persistent storage"

    7:
      step: "Deploy with sharding"
      skills: [discord-bot-architect, devops]
      output: "Production deployment"

  decision_points:
    - question: "Discord.js or Pycord?"
      guidance: |
        Discord.js (JavaScript/TypeScript):
        - Larger ecosystem
        - More documentation
        - Better TypeScript support
        - Best for: most projects

        Pycord (Python):
        - Great async support
        - Easier for Python developers
        - Good for AI integration
        - Best for: Python teams, ML bots

    - question: "Gateway or HTTP-only?"
      guidance: |
        Gateway (WebSocket):
        - Receives real-time events
        - Required for most features
        - Maintains persistent connection
        - Best for: most bots

        HTTP-only (Interactions):
        - Only slash commands
        - No gateway connection
        - Serverless-friendly
        - Best for: simple webhook-style bots

    - question: "Self-hosted or cloud?"
      guidance: |
        Self-hosted (VPS/Dedicated):
        - Full control
        - Consistent uptime
        - Can be cheaper at scale
        - Best for: serious projects

        Cloud (Railway, Fly.io):
        - Easy deployment
        - Auto-scaling
        - May have cold starts
        - Best for: small-medium bots

        Serverless (Lambda, Workers):
        - HTTP-only bots
        - No persistent connection
        - Limited to slash commands
        - Best for: simple integrations

collaboration_patterns:
  with_llm:
    when: "Building AI-powered Discord bot"
    approach: |
      Discord bot as chat interface, LLM for responses:

      ```javascript
      const { OpenAI } = require('openai');

      const openai = new OpenAI();

      // Store conversation context per channel/thread
      const contexts = new Map();

      module.exports = {
        data: new SlashCommandBuilder()
          .setName('chat')
          .setDescription('Chat with AI')
          .addStringOption(opt =>
            opt.setName('message')
              .setDescription('Your message')
              .setRequired(true)),

        async execute(interaction) {
          await interaction.deferReply();

          const message = interaction.options.getString('message');
          const contextKey = interaction.channelId;

          // Get or create context
          const context = contexts.get(contextKey) || [];
          context.push({ role: 'user', content: message });

          try {
            const response = await openai.chat.completions.create({
              model: 'gpt-4',
              messages: [
                { role: 'system', content: 'You are a helpful Discord bot.' },
                ...context.slice(-10)  // Keep last 10 messages
              ]
            });

            const reply = response.choices[0].message.content;
            context.push({ role: 'assistant', content: reply });
            contexts.set(contextKey, context);

            await interaction.editReply(reply);
          } catch (error) {
            await interaction.editReply('Sorry, something went wrong.');
          }
        }
      };
      ```

  with_database:
    when: "Storing server configs, user data, moderation logs"
    approach: |
      Prisma for type-safe database access:

      ```javascript
      // prisma/schema.prisma
      model GuildConfig {
        id        String   @id @default(cuid())
        guildId   String   @unique
        prefix    String   @default("!")
        welcomeChannel String?
        logChannel     String?
        createdAt DateTime @default(now())
        updatedAt DateTime @updatedAt
      }

      model UserData {
        id        String   @id @default(cuid())
        discordId String   @unique
        balance   Int      @default(0)
        xp        Int      @default(0)
        level     Int      @default(1)
      }

      // Usage in commands
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      module.exports = {
        async execute(interaction) {
          await interaction.deferReply();

          const config = await prisma.guildConfig.upsert({
            where: { guildId: interaction.guildId },
            update: {},
            create: { guildId: interaction.guildId }
          });

          await interaction.editReply(`Prefix: ${config.prefix}`);
        }
      };
      ```

  with_workflow_automation:
    when: "Discord events trigger complex workflows"
    approach: |
      Discord events trigger n8n/Temporal workflows:

      ```javascript
      // Discord event triggers workflow
      client.on(Events.MessageReactionAdd, async (reaction, user) => {
        if (reaction.emoji.name === 'âœ…') {
          // Trigger approval workflow
          await fetch('https://n8n.example.com/webhook/discord-approval', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messageId: reaction.message.id,
              channelId: reaction.message.channelId,
              userId: user.id,
              guildId: reaction.message.guildId
            })
          });
        }
      });

      // Workflow sends results back to Discord
      // (via webhook or direct API call)
      ```

  with_voice:
    when: "Voice channel features"
    approach: |
      Using @discordjs/voice for voice features:

      ```javascript
      const {
        joinVoiceChannel,
        createAudioPlayer,
        createAudioResource,
        AudioPlayerStatus
      } = require('@discordjs/voice');

      module.exports = {
        async execute(interaction) {
          const channel = interaction.member.voice.channel;
          if (!channel) {
            return interaction.reply('Join a voice channel first!');
          }

          const connection = joinVoiceChannel({
            channelId: channel.id,
            guildId: channel.guild.id,
            adapterCreator: channel.guild.voiceAdapterCreator
          });

          const player = createAudioPlayer();
          const resource = createAudioResource('audio.mp3');

          player.play(resource);
          connection.subscribe(player);

          player.on(AudioPlayerStatus.Idle, () => {
            connection.destroy();
          });

          await interaction.reply('Playing audio!');
        }
      };
      ```

platform_integration:
  railway:
    setup: |
      # railway.json
      {
        "build": {
          "builder": "NIXPACKS"
        },
        "deploy": {
          "restartPolicyType": "ON_FAILURE"
        }
      }

      # Environment variables in Railway dashboard
      DISCORD_TOKEN=xxx
      CLIENT_ID=xxx
    considerations:
      - "Persistent connection supported"
      - "Auto-scaling available"
      - "Free tier has usage limits"

  fly_io:
    setup: |
      # fly.toml
      app = "my-discord-bot"

      [build]
        builder = "heroku/buildpacks:20"

      [[services]]
        internal_port = 3000
        protocol = "tcp"

      # Deploy
      fly deploy
    considerations:
      - "Global edge deployment"
      - "Persistent connections OK"
      - "Good for multi-region"

  docker:
    setup: |
      FROM node:20-slim
      WORKDIR /app
      COPY package*.json ./
      RUN npm ci --only=production
      COPY . .
      CMD ["node", "src/index.js"]
    considerations:
      - "Consistent environment"
      - "Easy local development"
      - "Works with any host"

  pm2:
    setup: |
      # ecosystem.config.js
      module.exports = {
        apps: [{
          name: 'discord-bot',
          script: 'src/index.js',
          instances: 1,
          autorestart: true,
          watch: false,
          max_memory_restart: '500M'
        }]
      };

      # Start
      pm2 start ecosystem.config.js

      # For sharding
      # Use ShardingManager, not PM2 instances
    considerations:
      - "Process management"
      - "Auto-restart on crash"
      - "Don't use PM2 cluster with sharding"

cost_optimization:
  - "Request minimal intents to reduce event volume"
  - "Use guild commands during development"
  - "Implement command cooldowns to reduce API calls"
  - "Cache frequently accessed data"
  - "Use ephemeral messages when privacy allows"

security_checklist:
  - "Token in environment variable"
  - ".env in .gitignore"
  - "Minimal required intents"
  - "Minimal required permissions"
  - "Rate limit handling"
  - "Input validation on user data"
  - "No token logging"
  - "Permission checks in admin commands"
