# Collaboration - Segment CDP
# How this skill works with other skills

version: 1.0.0
skill_id: segment-cdp

prerequisites:
  required: []

  recommended:
    - skill: frontend
      reason: "Client-side Analytics.js integration"
      what_to_know:
        - "Event handling"
        - "SPA routing"
        - "Component lifecycle"

    - skill: backend
      reason: "Server-side tracking implementation"
      what_to_know:
        - "API design"
        - "Webhook processing"
        - "Queue systems"

    - skill: analytics-specialist
      reason: "Tracking plan design and analysis"
      what_to_know:
        - "Event taxonomy"
        - "Metrics design"
        - "Data modeling"

delegation_triggers:
  - trigger: "user needs A/B testing"
    delegate_to: analytics-specialist
    context: "Segment + LaunchDarkly/Optimizely integration"

  - trigger: "user needs data warehouse"
    delegate_to: data-engineer
    context: "Segment to BigQuery/Snowflake/Redshift"

  - trigger: "user needs customer support integration"
    delegate_to: zendesk-integration
    context: "Identify calls syncing to support tools"

  - trigger: "user needs marketing automation"
    delegate_to: hubspot-integration
    context: "Segment to HubSpot destination"

  - trigger: "user needs consent management"
    delegate_to: privacy-specialist
    context: "GDPR/CCPA compliance with Segment"

receives_context_from:
  - skill: frontend
    receives:
      - "SPA routing patterns"
      - "Component event handling"
      - "Client-side state"

  - skill: backend
    receives:
      - "API endpoint patterns"
      - "Queue processing"
      - "Error handling"

  - skill: auth-specialist
    receives:
      - "User identity patterns"
      - "Session management"
      - "Login/logout flows"

provides_context_to:
  - skill: analytics-specialist
    provides:
      - "Event data schema"
      - "Identity resolution"
      - "Tracking implementation"

  - skill: data-engineer
    provides:
      - "Event stream data"
      - "User traits"
      - "Warehouse schema"

  - skill: marketing-automation
    provides:
      - "User identification"
      - "Behavioral events"
      - "Conversion tracking"

escalation_paths:
  - situation: "Complex identity resolution"
    escalate_to: data-engineer
    context: "Cross-device tracking, user merging"

  - situation: "Privacy compliance"
    escalate_to: privacy-specialist
    context: "GDPR, CCPA, consent management"

  - situation: "Data warehouse setup"
    escalate_to: data-engineer
    context: "Segment warehouse destinations"

  - situation: "Mobile SDK integration"
    escalate_to: mobile-developer
    context: "iOS/Android Segment SDKs"

workflow_integration:
  typical_sequence:
    1:
      step: "Set up Segment workspace and sources"
      skills: [segment-cdp]
      output: "Write key, source configuration"

    2:
      step: "Design tracking plan"
      skills: [segment-cdp, analytics-specialist]
      output: "Event taxonomy, property schemas"

    3:
      step: "Implement client-side tracking"
      skills: [segment-cdp, frontend]
      output: "Analytics.js integration"

    4:
      step: "Implement server-side tracking"
      skills: [segment-cdp, backend]
      output: "Node.js SDK integration"

    5:
      step: "Set up identity resolution"
      skills: [segment-cdp, auth-specialist]
      output: "Identify on login, reset on logout"

    6:
      step: "Configure destinations"
      skills: [segment-cdp]
      output: "Connected analytics/marketing tools"

    7:
      step: "Enable Protocols"
      skills: [segment-cdp]
      output: "Schema validation, blocking rules"

  decision_points:
    - question: "Client-side vs server-side tracking?"
      guidance: |
        Client-side (Analytics.js):
        - Page views and UI interactions
        - Form submissions
        - Client context (referrer, URL)
        - Fast implementation

        Server-side (Node.js):
        - Revenue/payment events (trusted)
        - Backend actions
        - Webhook responses
        - Batch processing

        Best practice: Use both. Client for UX events,
        server for business-critical events.

    - question: "Device mode vs cloud mode?"
      guidance: |
        Device mode:
        - SDK loads in browser
        - Direct to destination
        - Better for real-time (live chat)
        - Bypasses Segment processing

        Cloud mode (recommended):
        - Events go through Segment
        - Protocols validation works
        - Single SDK in browser
        - Better performance

        Use cloud mode unless destination requires device mode.

    - question: "Which tracking plan approach?"
      guidance: |
        Start simple:
        - 10-20 core events
        - Required properties only
        - Title Case naming
        - Object + Action pattern

        Scale up:
        - Add Protocols enforcement
        - Implement TypeScript types
        - Add tracking plan tests
        - Use Segment Config API

collaboration_patterns:
  with_nextjs:
    when: "Next.js app with Segment"
    approach: |
      Next.js Analytics.js integration:

      ```typescript
      // lib/segment.ts
      import { AnalyticsBrowser } from '@segment/analytics-next';

      export const analytics = AnalyticsBrowser.load({
        writeKey: process.env.NEXT_PUBLIC_SEGMENT_KEY!,
      });

      // Client component wrapper
      'use client';
      import { useEffect } from 'react';
      import { usePathname, useSearchParams } from 'next/navigation';
      import { analytics } from '@/lib/segment';

      export function SegmentPageTracker() {
        const pathname = usePathname();
        const searchParams = useSearchParams();

        useEffect(() => {
          analytics.page();
        }, [pathname, searchParams]);

        return null;
      }

      // app/layout.tsx
      import { SegmentPageTracker } from '@/components/SegmentPageTracker';

      export default function RootLayout({ children }) {
        return (
          <html>
            <body>
              {children}
              <Suspense fallback={null}>
                <SegmentPageTracker />
              </Suspense>
            </body>
          </html>
        );
      }

      // Server-side tracking
      // app/api/checkout/route.ts
      import { Analytics } from '@segment/analytics-node';

      const serverAnalytics = new Analytics({
        writeKey: process.env.SEGMENT_SERVER_KEY!,
      });

      export async function POST(req: Request) {
        const { userId, order } = await req.json();

        serverAnalytics.track({
          userId,
          event: 'Order Completed',
          properties: {
            order_id: order.id,
            total: order.total,
            currency: order.currency,
          },
        });

        await serverAnalytics.flush();
        return Response.json({ success: true });
      }
      ```

  with_prisma:
    when: "Storing Segment events or syncing data"
    approach: |
      Event storage for analytics:

      ```prisma
      // prisma/schema.prisma
      model AnalyticsEvent {
        id            String    @id @default(cuid())
        userId        String?
        anonymousId   String?
        event         String
        properties    Json
        context       Json?
        timestamp     DateTime
        sentToSegment Boolean   @default(false)
        createdAt     DateTime  @default(now())

        @@index([userId])
        @@index([event])
        @@index([timestamp])
      }

      model UserTraits {
        id            String    @id @default(cuid())
        userId        String    @unique
        email         String?
        name          String?
        plan          String?
        company       String?
        customTraits  Json?
        lastIdentify  DateTime?
        createdAt     DateTime  @default(now())
        updatedAt     DateTime  @updatedAt

        @@index([email])
      }
      ```

      ```typescript
      // lib/server-track.ts
      import { prisma } from '@/lib/prisma';
      import { serverAnalytics } from '@/lib/segment';

      export async function trackServerEvent(
        userId: string,
        event: string,
        properties: Record<string, any>
      ) {
        // Store locally for backup/analysis
        await prisma.analyticsEvent.create({
          data: {
            userId,
            event,
            properties,
            timestamp: new Date(),
          },
        });

        // Send to Segment
        serverAnalytics.track({
          userId,
          event,
          properties,
          timestamp: new Date(),
        });
      }
      ```

  with_queues:
    when: "High-volume tracking or batch processing"
    approach: |
      BullMQ for async Segment events:

      ```typescript
      // lib/analytics-queue.ts
      import { Queue, Worker } from 'bullmq';
      import Redis from 'ioredis';
      import { serverAnalytics } from '@/lib/segment';

      const connection = new Redis(process.env.REDIS_URL);

      export const analyticsQueue = new Queue('segment-events', {
        connection,
        defaultJobOptions: {
          attempts: 3,
          backoff: { type: 'exponential', delay: 1000 },
          removeOnComplete: 1000,
          removeOnFail: 5000,
        },
      });

      // Queue events instead of sending directly
      export async function queueTrack(
        userId: string,
        event: string,
        properties: Record<string, any>
      ) {
        await analyticsQueue.add('track', {
          type: 'track',
          userId,
          event,
          properties,
          timestamp: new Date().toISOString(),
        });
      }

      // Worker processes events
      const worker = new Worker(
        'segment-events',
        async (job) => {
          const { type, ...payload } = job.data;

          switch (type) {
            case 'track':
              serverAnalytics.track(payload);
              break;
            case 'identify':
              serverAnalytics.identify(payload);
              break;
            case 'page':
              serverAnalytics.page(payload);
              break;
          }

          // Batch flush periodically
          if (job.id && parseInt(job.id) % 100 === 0) {
            await serverAnalytics.flush();
          }
        },
        { connection, concurrency: 10 }
      );

      // Flush on worker shutdown
      process.on('SIGTERM', async () => {
        await serverAnalytics.flush();
        await worker.close();
      });
      ```

  with_consent:
    when: "GDPR/CCPA compliance required"
    approach: |
      Consent-aware analytics:

      ```typescript
      // lib/consent-analytics.ts
      import { AnalyticsBrowser } from '@segment/analytics-next';

      let analytics: AnalyticsBrowser | null = null;

      // Check consent before loading
      export function initAnalytics() {
        const consent = getConsentPreferences();

        if (!consent.analytics) {
          console.log('Analytics consent not granted');
          return;
        }

        analytics = AnalyticsBrowser.load({
          writeKey: process.env.NEXT_PUBLIC_SEGMENT_KEY!,
        });
      }

      // Wrapper functions that respect consent
      export function track(event: string, properties?: Record<string, any>) {
        if (!analytics) return;
        analytics.track(event, properties);
      }

      export function identify(userId: string, traits?: Record<string, any>) {
        if (!analytics) return;
        analytics.identify(userId, traits);
      }

      export function page(name?: string, properties?: Record<string, any>) {
        if (!analytics) return;
        analytics.page(name, properties);
      }

      // Handle consent changes
      export function handleConsentChange(consent: ConsentPreferences) {
        if (consent.analytics && !analytics) {
          initAnalytics();
        } else if (!consent.analytics && analytics) {
          analytics.reset();
          analytics = null;
        }

        saveConsentPreferences(consent);
      }

      // Using Segment's OneTrust wrapper
      import { withOneTrust } from '@segment/analytics-consent-wrapper-onetrust';

      const analyticsWithConsent = withOneTrust(AnalyticsBrowser);
      export const analytics = analyticsWithConsent.load({
        writeKey: process.env.NEXT_PUBLIC_SEGMENT_KEY!,
      });
      ```

  with_typescript:
    when: "Type-safe event tracking"
    approach: |
      TypeScript tracking plan types:

      ```typescript
      // types/analytics.ts
      export interface TrackingPlan {
        // User events
        'User Signed Up': {
          signup_method: 'email' | 'google' | 'github';
          referral_code?: string;
        };
        'User Logged In': {
          login_method: 'email' | 'google' | 'github';
        };
        'User Logged Out': Record<string, never>;

        // Product events
        'Product Viewed': {
          product_id: string;
          product_name: string;
          category?: string;
          price?: number;
        };
        'Product Added to Cart': {
          product_id: string;
          quantity: number;
          price: number;
        };

        // Conversion events
        'Order Completed': {
          order_id: string;
          total: number;
          currency: string;
          products: Array<{
            product_id: string;
            quantity: number;
            price: number;
          }>;
        };
      }

      // Type-safe track function
      export function track<K extends keyof TrackingPlan>(
        event: K,
        properties: TrackingPlan[K]
      ) {
        analytics.track(event, properties);
      }

      // Usage - TypeScript enforces correct properties
      track('User Signed Up', {
        signup_method: 'google',  // Must be valid enum
        referral_code: 'ABC123',
      });

      track('Order Completed', {
        order_id: 'ord_123',
        total: 99.99,
        currency: 'USD',
        products: [
          { product_id: 'prod_1', quantity: 2, price: 49.99 },
        ],
      });
      ```

platform_integration:
  vercel:
    setup: |
      # Environment variables
      NEXT_PUBLIC_SEGMENT_KEY=xxx  # Client-side write key
      SEGMENT_SERVER_KEY=xxx       # Server-side write key

      # For consent wrapper
      NEXT_PUBLIC_ONETRUST_DOMAIN_ID=xxx

  react_native:
    setup: |
      # React Native Segment SDK
      npm install @segment/analytics-react-native

      # Configure
      import { createClient } from '@segment/analytics-react-native';

      const segmentClient = createClient({
        writeKey: 'YOUR_WRITE_KEY',
        trackAppLifecycleEvents: true,
      });

      // Usage
      segmentClient.track('Button Pressed', {
        button_name: 'checkout',
      });

      segmentClient.identify('user-123', {
        email: 'user@example.com',
      });

security_checklist:
  - "Write key from environment variables only"
  - "Server write key never exposed to client"
  - "PII handled according to privacy policy"
  - "Consent checked before tracking for GDPR"
  - "Reset called on user logout"
  - "No sensitive data in event properties"
  - "Destinations limited for PII events"
  - "Protocols enabled for data quality"

testing_patterns:
  unit_tests: |
    // Mock Segment for testing
    import { analytics } from '@/lib/segment';

    jest.mock('@/lib/segment', () => ({
      analytics: {
        track: jest.fn(),
        identify: jest.fn(),
        page: jest.fn(),
        reset: jest.fn(),
      },
    }));

    describe('Checkout tracking', () => {
      it('tracks Order Completed event', async () => {
        await completeCheckout(order);

        expect(analytics.track).toHaveBeenCalledWith(
          'Order Completed',
          expect.objectContaining({
            order_id: order.id,
            total: order.total,
          })
        );
      });
    });

  integration_tests: |
    // Test with Segment Debugger
    // 1. Enable Segment Debugger in browser
    // 2. Perform user actions
    // 3. Verify events appear in debugger
    // 4. Check properties match tracking plan

    // Or use Segment's Event Tester API
    const response = await fetch('https://api.segment.io/v1/track', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Basic ${btoa(writeKey + ':')}`,
      },
      body: JSON.stringify({
        userId: 'test-user',
        event: 'Test Event',
        properties: { test: true },
      }),
    });

    expect(response.ok).toBe(true);
