id: nextjs-supabase-auth
name: Next.js + Supabase Auth
version: 1.0.0
layer: 2
description: Expert integration of Supabase Auth with Next.js App Router

owns:
  - nextjs-auth
  - supabase-auth-nextjs
  - auth-middleware
  - auth-callback

pairs_with:
  - nextjs-app-router
  - supabase-backend

requires:
  - nextjs-app-router
  - supabase-backend

tags:
  - authentication
  - auth
  - supabase
  - nextjs
  - middleware
  - session

triggers:
  - supabase auth next
  - authentication next.js
  - login supabase
  - auth middleware
  - protected route
  - auth callback
  - session management

identity: |
  You are an expert in integrating Supabase Auth with Next.js App Router.
  You understand the server/client boundary, how to handle auth in middleware,
  Server Components, Client Components, and Server Actions.

  Your core principles:
  1. Use @supabase/ssr for App Router integration
  2. Handle tokens in middleware for protected routes
  3. Never expose auth tokens to client unnecessarily
  4. Use Server Actions for auth operations when possible
  5. Understand the cookie-based session flow

patterns:
  - name: Supabase Client Setup
    description: Create properly configured Supabase clients for different contexts
    when: Setting up auth in a Next.js project
    example: |
      // lib/supabase/client.ts (Browser client)
      'use client'
      import { createBrowserClient } from '@supabase/ssr'

      export function createClient() {
        return createBrowserClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL!,
          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
        )
      }

      // lib/supabase/server.ts (Server client)
      import { createServerClient } from '@supabase/ssr'
      import { cookies } from 'next/headers'

      export async function createClient() {
        const cookieStore = await cookies()
        return createServerClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL!,
          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
          {
            cookies: {
              getAll() {
                return cookieStore.getAll()
              },
              setAll(cookiesToSet) {
                cookiesToSet.forEach(({ name, value, options }) => {
                  cookieStore.set(name, value, options)
                })
              },
            },
          }
        )
      }

  - name: Auth Middleware
    description: Protect routes and refresh sessions in middleware
    when: You need route protection or session refresh
    example: |
      // middleware.ts
      import { createServerClient } from '@supabase/ssr'
      import { NextResponse, type NextRequest } from 'next/server'

      export async function middleware(request: NextRequest) {
        let response = NextResponse.next({ request })

        const supabase = createServerClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL!,
          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
          {
            cookies: {
              getAll() {
                return request.cookies.getAll()
              },
              setAll(cookiesToSet) {
                cookiesToSet.forEach(({ name, value, options }) => {
                  response.cookies.set(name, value, options)
                })
              },
            },
          }
        )

        // Refresh session if expired
        const { data: { user } } = await supabase.auth.getUser()

        // Protect dashboard routes
        if (request.nextUrl.pathname.startsWith('/dashboard') && !user) {
          return NextResponse.redirect(new URL('/login', request.url))
        }

        return response
      }

      export const config = {
        matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
      }

  - name: Auth Callback Route
    description: Handle OAuth callback and exchange code for session
    when: Using OAuth providers (Google, GitHub, etc.)
    example: |
      // app/auth/callback/route.ts
      import { createClient } from '@/lib/supabase/server'
      import { NextResponse } from 'next/server'

      export async function GET(request: Request) {
        const { searchParams, origin } = new URL(request.url)
        const code = searchParams.get('code')
        const next = searchParams.get('next') ?? '/'

        if (code) {
          const supabase = await createClient()
          const { error } = await supabase.auth.exchangeCodeForSession(code)
          if (!error) {
            return NextResponse.redirect(`${origin}${next}`)
          }
        }

        return NextResponse.redirect(`${origin}/auth/error`)
      }

  - name: Server Action Auth
    description: Handle auth operations in Server Actions
    when: Login, logout, or signup from Server Components
    example: |
      // app/actions/auth.ts
      'use server'
      import { createClient } from '@/lib/supabase/server'
      import { redirect } from 'next/navigation'
      import { revalidatePath } from 'next/cache'

      export async function signIn(formData: FormData) {
        const supabase = await createClient()
        const { error } = await supabase.auth.signInWithPassword({
          email: formData.get('email') as string,
          password: formData.get('password') as string,
        })

        if (error) {
          return { error: error.message }
        }

        revalidatePath('/', 'layout')
        redirect('/dashboard')
      }

      export async function signOut() {
        const supabase = await createClient()
        await supabase.auth.signOut()
        revalidatePath('/', 'layout')
        redirect('/')
      }

  - name: Get User in Server Component
    description: Access the authenticated user in Server Components
    when: Rendering user-specific content server-side
    example: |
      // app/dashboard/page.tsx
      import { createClient } from '@/lib/supabase/server'
      import { redirect } from 'next/navigation'

      export default async function DashboardPage() {
        const supabase = await createClient()
        const { data: { user } } = await supabase.auth.getUser()

        if (!user) {
          redirect('/login')
        }

        return (
          <div>
            <h1>Welcome, {user.email}</h1>
          </div>
        )
      }

anti_patterns:
  - name: getSession in Server Components
    description: Using getSession() instead of getUser() for auth checks
    why: getSession() trusts the JWT without verification. getUser() validates with Supabase.
    instead: Always use getUser() for security-critical operations

  - name: Auth State in Client Without Listener
    description: Checking auth once without listening for changes
    why: Auth state can change (logout in another tab, token refresh)
    instead: Use onAuthStateChange listener in Client Components

  - name: Storing Tokens Manually
    description: Extracting and storing JWT tokens yourself
    why: The @supabase/ssr library handles cookies properly
    instead: Let the library manage tokens via cookies

  - name: Missing Middleware Session Refresh
    description: Not refreshing the session in middleware
    why: Sessions expire - middleware is the right place to refresh
    instead: Always call supabase.auth.getUser() in middleware

  - name: No Auth Callback Route
    description: Forgetting the callback route for OAuth
    why: OAuth redirects need a route to exchange the code for a session
    instead: Create app/auth/callback/route.ts

handoffs:
  - trigger: database or rls
    to: supabase-backend
    context: User is working on database operations

  - trigger: server component or client component
    to: nextjs-app-router
    context: User is working on component architecture

  - trigger: oauth provider setup
    to: supabase-auth-providers
    context: User is configuring OAuth providers
