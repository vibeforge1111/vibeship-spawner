id: demoscene-coding
skill: Demoscene Coding
version: "1.0"

receives_context_from:
  - skill: threejs-3d-graphics
    receives:
      - Scene composition
      - Material systems
      - Animation patterns
    provides:
      - Size-optimized shader techniques
      - Minimal WebGL setup
      - Procedural geometry SDFs

  - skill: procedural-generation
    receives:
      - Noise functions
      - Terrain algorithms
      - Content generation patterns
    provides:
      - Size-constrained implementations
      - Shader-only generation
      - Byte-optimized noise

  - skill: generative-art
    receives:
      - Visual patterns
      - Color theory
      - Aesthetic principles
    provides:
      - Minimal code implementations
      - GLSL pattern techniques
      - Size-optimized effects

  - skill: game-design
    receives:
      - Game loop patterns
      - Interactive mechanics
      - Player engagement
    provides:
      - Demo pacing techniques
      - Audience engagement
      - Timing and sync

delegation_triggers:
  - pattern: "game|gameplay|player interaction"
    delegate_to: game-design
    context: "Need game mechanics beyond demo visuals"

  - pattern: "full 3D scene|object loading|GLTF"
    delegate_to: threejs-3d-graphics
    context: "Need full 3D engine features"

  - pattern: "level generation|dungeon|terrain"
    delegate_to: procedural-generation
    context: "Need game-scale content generation"

  - pattern: "nft|collection|generative series"
    delegate_to: generative-art
    context: "Focus on art over size optimization"

  - pattern: "VR|AR|immersive"
    delegate_to: vr-ar-development
    context: "Need XR platform features"

common_combinations:
  - name: WebGL Demo
    skills:
      - demoscene-coding
      - threejs-3d-graphics
    workflow: |
      1. Design visual concept (demoscene-coding)
      2. Prototype with Three.js (threejs-3d-graphics)
      3. Port to minimal WebGL (demoscene-coding)
      4. Optimize and pack (demoscene-coding)

  - name: Procedural Demo
    skills:
      - demoscene-coding
      - procedural-generation
    workflow: |
      1. Design world rules (procedural-generation)
      2. Implement in size-constrained GLSL (demoscene-coding)
      3. Add procedural audio (demoscene-coding)

  - name: Interactive Demo
    skills:
      - demoscene-coding
      - game-design
    workflow: |
      1. Design interaction (game-design)
      2. Implement minimal input handling (demoscene-coding)
      3. Size-optimize the loop (demoscene-coding)

  - name: 64K Production
    skills:
      - demoscene-coding
      - threejs-3d-graphics
      - procedural-generation
    workflow: |
      1. Plan scenes and transitions (demoscene-coding)
      2. Build scene framework (threejs-3d-graphics)
      3. Add procedural content (procedural-generation)
      4. Compose with synth music (demoscene-coding)

cross_domain_insights:
  - domain: Mathematics
    insight: Complex visuals from simple formulas
    application: SDFs, noise functions, parametric equations

  - domain: Signal Processing
    insight: Audio synthesis from waveforms
    application: Bytebeat, FM synthesis, filters

  - domain: Computer Graphics History
    insight: Techniques from Amiga/C64 era
    application: Palette effects, raster tricks, mode switching

  - domain: Music Theory
    insight: Harmony, rhythm, and structure
    application: Procedural composition, arpeggios, chord progressions

  - domain: Data Compression
    insight: Entropy and symbol frequency
    application: Code packing, shader minification

ecosystem_alternatives:
  web_frameworks:
    - name: Raw WebGL
      when: Maximum control, smallest size
      tradeoff: Most work, least abstraction
    - name: Shadertoy
      when: Shader prototyping, community feedback
      tradeoff: Not standalone, different constraints
    - name: Three.js
      when: Complex 3D needs, 64K+ size
      tradeoff: Large bundle, not for 4K
    - name: Babylon.js
      when: Full game engine needed
      tradeoff: Massive bundle

  audio_approaches:
    - name: Bytebeat
      when: Smallest size, experimental sound
      tradeoff: Limited musical control
    - name: Web Audio API
      when: Full synth control
      tradeoff: More code
    - name: SoundBox
      when: Traditional tracker music
      tradeoff: External tool needed
    - name: 4klang/Oidos
      when: Native demos
      tradeoff: Not for web

  size_optimizers:
    - name: Terser
      when: Standard JS minification
      tradeoff: Good baseline
    - name: RegPack
      when: Extreme JS compression
      tradeoff: Specialized for demos
    - name: Shader Minifier
      when: GLSL-specific optimization
      tradeoff: Separate tool chain
    - name: Crinkler/kkrunchy
      when: Native executables
      tradeoff: Not for web demos

feedback_loops:
  - from: party_results
    incorporates:
      - Competition ranking
      - Audience reactions
      - Judge comments
    into: Technique refinement

  - from: community_feedback
    incorporates:
      - pouet.net comments
      - Other sceners' opinions
      - Technical discussions
    into: Style evolution

  - from: optimization_discoveries
    incorporates:
      - New size tricks
      - GPU quirks found
      - Formula refinements
    into: Personal knowledge base

prerequisites:
  required_knowledge:
    - WebGL fundamentals
    - GLSL shader programming
    - Basic linear algebra
    - JavaScript fluency
    - Understanding of size constraints

  recommended_tools:
    - Browser DevTools for WebGL debugging
    - Terser/RegPack for JS compression
    - Shader editors (Shadertoy, glslsandbox)
    - Audio workstation for reference
    - Multiple browsers for testing

  environment_setup: |
    # Demo development setup
    mkdir -p demo-project/{src,dist,shaders}
    cd demo-project

    # Initialize npm project
    npm init -y
    npm install --save-dev terser regpack-cli http-server

    # Shader development file
    cat > shaders/main.frag << 'EOF'
    #version 300 es
    precision highp float;
    uniform float t;
    uniform vec2 r;
    out vec4 O;

    void main() {
      vec2 uv = (gl_FragCoord.xy - .5 * r) / r.y;

      // Your effect here
      vec3 col = vec3(0);
      col.rg = uv + .5;
      col.b = sin(t) * .5 + .5;

      O = vec4(col, 1);
    }
    EOF

    # Minimal HTML template
    cat > src/index.html << 'EOF'
    <!DOCTYPE html>
    <html>
    <head><style>*{margin:0}canvas{display:block}</style></head>
    <body><script src="demo.js"></script></body>
    </html>
    EOF

    # Build script
    cat > package.json << 'EOF'
    {
      "scripts": {
        "dev": "http-server -p 8080 src",
        "build": "terser src/demo.js -c -m --toplevel -o dist/demo.min.js",
        "size": "wc -c dist/demo.min.js",
        "pack": "regpack dist/demo.min.js > dist/demo.packed.js && wc -c dist/demo.packed.js"
      }
    }
    EOF

    # Start development
    npm run dev
    # Open http://localhost:8080 in browser

    echo "Demo project initialized!"
    echo "Edit src/demo.js, then: npm run build && npm run size"
