import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const TEMPLATES_DIR = path.join(__dirname, '..', 'templates');
// Skills are stored in the parent repo's skills directory
const SKILLS_DIR = path.join(__dirname, '..', '..', 'skills');

/**
 * Scaffold a new project from config
 */
export async function scaffoldProject(config, targetDir) {
  // Create project directory
  await fs.mkdir(targetDir, { recursive: true });

  // Create subdirectories
  await fs.mkdir(path.join(targetDir, 'docs'), { recursive: true });
  await fs.mkdir(path.join(targetDir, 'skills'), { recursive: true });
  await fs.mkdir(path.join(targetDir, '.claude'), { recursive: true });

  // Generate and write files
  await Promise.all([
    writeClaudeMd(config, targetDir),
    writeStateJson(config, targetDir),
    writeTaskQueue(config, targetDir),
    writePrdTemplate(config, targetDir),
    writeArchitectureTemplate(config, targetDir),
    writeSkillSchema(targetDir),
    copySkills(config, targetDir),
    writeClaudeSettings(config, targetDir)
  ]);

  return targetDir;
}

async function writeClaudeMd(config, targetDir) {
  const behaviors = config.behaviors || { mandatory: [], selected: [] };
  const allBehaviors = [...(behaviors.mandatory || []), ...(behaviors.selected || [])];

  // Try to read template, fall back to inline generation
  let content;
  try {
    content = await fs.readFile(path.join(TEMPLATES_DIR, 'CLAUDE.md'), 'utf-8');
    // Replace template variables
    content = content.replace(/\{\{project_name\}\}/g, config.project_name);
    content = content.replace(/\{\{description\}\}/g, config.description || 'A VibeShip project');
    content = content.replace(/\{\{agents\}\}/g, config.agents.join(', '));
    content = content.replace(/\{\{mcps\}\}/g, config.mcps.join(', '));
    content = content.replace(/\{\{behaviors\}\}/g, allBehaviors.map(b => `- ${b}`).join('\n') || '- None selected');
  } catch {
    // Fallback to inline content if template not found
    content = `# ${config.project_name}

> ${config.description || 'A VibeShip project'}

---

## Quick Start

This project was scaffolded with VibeShip Orchestrator.

Run \`claude\` to start building.

---

## Stack

### Agents
${config.agents.map(a => `- ${a}`).join('\n')}

### MCPs
${config.mcps.map(m => `- ${m}`).join('\n')}

### Build Disciplines
${allBehaviors.map(b => `- ${b}`).join('\n') || '- None selected'}

---

## Project State

- \`state.json\` - Current phase and decisions
- \`task_queue.json\` - Task breakdown and progress
- \`docs/PRD.md\` - Product requirements
- \`docs/ARCHITECTURE.md\` - Technical decisions

---

## Commands

| Command | Action |
|---------|--------|
| \`status\` | Show current phase and progress |
| \`continue\` | Resume from last checkpoint |
| \`replan\` | Go back to planning phase |

---

Built with VibeShip. "You vibe. It ships."
`;
  }

  await fs.writeFile(path.join(targetDir, 'CLAUDE.md'), content);
}

async function writeStateJson(config, targetDir) {
  const state = {
    version: 1,
    project_name: config.project_name,
    description: config.description || '',
    phase: 'planning',
    discovery: config.discovery || {},
    stack: {
      agents: config.agents,
      mcps: config.mcps
    },
    behaviors: config.behaviors || { mandatory: [], selected: [] },
    custom_skills_needed: config.custom_skills_needed || [],
    checkpoint: {
      last_task: null,
      timestamp: new Date().toISOString()
    },
    decisions: [],
    assumptions: []
  };

  await fs.writeFile(
    path.join(targetDir, 'state.json'),
    JSON.stringify(state, null, 2)
  );
}

async function writeTaskQueue(config, targetDir) {
  const queue = {
    version: 1,
    tasks: []
  };

  await fs.writeFile(
    path.join(targetDir, 'task_queue.json'),
    JSON.stringify(queue, null, 2)
  );
}

async function writePrdTemplate(config, targetDir) {
  let content;
  try {
    content = await fs.readFile(path.join(TEMPLATES_DIR, 'docs', 'PRD.md'), 'utf-8');
    content = content.replace(/\{\{project_name\}\}/g, config.project_name);
    content = content.replace(/\{\{description\}\}/g, config.description || '[To be filled by planner]');
  } catch {
    content = `# Product Requirements Document

## Project: ${config.project_name}

### Overview

${config.description || '[To be filled by planner]'}

---

### Problem Statement

[What problem does this solve?]

---

### Target User

[Who is this for?]

---

### Core Features

[Priority ordered list of features]

1.
2.
3.

---

### Out of Scope (V1)

[What are we NOT building?]

-

---

### Success Criteria

[How do we know this works?]

-

---

*Generated by VibeShip Orchestrator*
`;
  }

  await fs.writeFile(path.join(targetDir, 'docs', 'PRD.md'), content);
}

async function writeArchitectureTemplate(config, targetDir) {
  let content;
  try {
    content = await fs.readFile(path.join(TEMPLATES_DIR, 'docs', 'ARCHITECTURE.md'), 'utf-8');
    content = content.replace(/\{\{project_name\}\}/g, config.project_name);
  } catch {
    content = `# Architecture

## Project: ${config.project_name}

---

### System Overview

[High-level system diagram]

---

### Tech Stack

| Layer | Technology |
|-------|------------|
| Frontend | [TBD] |
| Backend | [TBD] |
| Database | [TBD] |
| Auth | [TBD] |

---

### File Structure

\`\`\`
${config.project_name}/
├── src/
├── docs/
└── ...
\`\`\`

---

### Data Models

[Key entities and relationships]

---

### API Routes

[Key endpoints]

---

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| | |

---

*Generated by VibeShip Orchestrator*
`;
  }

  await fs.writeFile(path.join(targetDir, 'docs', 'ARCHITECTURE.md'), content);
}

async function writeSkillSchema(targetDir) {
  const content = `# Skill Schema

> Shared protocols for all skills

---

## State Management

All skills must read/write state through these files:

| File | Purpose |
|------|---------|
| \`state.json\` | Current phase, decisions, assumptions |
| \`task_queue.json\` | Tasks and their status |

---

## Mandatory Behaviors

Before marking ANY task complete:

1. **Verify** - Run the code/tests, confirm working
2. **Architecture check** - Confirm no deviation from ARCHITECTURE.md
3. **Security scan** - Check for secrets, validate inputs
4. **Maintainability** - Clear naming, no magic numbers, logical structure

---

## Task Status

| Status | Meaning |
|--------|---------|
| \`pending\` | Not started |
| \`in_progress\` | Currently working |
| \`completed\` | Done and verified |
| \`blocked\` | Waiting on something |

---

## Handoff Protocol

When completing a task:

1. Update task status in \`task_queue.json\`
2. Update checkpoint in \`state.json\`
3. Return control to planner

---

*VibeShip Orchestrator Schema v1*
`;

  await fs.writeFile(path.join(targetDir, 'skills', '_schema.md'), content);
}

async function copySkills(config, targetDir) {
  // Copy real skill files from the skills directory
  // Falls back to generating placeholder if skill file not found

  // Always copy the schema first
  try {
    const schemaContent = await fs.readFile(path.join(SKILLS_DIR, '_schema.md'), 'utf-8');
    await fs.writeFile(path.join(targetDir, 'skills', '_schema.md'), schemaContent);
  } catch {
    // Schema was already written by writeSkillSchema, so this is fine
  }

  // Copy each selected agent's skill file
  for (const agent of config.agents) {
    const skillFileName = `${agent}.md`;
    const sourceSkillPath = path.join(SKILLS_DIR, skillFileName);
    const targetSkillPath = path.join(targetDir, 'skills', skillFileName);

    try {
      // Try to copy the real skill file from the repo
      const skillContent = await fs.readFile(sourceSkillPath, 'utf-8');
      await fs.writeFile(targetSkillPath, skillContent);
    } catch {
      // If skill file not found, create a placeholder
      const skillContent = `# ${agent.charAt(0).toUpperCase() + agent.slice(1)} Skill

> Agent: ${agent}

---

## Read First

Before any work, read \`skills/_schema.md\` for state management protocols.

---

## Identity

You are the ${agent} agent for this project.

---

## Capabilities

[To be customized based on project needs]

---

## Workflow

1. Read your assigned task from task_queue.json
2. Execute the task following architecture guidelines
3. Update task status when complete
4. Return control to planner

---

*Always read skills/_schema.md first*
`;

      await fs.writeFile(targetSkillPath, skillContent);
    }
  }
}

async function writeClaudeSettings(config, targetDir) {
  const settings = {
    version: 1,
    project: config.project_name,
    mcps: config.mcps
  };

  await fs.writeFile(
    path.join(targetDir, '.claude', 'settings.json'),
    JSON.stringify(settings, null, 2)
  );
}
